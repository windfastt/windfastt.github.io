var ur = Object.defineProperty; var dr = (u, e, t) => e in u ? ur(u, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : u[e] = t; var s = (u, e, t) => dr(u, typeof e != "symbol" ? e + "" : e, t); import { $ as c, i as Ee, C as ie, T as X, S as re, G as Se, a as pr, b as Ye, R as fr, c as wr, P as Bt, d as nt, B as Vt, e as Wt, f as gr, s as Sr, g as yr, A as xr } from "./vendor-taVxPZ7O.js"; import { G as N, a as F, u as y, m as _, v as h, C as Qe, c as U, P as $e, E as fe, b as qe, I as E, T as we, d as ke, M as oe, e as Pe, f as lt, O as pe, g as Ei, h as Je, i as zr, j as br, B as ht, k as Ut, l as kr, A as ce, n as se, H as Ve, o as dt, R as Ri, S as kt, p as vt, D as We, q as Le, J as vr, r as ue, s as Gt, t as $t, W as rt, U as _r, w as Ir, x as Mr, y as Tr, z as Ht, F as Pr, K as Cr, L as Dr, N as Lr, Q as Ar, V as Br, X as Er, Y as Rr, Z as Or, _ as Nr, $ as _t, a0 as Me, a1 as Et, a2 as Xt } from "./shared-DnGgH_M2.js"; (function() { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const a of r) if (a.type === "childList") for (const m of a.addedNodes) m.tagName === "LINK" && m.rel === "modulepreload" && i(m) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const a = {}; return r.integrity && (a.integrity = r.integrity), r.referrerPolicy && (a.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? a.credentials = "include" : r.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function i(r) { if (r.ep) return; r.ep = !0; const a = t(r); fetch(r.href, a) } })(); const Fr = "https://surviv.mathsiscoolfun.com", et = { resolveUrl: function(u) { return Fr + u }, resolveRoomHost: function() { return "surviv.mathsiscoolfun.com" } }, je = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) { return typeof u } : function(u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, Zt = Array.prototype.slice, Kt = Object.keys, jr = function() { return Object.prototype.toString.call(arguments) }() == "[object Arguments]"; function qr(u) { return Object.prototype.toString.call(u) == "[object Arguments]" } function Vr(u) { return u && (typeof u > "u" ? "undefined" : je(u)) == "object" && typeof u.length == "number" && Object.prototype.hasOwnProperty.call(u, "callee") && !Object.prototype.propertyIsEnumerable.call(u, "callee") || !1 } const Yt = jr ? qr : Vr, It = function(u, e, t) { return t || (t = {}), u === e ? !0 : u instanceof Date && e instanceof Date ? u.getTime() === e.getTime() : !u || !e || (typeof u > "u" ? "undefined" : je(u)) != "object" && (typeof e > "u" ? "undefined" : je(e)) != "object" ? t.strict ? u === e : u == e : Wr(u, e, t) }; function Qt(u) { return u == null } function Jt(u) { return !(!u || (typeof u > "u" ? "undefined" : je(u)) !== "object" || typeof u.length != "number" || typeof u.copy != "function" || typeof u.slice != "function" || u.length > 0 && typeof u[0] != "number") } function Wr(u, e, t) { let i, r; if (Qt(u) || Qt(e) || u.prototype !== e.prototype) return !1; if (Yt(u)) return Yt(e) ? (u = Zt.call(u), e = Zt.call(e), It(u, e, t)) : !1; if (Jt(u)) { if (!Jt(e) || u.length !== e.length) return !1; for (i = 0; i < u.length; i++) if (u[i] !== e[i]) return !1; return !0 } let a, m; try { a = Kt(u), m = Kt(e) } catch { return !1 } if (a.length != m.length) return !1; for (a.sort(), m.sort(), i = a.length - 1; i >= 0; i--) if (a[i] != m[i]) return !1; for (i = a.length - 1; i >= 0; i--) if (r = a[i], !It(u[r], e[r], t)) return !1; return (typeof u > "u" ? "undefined" : je(u)) === (typeof e > "u" ? "undefined" : je(e)) } var Oi = (u => (u[u.New = 0] = "New", u[u.Confirmed = 1] = "Confirmed", u[u.Ackd = 2] = "Ackd", u))(Oi || {}); const ne = { ItemStatus: Oi, validate: function(u) { const e = function(m, o, n) { const p = F[o]; return p && p.type == m ? o : n }, t = function(m, o) { const n = parseFloat(m); return Number.isNaN(n) ? o : n }, i = { crosshair: { type: "", color: 16777215, size: 1, stroke: 0 }, emotes: [], ...u }, r = { outfit: e("outfit", i.outfit, "outfitBase"), melee: e("melee", i.melee, "fists"), heal: e("heal_effect", i.heal, "heal_basic"), boost: e("boost_effect", i.boost, "boost_basic"), player_icon: e("emote", i.player_icon, ""), crosshair: { type: e("crosshair", i.crosshair.type, "crosshair_default"), color: parseInt(i.crosshair.color) || 16777215, size: t(i.crosshair.size, 1).toFixed(2), stroke: t(i.crosshair.stroke, 0).toFixed(2) }, emotes: [] }, a = N.defaultEmoteLoadout.slice(); for (let m = 0; m < N.EmoteSlot.Count; m++) { const o = m < i.emotes.length ? i.emotes[m] : ""; r.emotes.push(e("emote", o, a[m])) } return r }, defaultLoadout: function() { return ne.validate({}) }, modified: function(u, e) { return !It(u, e) }, getUserAvailableItems: function(u) { const e = [], t = F.unlock_default; for (let i = 0; i < t.unlocks.length; i++) { const r = t.unlocks[i]; e.push({ type: r, source: "unlock_default", timeAcquired: 0, ackd: ne.ItemStatus.Ackd }) } for (let i = 0; i < u.length; i++) e.push(u[i]); return e } }; function Ur(u, e, t) { typeof e == "function" && (t = e, e = null); const i = { url: et.resolveUrl(u), type: "POST", timeout: 10 * 1e3, headers: { "X-Requested-With": "XMLHttpRequest" } }; e && (i.contentType = "application/json; charset=utf-8", i.data = JSON.stringify(e)), c.ajax(i).done(r => { t(null, r) }).fail(r => { t(r) }) } class Gr { constructor(e) { s(this, "events", {}); s(this, "requestsInFlight", 0); s(this, "loggingIn", !1); s(this, "loggedIn", !1); s(this, "profile", { linkedTwitch: !1, linkedDiscord: !1, usernameSet: !1, username: "", slug: "", usernameChangeTime: 0 }); s(this, "loadout", ne.defaultLoadout()); s(this, "loadoutPriv", ""); s(this, "items", []); s(this, "quests", []); s(this, "questPriv", ""); s(this, "pass", {}); this.config = e, window.login = () => { this.login() }, window.deleteAccount = () => { this.deleteAccount() }, window.deleteItems = () => { this.ajaxRequest("/api/user/delete_items", {}, (t, i) => { this.loadProfile() }) }, window.unlock = t => { console.log(`Unlocking ${t}`), this.unlock(t) }, window.setQuest = (t, i = 0) => { this.ajaxRequest("/api/user/set_quest", { questType: t, idx: i }, (r, a) => { this.getPass() }) }, window.refreshQuest = t => { this.refreshQuest(t) }, window.setPassUnlock = t => { this.setPassUnlock(t) } } ajaxRequest(e, t, i) { typeof t == "function" && (i = t, t = null), this.requestsInFlight++, this.emit("request", this), Ur(e, t, (r, a) => { i(r, a), this.requestsInFlight--, this.emit("request", this), this.requestsInFlight == 0 && this.emit("requestsComplete") }) } addEventListener(e, t) { this.events[e] = this.events[e] || [], this.events[e].push(t) } removeEventListener(e, t) { const i = this.events[e] || []; for (let r = i.length - 1; r >= 0; r--) i[r] == t && i.splice(r, 1) } emit(e, ...t) { const i = (this.events[e] || []).slice(0); for (let r = 0; r < i.length; r++) i[r](...t) } init() { this.config.get("sessionCookie") && this.setSessionCookies(), this.login() } setSessionCookies() { this.clearSessionCookies(), document.cookie = this.config.get("sessionCookie"), document.cookie = `app-data=${Date.now()}` } clearSessionCookies() { document.cookie = "app-sid=;expires=Thu, 01 Jan 1970 00:00:01 GMT;", document.cookie = "app-data=;expires=Thu, 01 Jan 1970 00:00:01 GMT;" } loginWithAccessToken(e, t, i) { t((r, a) => { if (r) { this.emit("error", "login_failed"); return } const m = i(a); this.ajaxRequest(`${e}?access_token=${m}`, (o, n) => { o ? this.emit("error", "login_failed") : (this.config.set("sessionCookie", n.cookie), this.setSessionCookies(), this.login()) }) }) } login() { this.loadProfile(), this.getPass(!0) } logout() { this.config.set("profile", null), this.config.set("sessionCookie", null), this.ajaxRequest("/api/user/logout", (e, t) => { window.location.reload() }) } loadProfile() { this.loggingIn = !this.loggedIn, this.ajaxRequest("/api/user/profile", (t, i) => { const r = this.loggingIn; if (this.loggingIn = !1, this.loggedIn = !1, this.profile = {}, this.loadoutPriv = "", this.items = [], t) console.error("account", "load_profile_error"); else if (i.banned) this.emit("error", "account_banned", i.reason); else if (i.success) { this.loggedIn = !0, this.profile = i.profile, this.loadoutPriv = i.loadoutPriv, this.items = i.items; const a = this.config.get("profile") || { slug: "" }; a.slug = i.profile.slug, this.config.set("profile", a) } this.loggedIn || this.config.set("sessionCookie", null), r && this.loggedIn && this.emit("login", this), this.emit("items", this.items) }); const e = this.config.get("loadout"); this.loadout = y.mergeDeep({}, ne.defaultLoadout(), e), this.emit("loadout", this.loadout) } resetStats() { this.ajaxRequest("/api/user/reset_stats", (e, t) => { e && (console.error("account", "reset_stats_error"), this.emit("error", "server_error")) }) } deleteAccount() { this.ajaxRequest("/api/user/delete", (e, t) => { if (e) { console.error("account", "delete_error"), this.emit("error", "server_error"); return } this.config.set("profile", null), this.config.set("sessionCookie", null), window.location.reload() }) } setUsername(e, t) { this.ajaxRequest("/api/user/username", { username: e }, (i, r) => { if (i) { console.error("account", "set_username_error"), t(i); return } r.result == "success" ? (this.loadProfile(), t()) : t(r.result) }) } setLoadout(e) { this.loadout, this.loadout = e, this.emit("loadout", this.loadout), this.config.set("loadout", e) } setItemStatus(e, t) { if (t.length != 0) { for (let i = 0; i < t.length; i++) { const r = this.items.find(a => a.type == t[i]); r && (r.status = Math.max(r.status, e)) } this.emit("items", this.items), this.ajaxRequest("/api/user/set_item_status", { status: e, itemTypes: t }, (i, r) => { i && console.error("account", "set_item_status_error") }) } } unlock(e) { this.ajaxRequest("/api/user/unlock", { unlockType: e }, (t, i) => { if (t || !i.success) { console.error("account", "unlock_error"), this.emit("error", "server_error"); return } this.items = i.items, this.emit("items", this.items) }) } getPass(e) {} setPassUnlock(e) { this.ajaxRequest("/api/user/set_pass_unlock", { unlockType: e }, (t, i) => { t || !i.success ? console.error("account", "set_pass_unlock_error") : this.getPass(!1) }) } refreshQuest(e) { this.ajaxRequest("/api/user/refresh_quest", { idx: e }, (t, i) => { if (t) { console.error("account", "refresh_quest_error"); return } i.success ? this.getPass(!1) : this.emit("pass", this.pass, this.quests, !1) }) } } class $r { constructor() { s(this, "introMusic", !0); s(this, "soundUpdateThrottle", 0); s(this, "tracks"); s(this, "trackToIdx"); s(this, "initTime"); this.tracks = [], this.trackToIdx = {}; const e = (t, i, r, a) => { this.tracks.push({ name: t, sound: i, channel: r, immediateMode: a, inst: null, instSound: "", filter: "", weight: 0, volume: 0 }), this.trackToIdx[t] = this.tracks.length - 1 }; e("music", "menu_music", "music", !1), e("wind", "ambient_wind_01", "ambient", !1), e("river", "ambient_stream_01", "ambient", !1), e("waves", "ambient_waves_01", "ambient", !1), e("interior_0", "", "ambient", !0), e("interior_1", "", "ambient", !0), this.initTime = Date.now() } getTrack(e) { return this.tracks[this.trackToIdx[e]] } onGameStart() { this.introMusic = !1; for (let e = 0; e < this.tracks.length; e++) this.tracks[e].weight = 0; this.getTrack("wind").weight = 1, this.soundUpdateThrottle = 0 } onGameComplete(e) { for (let t = 0; t < this.tracks.length; t++) { const i = this.tracks[t]; i.immediateMode && (i.weight = 0) } this.getTrack("river").weight = 0 } update(e, t, i) { let r = !1; this.soundUpdateThrottle -= e, this.soundUpdateThrottle <= 0 && (this.soundUpdateThrottle = .2, r = !0); let a = 0; for (let m = this.tracks.length - 1; m >= 0; m--) { const o = this.tracks[m]; if (!o.inst && o.sound && t.isSoundLoaded(o.sound, o.channel) && (console.log("Start track", o.sound, o.channel), o.inst = t.playSound(o.sound, { channel: o.channel, startSilent: !0, loop: o.channel == "ambient", forceStart: !0, filter: o.filter, forceFilter: !0 }), o.instSound = o.sound, m == 0 && console.log("Play delay", Date.now() - this.initTime)), o.inst && r) { const n = o.weight * (1 - a); a += n, o.volume = n; const p = t.getSoundDefVolume(o.sound, o.channel); t.setVolume(o.inst, n * p, o.channel) } o.inst && (!o.sound && _.eqAbs(t.getVolume(o.inst), 0) || o.sound && o.sound != o.instSound) && (console.log("Stop track", o.name, o.channel), t.stopSound(o.inst), o.inst = null, o.instSound = ""), o.immediateMode && (o.sound = "", o.weight = 0) } if (this.introMusic) { const m = this.getTrack("music"); m.inst && (m.weight = _.min(m.weight + e, 1)); const o = this.getTrack("wind"); m.inst && !t.isSoundPlaying(m.inst) && (o.weight = _.min(o.weight + e, 1)) } } } const Xe = window.navigator.userAgent.includes("iPod") || window.navigator.userAgent.includes("iPhone") || window.navigator.userAgent.includes("iPad"); let Ni = null, Fi = !1; function Hr(u) { try { return u.createGain().disconnect(u.destination), !1 } catch { return !0 } } const Re = 128; class ei { constructor(e) { s(this, "sound", null); s(this, "id", 0); s(this, "volume", 1); s(this, "volumeOld"); s(this, "pan", 0); s(this, "panOld"); s(this, "ambient"); s(this, "sourceNode", null); s(this, "destination", null); s(this, "paramEvents", 0); s(this, "gainNode"); s(this, "pannerNode"); s(this, "stopTime", 0); s(this, "stopping", !1); s(this, "playState", "playFinished"); this.ctx = e, this.volumeOld = this.volume, this.panOld = this.pan, this.gainNode = this.ctx.createGain(), this.pannerNode = this.ctx.createPanner(), this.pannerNode.panningModel = "equalpower", this.gainNode.connect(this.pannerNode) } setGain(e) { this.stopping || (Xe ? this.gainNode.gain.value = e : (this.gainNode.gain.setTargetAtTime(e, this.ctx.currentTime, .02), ++this.paramEvents)) } setPan(e) { this.stopping || (this.pannerNode.setPosition(e, 0, -.5), this.paramEvents += 3) } start(e, t, i, r, a, m, o, n, p) { this.volume = this.volumeOld = i, this.pan = this.panOld = r, this.ambient = n, this.stopping = !1, this.destination = e, this.sourceNode = this.ctx.createBufferSource(), this.sourceNode.buffer = t, this.sourceNode.connect(this.gainNode), this.pannerNode.connect(this.destination), this.sourceNode.loop = a, Xe ? this.gainNode.gain.value = i : (this.gainNode.gain.setValueAtTime(i, this.ctx.currentTime), ++this.paramEvents), this.setPan(r), this.sourceNode.detune && (this.sourceNode.detune.value = p), this.sourceNode.start(this.ctx.currentTime + m, o), this.stopTime = a ? 1e100 : this.ctx.currentTime + m + t.duration - o, this.playState = "playSucceeded" } stop() { this.stopping || (this.setGain(0), this.stopTime = this.ctx.currentTime + .1, this.stopping = !0, this.playState = "playInterrupted") } disconnect() { var e, t, i, r, a; if ((t = this.sound) == null || t.instances.splice((e = this.sound) == null ? void 0 : e.instances.indexOf(this), 1), this.sound = null, (i = this.sourceNode) == null || i.stop(0), (r = this.sourceNode) == null || r.disconnect(this.gainNode), (a = this.pannerNode) == null || a.disconnect(this.destination), Xe) try { this.sourceNode.buffer = Ni } catch {} this.destination = null, this.sourceNode = null, this.playState = "playFinished" } reallocNodes() { this.gainNode.disconnect(this.pannerNode), this.gainNode = this.ctx.createGain(), this.pannerNode = this.ctx.createPanner(), this.pannerNode.panningModel = "equalpower", this.gainNode.connect(this.pannerNode), this.paramEvents = 0 } } let Ne = null; class ti { constructor(e) { s(this, "id"); this.instance = e, this.id = e.id } check(e) { this.id != this.instance.id && (this.instance = Ne, this.id = Ne == null ? void 0 : Ne.id) } stop() { this.check(), this.instance.stop() } get volume() { return this.check(), this.instance.volume } set volume(e) { this.check(!0), this.instance.volume = e } get pan() { return this.check(), this.instance.pan } set pan(e) { this.check(!0), this.instance.pan = e } get playState() { return this.check(), this.instance.playState } } let De = null; class Xr { constructor(e, t, i, r, a) { s(this, "volume"); s(this, "echoVolume"); s(this, "echoDelay"); s(this, "echoLowPass"); s(this, "stereoSpread"); s(this, "gainNode", null); s(this, "convolverNode", null); s(this, "echoGainNode", null); s(this, "echoLowPassNode", null); s(this, "echoDelayNode", null); s(this, "stereoDelayNode", null); s(this, "mergerNode", null); s(this, "targetLevel", 0); s(this, "gain", 0); s(this, "drainEndTime", 0); s(this, "active", !1); if (this.ctx = e, this.inNode = t, this.outNode = i, this.name = r, this.params = a, this.volume = a.volume != null ? a.volume : 1, this.echoVolume = a.echoVolume || 0, this.echoDelay = a.echoDelay || 0, this.echoLowPass = a.echoLowPass || 3e3, this.stereoSpread = a.stereoSpread || 0, !Fi) { const m = this.ctx.createGain(); this.inNode.connect(m), this.inNode = m } this.convolverNode = this.ctx.createConvolver(), this.echoVolume && (this.echoLowPassNode = this.ctx.createBiquadFilter(), this.echoLowPassNode.type = "lowpass", this.echoLowPassNode.frequency.setValueAtTime(this.echoLowPass, 0), this.echoLowPassNode.Q.setValueAtTime(-3.0102999566398125, 0), this.echoDelayNode = this.ctx.createDelay(this.echoDelay || .01), this.echoDelayNode.delayTime.setValueAtTime(this.echoDelay, 0)), this.stereoSpread && (this.stereoDelayNode = this.ctx.createDelay(this.stereoSpread), this.stereoDelayNode.delayTime.setValueAtTime(this.stereoSpread, 0), this.mergerNode = this.ctx.createChannelMerger(2)) } isConnected() { return this.gainNode != null } connect() { var e, t, i, r, a, m, o, n, p; if (this.gainNode = this.ctx.createGain(), this.gainNode.channelCount = 1, this.gainNode.channelCountMode = "explicit", this.gainNode.gain.setValueAtTime(0, 0), this.echoVolume && (this.echoGainNode = this.ctx.createGain(), this.echoGainNode.channelCount = 1, this.echoGainNode.channelCountMode = "explicit", this.echoGainNode.gain.setValueAtTime(this.echoVolume, 0)), this.inNode.connect(this.gainNode), this.gainNode.connect(this.convolverNode), this.echoVolume && ((e = this.convolverNode) == null || e.connect(this.echoGainNode), (t = this.echoGainNode) == null || t.connect(this.echoLowPassNode), (i = this.echoLowPassNode) == null || i.connect(this.echoDelayNode), (r = this.echoDelayNode) == null || r.connect(this.convolverNode)), this.stereoSpread) { const { buffer: d } = this.convolverNode; d && d.numberOfChannels != 1 && console.error("stereoSpread can only be applied to mono IRs"), (a = this.convolverNode) == null || a.connect(this.stereoDelayNode), (m = this.convolverNode) == null || m.connect(this.mergerNode, 0, 0), (o = this.stereoDelayNode) == null || o.connect(this.mergerNode, 0, 1), (n = this.mergerNode) == null || n.connect(this.outNode) } else(p = this.convolverNode) == null || p.connect(this.outNode) } disconnect() { var e, t, i, r, a, m, o, n, p, d; this.inNode.disconnect(this.gainNode), (e = this.gainNode) == null || e.disconnect(this.convolverNode), this.echoVolume && ((t = this.convolverNode) == null || t.disconnect(this.echoGainNode), (i = this.echoGainNode) == null || i.disconnect(this.echoLowPassNode), (r = this.echoLowPassNode) == null || r.disconnect(this.echoDelayNode), (a = this.echoDelayNode) == null || a.disconnect(this.convolverNode)), this.stereoSpread ? ((m = this.convolverNode) == null || m.disconnect(this.stereoDelayNode), (o = this.convolverNode) == null || o.disconnect(this.mergerNode, 0, 0), (n = this.stereoDelayNode) == null || n.disconnect(this.mergerNode, 0, 1), (p = this.mergerNode) == null || p.disconnect(this.outNode)) : (d = this.convolverNode) == null || d.disconnect(this.outNode), this.gainNode = null, this.echoGainNode = null } setGain(e, t, i) { var r, a; if (e *= this.volume, this.gain != e) { if (e != 0 && !this.gainNode && this.connect(), e == 0) { this.echoGainNode && this.echoGainNode.gain.setValueAtTime(0, i); const { buffer: m } = this.convolverNode, o = m ? m.duration : 0; this.drainEndTime = i + o + this.echoDelay + this.stereoSpread } this.gain == 0 && this.echoGainNode && this.echoGainNode.gain.setValueAtTime(this.echoVolume, t), (r = this.gainNode) == null || r.gain.setValueAtTime(this.gain, t), (a = this.gainNode) == null || a.gain.linearRampToValueAtTime(e, i), this.gain = e } } } class Zr { constructor() { s(this, "ctx", new(window.AudioContext || window.webkitAudioContext)); s(this, "masterGainNode"); s(this, "compressorNode"); s(this, "reverbNode"); s(this, "eqNodes", {}); s(this, "files", {}); s(this, "sounds", {}); s(this, "instances", []); s(this, "instanceId", 0); s(this, "playingInstances", []); s(this, "reverbs", {}); s(this, "activeReverbs", []); s(this, "reverbFadeEndTime", 0); s(this, "volume", 1); s(this, "volumeOld"); s(this, "muted", !1); s(this, "mutedOld"); s(this, "runningOfflineTest"); s(this, "offlineCtx"); s(this, "startTime"); s(this, "onfileload", function(...e) {}); s(this, "PLAY_INITED", "playInited"); s(this, "PLAY_SUCCEEDED", "playSucceeded"); s(this, "PLAY_INTERRUPTED", "playInterrupted"); s(this, "PLAY_FINISHED", "playFinished"); s(this, "PLAY_FAILED", "playFailed"); if (Xe) { const t = this.ctx.createBuffer(1, 1, 44100), i = this.ctx.createBufferSource(); i.buffer = t, i.connect(this.ctx.destination), i.start(), i.disconnect(this.ctx.destination), this.ctx.close(), this.ctx = new(window.AudioContext || window.webkitAudioContext) } Fi = Hr(this.ctx), window.audioEngine = this, this.masterGainNode = this.ctx.createGain(), this.compressorNode = this.ctx.createDynamicsCompressor(), this.masterGainNode.connect(this.compressorNode), this.compressorNode.connect(this.ctx.destination), this.reverbNode = this.ctx.createGain(), this.reverbNode.connect(this.masterGainNode); const e = { muffled: [ [20, 2.8284 / 2, -6, "peaking"], [40, 2.8284 / 2, -7, "peaking"], [80, 2.8284 / 2, -10, "peaking"], [160, 2.8284 / 2, -13, "peaking"], [320, 2.8284 / 2, -22, "peaking"], [640, 2.8284 / 2, -18, "peaking"], [1280, 2.8284 / 2, -25, "peaking"], [2560, 2.8284 / 2, -10, "peaking"], [5120, 2.8284 / 2, -30, "peaking"], [10240, 2.8284 / 2, -25, "peaking"] ], club: [ [20, 2.8284 / 2, -6, "lowshelf"], [63, 2.8284 / 2, -3, "lowshelf"], [125, 2.8284 / 2, -3, "lowshelf"], [250, 2.8284 / 2, -6, "lowshelf"], [500, 2.8284 / 2, -18, "peaking"], [1e3, 2.8284 / 2, -36, "peaking"], [2e3, 2.8284 / 2, -48, "peaking"], [4e3, 2.8284 / 2, -50, "highshelf"], [8e3, 2.8284 / 2, -50, "highshelf"], [16e3, 2.8284 / 2, -50, "highshelf"] ] }; Object.keys(e).forEach(t => { const i = this.ctx.createGain(); i.gain.setValueAtTime(16, 0); const r = e[t]; let a = i; for (let m = 0; m < r.length; m++) { const o = this.ctx.createBiquadFilter(); a.connect(o), a = o, o.frequency.setValueAtTime(r[m][0], 0), o.Q.setValueAtTime(r[m][1], 0), o.gain.setValueAtTime(r[m][2], 0), o.type = r[m][3] } a.connect(this.reverbNode), this.eqNodes[t] = i }); for (let t = 0; t < Re; t++) { const i = new ei(this.ctx); this.instances[t] = i } if (Ne = new ei(this.ctx), De = new ti(Ne), this.volumeOld = this.volume, this.mutedOld = this.muted, this.ctx.state == "suspended") { const t = () => { this.ctx.resume(); const i = this.ctx.createBufferSource(); i.buffer = this.ctx.createBuffer(1, 1, 22050), i.connect(this.ctx.destination), i.start(), setTimeout(() => { this.ctx.state == "running" && (document.body.removeEventListener("mousedown", t, !1), document.body.removeEventListener("touchend", t, !1)) }, 0) }; document.body.addEventListener("mousedown", t, !1), document.body.addEventListener("touchend", t, !1) } Xe && (Ni = this.ctx.createBuffer(1, 1, 22050)) } loadFile(e, t) { if (this.files[e] != null) return t(e), this.files[e]; this.files[e] = { buffer: null }; const i = new XMLHttpRequest; i.open("GET", e), i.responseType = "arraybuffer"; const r = function(m) { console.error(`Failed loading sound file: ${e}`) }; return i.addEventListener("load", a => { const m = i.response; if (!m) { r(); return } this.ctx.decodeAudioData(m, o => { this.files[e].buffer = o, t(e) }, () => { console.error(`Failed decoding sound: ${e}`) }) }), i.addEventListener("abort", r), i.addEventListener("error", r), i.addEventListener("timeout", r), i.send(), this.files[e] } registerSound(e, t, i) { const a = { file: this.loadFile(e, this.onfileload.bind(this)), canCoalesce: !!i.canCoalesce, maxInstances: i.channels || 16, volume: i.volume || 1, instances: [] }; this.sounds[t] = a } play(e, t) { const i = this.sounds[e]; if (!i) return console.error(`No sound named: ${e}`), De; const r = t.filter || "none"; let a = t.volume != null ? t.volume : 1; a *= i.volume, a = this.muted ? 0 : a; const m = t.pan || 0, o = !!t.loop, n = t.delay ? t.delay * .001 : 0, p = t.offset ? t.offset : 0, d = t.ambient || !1, f = t.detune || 0; if (!i.file.buffer || this.muted && !t.loop) return De; if (r !== "none" && r !== "reverb" && r !== "muffled" && r !== "club") return console.error(`Invalid filter: ${r}. Only valid filters are 'none', 'reverb', 'muffled' and 'club'.`), De; if (i.canCoalesce) { const I = this.ctx.currentTime + i.file.buffer.duration; for (let k = 0; k < i.instances.length; k++) { const v = i.instances[k]; if (Math.abs(I - v.stopTime) > .03) continue; const b = v.volume * v.volume + a * a, M = v.volume * v.pan + a * m, A = v.volume + a; return v.volume = Math.sqrt(b), v.pan = M / Math.max(.001, A), De } } for (let z = 0; z < Re && (++this.instanceId, !!this.instances[this.instanceId % Re].sound); z++); const w = this.instances[this.instanceId % Re]; if (w.sound) return console.error(`All ${Re} sound instances in use. You are using way too many sounds!`), De; w.id = this.instanceId; const g = w.paramEvents > 150, x = w.paramEvents > 20 && !(this.instanceId % 7); for ((g || x) && w.reallocNodes(); i.instances.length >= i.maxInstances;) { let z = i.instances[0]; for (let I = 1; I < i.instances.length; I++) z.stopTime > i.instances[I].stopTime && (z = i.instances[I]); z.disconnect() } w.sound = i, i.instances.push(w); const S = r === "none" ? this.masterGainNode : r === "reverb" ? this.reverbNode : this.eqNodes[r]; return w.start(S, i.file.buffer, a, m, o, n, p, d, f), this.playingInstances.includes(w) || this.playingInstances.push(w), new ti(w) } registerReverb(e, t, i) { const r = new Xr(this.ctx, this.reverbNode, this.masterGainNode, t, i); this.loadFile(e, a => { r.convolverNode.buffer = this.files[a].buffer, this.onfileload(a) }), this.reverbs[t] = r } setReverbs(e) { for (let t = 0; t < this.activeReverbs.length; t++) { const i = this.activeReverbs[t]; e[i.name] || (i.targetLevel = 0) } for (const t in e) { if (!e[t]) continue; const i = this.reverbs[t]; if (!i) { console.error(`No reverb named ${t}`); continue } this.reverbs[t].active || (this.activeReverbs.push(i), i.active = !0), i.targetLevel = e[t] } } stop(e = !0) { for (let t = 0; t < Re; t++) { const i = this.instances[t]; e && i.ambient || i.sound && i.stop() } } update(e) { this.ctx.state == "suspended" && this.ctx.resume(); const t = this.muted ? 0 : this.volume, i = this.mutedOld ? 0 : this.volumeOld; this.volumeOld = this.volume, this.mutedOld = this.muted, t != i && this.masterGainNode.gain.setTargetAtTime(t, this.ctx.currentTime, .02); for (let r = this.playingInstances.length - 1; r >= 0; r--) { const a = this.playingInstances[r]; a.volumeOld != a.volume && (a.volumeOld = a.volume, a.setGain(a.volume)), a.panOld != a.pan && (a.panOld = a.pan, a.setPan(a.pan)), a.sound && this.ctx.currentTime > a.stopTime && a.disconnect(), a.sound || this.playingInstances.splice(r, 1) } if (this.ctx.currentTime > this.reverbFadeEndTime) { const r = this.ctx.currentTime + .006, a = .025; this.reverbFadeEndTime = r + a; let m = 0; for (let n = 0; n < this.activeReverbs.length; n++) { const p = this.activeReverbs[n]; m += p.targetLevel } const o = m > 1 ? 1 / m : 1; for (let n = 0; n < this.activeReverbs.length; n++) { const p = this.activeReverbs[n], d = Math.sqrt(o * p.targetLevel); p.setGain(d, r, this.reverbFadeEndTime) } for (let n = this.activeReverbs.length - 1; n >= 0; n--) { const p = this.activeReverbs[n], d = this.ctx.currentTime > p.drainEndTime; p.gain == 0 && d && (p.isConnected() && p.disconnect(), p.active = !1, this.activeReverbs.splice(n, 1)) } } } setMute(e) { this.muted = e } on(e, t, i) { if (e != "fileload") { console.error('Only "fileload" event supported'); return } this.onfileload = t.bind(i) } updatePerformanceTest() { var n, p; if (this.runningOfflineTest = this.runningOfflineTest != null ? this.runningOfflineTest : !1, this.runningOfflineTest) return; this.runningOfflineTest = !0; const e = 10; this.offlineCtx = new OfflineAudioContext(2, e * this.ctx.sampleRate, this.ctx.sampleRate); const t = this.offlineCtx.createBuffer(2, e * this.ctx.sampleRate, this.ctx.sampleRate); for (let d = 0; d < t.numberOfChannels; d++) { const f = t.getChannelData(d); for (let w = 0; w < f.length; w++) f[w] = Math.sin(w / 2333) * Math.sin(w / 5741) * 2 * Math.random() - 1 } const i = this.offlineCtx.createBufferSource(); i.buffer = t; const r = this.offlineCtx.createConvolver(), m = this.offlineCtx.createBuffer(1, 4 * this.ctx.sampleRate, this.ctx.sampleRate); for (let d = 0; d < m.numberOfChannels; d++) { const f = m.getChannelData(d); for (let w = 0; w < f.length; w++) f[w] = 2 * Math.random() - 1 } r.buffer = m; const o = { volume: .7, echoVolume: .5, echoLowPass: 800, echoDelay: .25, stereoSpread: .004 }; o.convolverNode = r, o.echoLowPassNode = this.offlineCtx.createBiquadFilter(), o.echoLowPassNode.type = "lowpass", o.echoLowPassNode.frequency.setValueAtTime(o.echoLowPass, 0), o.echoLowPassNode.Q.setValueAtTime(-3.0102999566398125, 0), o.echoDelayNode = this.offlineCtx.createDelay(o.echoDelay), o.echoDelayNode.delayTime.setValueAtTime(o.echoDelay, 0), o.stereoDelayNode = this.offlineCtx.createDelay(o.stereoSpread), o.stereoDelayNode.delayTime.setValueAtTime(o.stereoSpread, 0), o.mergerNode = this.offlineCtx.createChannelMerger(2), o.gainNode = this.offlineCtx.createGain(), o.gainNode.channelCount = 1, o.gainNode.channelCountMode = "explicit", o.gainNode.gain.setValueAtTime(1, 0), o.echoGainNode = this.offlineCtx.createGain(), o.echoGainNode.channelCount = 1, o.echoGainNode.channelCountMode = "explicit", o.echoGainNode.gain.setValueAtTime(o.echoVolume, 0), o.outNode = this.offlineCtx.createGain(), o.gainNode.connect(o.convolverNode); { const { buffer: d } = o.convolverNode; d && d.numberOfChannels != 1 && console.error("stereoSpread can only be applied to mono IRs"), o.convolverNode.connect(o.stereoDelayNode), o.convolverNode.connect(o.mergerNode, 0, 0), (n = o.stereoDelayNode) == null || n.connect(o.mergerNode, 0, 1), (p = o.mergerNode) == null || p.connect(o.outNode) } console.log("starting convolver"), i.connect(o.gainNode), o.outNode.connect(this.offlineCtx.destination), i.start(), this.startTime = performance.now(), this.offlineCtx.oncomplete = d => { const f = performance.now(); console.log("Offline render time: ", f - this.startTime), this.runningOfflineTest = !1 }, this.offlineCtx.startRendering() } } const be = { Sound: new Zr }, Kr = { players: { m9_01: { path: "audio/guns/m9_01.mp3", volume: 1, maxInstances: 5 }, m9_reload_01: { path: "audio/guns/m9_reload_01.mp3", volume: 1 }, m9_reload_02: { path: "audio/guns/m9_reload_02.mp3", volume: 1 }, m9_switch_01: { path: "audio/guns/m9_switch_01.mp3", volume: 1 }, m93r_01: { path: "audio/guns/m93r_01.mp3", volume: 1, maxInstances: 5 }, m93r_reload_01: { path: "audio/guns/m93r_reload_01.mp3", volume: 1 }, m93r_reload_02: { path: "audio/guns/m93r_reload_02.mp3", volume: 1 }, m93r_switch_01: { path: "audio/guns/m93r_switch_01.mp3", volume: 1 }, glock_01: { path: "audio/guns/glock_01.mp3", volume: 1, maxInstances: 5 }, glock_reload_01: { path: "audio/guns/glock_reload_01.mp3", volume: 1 }, glock_reload_02: { path: "audio/guns/glock_reload_02.mp3", volume: 1 }, glock_switch_01: { path: "audio/guns/glock_switch_01.mp3", volume: 1 }, p30l_01: { path: "audio/guns/p30l_01.mp3", volume: 1.2, maxInstances: 5 }, p30l_reload_01: { path: "audio/guns/p30l_reload_01.mp3", volume: 1.4 }, p30l_reload_02: { path: "audio/guns/p30l_reload_02.mp3", volume: 1.4 }, p30l_switch_01: { path: "audio/guns/p30l_switch_01.mp3", volume: 1.5 }, m1911_01: { path: "audio/guns/m1911_01.mp3", volume: 1, maxInstances: 5 }, m1911_reload_01: { path: "audio/guns/m1911_reload_01.mp3", volume: 1 }, m1911_reload_02: { path: "audio/guns/m1911_reload_02.mp3", volume: 1 }, m1911_switch_01: { path: "audio/guns/m1911_switch_01.mp3", volume: 1 }, ot38_01: { path: "audio/guns/ot38_01.mp3", volume: 1, maxInstances: 5 }, ot38_reload_01: { path: "audio/guns/ot38_reload_01.mp3", volume: 1 }, ot38_reload_02: { path: "audio/guns/ot38_reload_02.mp3", volume: 1 }, ot38_switch_01: { path: "audio/guns/ot38_switch_01.mp3", volume: 1 }, ots38_01: { path: "audio/guns/ots38_01.mp3", volume: 1, maxInstances: 5 }, colt45_01: { path: "audio/guns/colt45_01.mp3", volume: 1 }, colt45_reload_01: { path: "audio/guns/colt45_reload_01.mp3", volume: 1 }, colt45_reload_02: { path: "audio/guns/colt45_reload_02.mp3", volume: 1 }, colt45_switch_01: { path: "audio/guns/colt45_switch_01.mp3", volume: 1 }, deagle_01: { path: "audio/guns/deagle_01.mp3", volume: 1, maxInstances: 5 }, deagle_reload_01: { path: "audio/guns/deagle_reload_01.mp3", volume: 1 }, deagle_reload_02: { path: "audio/guns/deagle_reload_02.mp3", volume: 1 }, deagle_switch_01: { path: "audio/guns/deagle_switch_01.mp3", volume: 1 }, flare_gun_01: { path: "audio/guns/flare_gun_01.mp3", volume: 1, maxInstances: 5 }, flare_gun_reload_01: { path: "audio/guns/flare_gun_reload_01.mp3", volume: 1 }, flare_gun_reload_02: { path: "audio/guns/flare_gun_reload_02.mp3", volume: 1 }, ak47_01: { path: "audio/guns/ak47_01.mp3", volume: 1, maxInstances: 5 }, ak47_reload_01: { path: "audio/guns/ak47_reload_01.mp3", volume: 1 }, ak47_switch_01: { path: "audio/guns/ak47_switch_01.mp3", volume: 1 }, an94_01: { path: "audio/guns/an94_01.mp3", volume: 1, maxInstances: 5 }, an94_reload_01: { path: "audio/guns/an94_reload_01.mp3", volume: 1 }, an94_switch_01: { path: "audio/guns/an94_switch_01.mp3", volume: 1 }, groza_01: { path: "audio/guns/groza_01.mp3", volume: .95, maxInstances: 5 }, groza_reload_01: { path: "audio/guns/groza_reload_01.mp3", volume: 1.1 }, groza_switch_01: { path: "audio/guns/groza_switch_01.mp3", volume: 1.1 }, grozas_01: { path: "audio/guns/grozas_01.mp3", volume: .95, maxInstances: 5 }, scar_01: { path: "audio/guns/scar_01.mp3", volume: 1, maxInstances: 5 }, scar_reload_01: { path: "audio/guns/scar_reload_01.mp3", volume: 1 }, scar_switch_01: { path: "audio/guns/scar_switch_01.mp3", volume: 1 }, scarssr_01: { path: "audio/guns/scarssr_01.mp3", volume: 1, maxInstances: 5 }, dp28_01: { path: "audio/guns/dp28_01.mp3", volume: 1, maxInstances: 5 }, dp28_reload_01: { path: "audio/guns/dp28_reload_01.mp3", volume: 1 }, dp28_switch_01: { path: "audio/guns/dp28_switch_01.mp3", volume: 1 }, bar_01: { path: "audio/guns/bar_01.mp3", volume: 1, maxInstances: 5 }, bar_reload_01: { path: "audio/guns/bar_reload_01.mp3", volume: 1 }, bar_switch_01: { path: "audio/guns/bar_switch_01.mp3", volume: 1 }, pkp_01: { path: "audio/guns/pkp_01.mp3", volume: 1, maxInstances: 5 }, pkp_reload_01: { path: "audio/guns/pkp_reload_01.mp3", volume: 1 }, pkp_switch_01: { path: "audio/guns/pkp_switch_01.mp3", volume: 1 }, m870_01: { path: "audio/guns/m870_01.mp3", volume: 1, maxInstances: 5 }, m870_reload_01: { path: "audio/guns/m870_reload_01.mp3", volume: 1 }, m870_cycle_01: { path: "audio/guns/m870_cycle_01.mp3", volume: 1 }, m870_pull_01: { path: "audio/guns/m870_pull_01.mp3", volume: 1 }, spas12_01: { path: "audio/guns/spas12_01.mp3", volume: 1, maxInstances: 5 }, spas12_reload_01: { path: "audio/guns/spas12_reload_01.mp3", volume: 1 }, spas12_cycle_01: { path: "audio/guns/spas12_cycle_01.mp3", volume: 1 }, spas12_pull_01: { path: "audio/guns/spas12_pull_01.mp3", volume: 1 }, mp220_01: { path: "audio/guns/mp220_01.mp3", volume: 1, maxInstances: 5 }, mp220_reload_01: { path: "audio/guns/mp220_reload_01.mp3", volume: 1 }, mp220_deploy_01: { path: "audio/guns/mp220_deploy_01.mp3", volume: 1 }, saiga_01: { path: "audio/guns/saiga_01.mp3", volume: 1, maxInstances: 5 }, saiga_reload_01: { path: "audio/guns/saiga_reload_01.mp3", volume: 1 }, saiga_switch_01: { path: "audio/guns/saiga_switch_01.mp3", volume: 1 }, usas_01: { path: "audio/guns/usas_01.mp3", volume: 1, maxInstances: 5 }, usas_reload_01: { path: "audio/guns/usas_reload_01.mp3", volume: 1 }, usas_switch_01: { path: "audio/guns/usas_switch_01.mp3", volume: 1 }, m1100_01: { path: "audio/guns/m1100_01.mp3", volume: 1, maxInstances: 5 }, m1100_reload_01: { path: "audio/guns/m1100_reload_01.mp3", volume: 1 }, m1100_deploy_01: { path: "audio/guns/m1100_deploy_01.mp3", volume: 1 }, m1014_01: { path: "audio/guns/m1014_01.mp3", volume: 1, maxInstances: 5 }, m1014_reload_01: { path: "audio/guns/m1014_reload_01.mp3", volume: 1 }, m1014_deploy_01: { path: "audio/guns/m1014_deploy_01.mp3", volume: 1 }, m39_01: { path: "audio/guns/m39_01.mp3", volume: 1, maxInstances: 5 }, m39_reload_01: { path: "audio/guns/m39_reload_01.mp3", volume: 1 }, m39_switch_01: { path: "audio/guns/m39_switch_01.mp3", volume: 1 }, svd_01: { path: "audio/guns/svd_01.mp3", volume: 1, maxInstances: 5 }, svd_reload_01: { path: "audio/guns/svd_reload_01.mp3", volume: 1 }, svd_switch_01: { path: "audio/guns/svd_switch_01.mp3", volume: 1 }, garand_01: { path: "audio/guns/garand_01.mp3", volume: 1, maxInstances: 5 }, garand_02: { path: "audio/guns/garand_02.mp3", volume: 1, maxInstances: 5 }, garand_reload_01: { path: "audio/guns/garand_reload_01.mp3", volume: 1 }, garand_switch_01: { path: "audio/guns/garand_switch_01.mp3", volume: 1 }, m1a1_01: { path: "audio/guns/m1a1_01.mp3", volume: 1, maxInstances: 5 }, m1a1_reload_01: { path: "audio/guns/m1a1_reload_01.mp3", volume: 1 }, m1a1_switch_01: { path: "audio/guns/m1a1_switch_01.mp3", volume: 1 }, mp5_01: { path: "audio/guns/mp5_01.mp3", volume: 1, maxInstances: 5 }, mp5_reload_01: { path: "audio/guns/mp5_reload_01.mp3", volume: 1 }, mp5_switch_01: { path: "audio/guns/mp5_switch_01.mp3", volume: 1 }, mac10_01: { path: "audio/guns/mac10_01.mp3", volume: 1, maxInstances: 5 }, mac10_reload_01: { path: "audio/guns/mac10_reload_01.mp3", volume: 1 }, mac10_switch_01: { path: "audio/guns/mac10_switch_01.mp3", volume: 1 }, ump9_01: { path: "audio/guns/ump9_01.mp3", volume: 1, maxInstances: 5 }, ump9_reload_01: { path: "audio/guns/ump9_reload_01.mp3", volume: 1 }, ump9_switch_01: { path: "audio/guns/ump9_switch_01.mp3", volume: 1 }, vector_01: { path: "audio/guns/vector_01.mp3", volume: 1, maxInstances: 5 }, vector_02: { path: "audio/guns/vector_02.mp3", volume: 1, maxInstances: 5 }, vector_reload_01: { path: "audio/guns/vector_reload_01.mp3", volume: 1 }, vector_switch_01: { path: "audio/guns/vector_switch_01.mp3", volume: 1 }, scorpion_01: { path: "audio/guns/scorpion_01.mp3", volume: 1, maxInstances: 5 }, scorpion_reload_01: { path: "audio/guns/scorpion_reload_01.mp3", volume: 1 }, scorpion_switch_01: { path: "audio/guns/scorpion_switch_01.mp3", volume: 1 }, vss_01: { path: "audio/guns/vss_01.mp3", volume: 1, maxInstances: 5 }, vss_reload_01: { path: "audio/guns/vss_reload_01.mp3", volume: 1 }, vss_switch_01: { path: "audio/guns/vss_switch_01.mp3", volume: 1 }, famas_01: { path: "audio/guns/famas_01.mp3", volume: 1, maxInstances: 5 }, famas_reload_01: { path: "audio/guns/famas_reload_01.mp3", volume: 1 }, famas_switch_01: { path: "audio/guns/famas_switch_01.mp3", volume: 1 }, hk416_01: { path: "audio/guns/hk416_01.mp3", volume: 1, maxInstances: 5 }, hk416_reload_01: { path: "audio/guns/hk416_reload_01.mp3", volume: 1 }, hk416_switch_01: { path: "audio/guns/hk416_switch_01.mp3", volume: 1 }, m4a1_01: { path: "audio/guns/m4a1_01.mp3", volume: 1, maxInstances: 5 }, m4a1_reload_01: { path: "audio/guns/m4a1_reload_01.mp3", volume: 1 }, m4a1_switch_01: { path: "audio/guns/m4a1_switch_01.mp3", volume: 1 }, mk12_01: { path: "audio/guns/mk12_01.mp3", volume: 1, maxInstances: 5 }, mk12_reload_01: { path: "audio/guns/mk12_reload_01.mp3", volume: 1 }, mk12_switch_01: { path: "audio/guns/mk12_switch_01.mp3", volume: 1 }, l86_01: { path: "audio/guns/l86_01.mp3", volume: 1, maxInstances: 5 }, l86_reload_01: { path: "audio/guns/l86_reload_01.mp3", volume: 1 }, l86_switch_01: { path: "audio/guns/l86_switch_01.mp3", volume: 1 }, m249_01: { path: "audio/guns/m249_01.mp3", volume: 1, maxInstances: 5 }, m249_reload_01: { path: "audio/guns/m249_reload_01.mp3", volume: 1.5 }, m249_switch_01: { path: "audio/guns/m249_switch_01.mp3", volume: 1.5 }, qbb97_01: { path: "audio/guns/qbb97_01.mp3", volume: 1, maxInstances: 5 }, qbb97_reload_01: { path: "audio/guns/qbb97_reload_01.mp3", volume: 1 }, qbb97_switch_01: { path: "audio/guns/qbb97_switch_01.mp3", volume: 1 }, scout_01: { path: "audio/guns/scout_01.mp3", volume: 2, maxInstances: 5 }, scout_reload_01: { path: "audio/guns/scout_reload_01.mp3", volume: 1.2 }, scout_cycle_01: { path: "audio/guns/scout_cycle_01.mp3", volume: 1.2 }, scout_pull_01: { path: "audio/guns/scout_pull_01.mp3", volume: 1.2 }, model94_01: { path: "audio/guns/model94_01.mp3", volume: 1, maxInstances: 5 }, model94_reload_01: { path: "audio/guns/model94_reload_01.mp3", volume: 1 }, model94_cycle_01: { path: "audio/guns/model94_cycle_01.mp3", volume: 1 }, mkg45_01: { path: "audio/guns/mkg45_01.mp3", volume: 1, maxInstances: 5 }, mkg45_reload_01: { path: "audio/guns/mkg45_reload_01.mp3", volume: 1.25 }, mkg45_switch_01: { path: "audio/guns/mkg45_switch_01.mp3", volume: 1.25 }, blr_01: { path: "audio/guns/blr_01.mp3", volume: 1.5, maxInstances: 5 }, blr_reload_01: { path: "audio/guns/blr_reload_01.mp3", volume: 1 }, blr_cycle_01: { path: "audio/guns/blr_cycle_01.mp3", volume: 1 }, mosin_01: { path: "audio/guns/mosin_01.mp3", volume: 1, maxInstances: 5 }, mosin_reload_01: { path: "audio/guns/mosin_reload_01.mp3", volume: 1 }, mosin_reload_02: { path: "audio/guns/mosin_reload_02.mp3", volume: 1 }, mosin_cycle_01: { path: "audio/guns/mosin_cycle_01.mp3", volume: 1 }, mosin_pull_01: { path: "audio/guns/mosin_pull_01.mp3", volume: 1 }, sv98_01: { path: "audio/guns/sv98_01.mp3", volume: 1, maxInstances: 5 }, sv98_reload_01: { path: "audio/guns/sv98_reload_01.mp3", volume: 1 }, sv98_cycle_01: { path: "audio/guns/sv98_cycle_01.mp3", volume: 1 }, sv98_pull_01: { path: "audio/guns/sv98_pull_01.mp3", volume: 1 }, awc_01: { path: "audio/guns/awc_01.mp3", volume: 1, maxInstances: 5 }, awc_reload_01: { path: "audio/guns/awc_reload_01.mp3", volume: 1 }, awc_cycle_01: { path: "audio/guns/awc_cycle_01.mp3", volume: 1 }, awc_pull_01: { path: "audio/guns/awc_pull_01.mp3", volume: 1 }, potato_cannon_01: { path: "audio/guns/potato_cannon_01.mp3", volume: 1, maxInstances: 5 }, potato_cannon_reload_01: { path: "audio/guns/potato_cannon_reload_01.mp3", volume: 1 }, potato_cannon_switch_01: { path: "audio/guns/potato_cannon_switch_01.mp3", volume: 1 }, potato_smg_01: { path: "audio/guns/potato_smg_01.mp3", volume: 1, maxInstances: 5 }, potato_smg_reload_01: { path: "audio/guns/potato_smg_reload_01.mp3", volume: 1 }, potato_smg_switch_01: { path: "audio/guns/potato_smg_switch_01.mp3", volume: 1 }, bugle_01: { path: "audio/guns/bugle_01.mp3", volume: 1.5, maxInstances: 3, preload: !1 }, bugle_02: { path: "audio/guns/bugle_02.mp3", volume: 1.5, maxInstances: 3, preload: !1 }, bugle_03: { path: "audio/guns/bugle_03.mp3", volume: 1.5, maxInstances: 3, preload: !1 }, empty_fire_01: { path: "audio/guns/empty_fire_01.mp3", volume: .9 }, empty_fire_02: { path: "audio/guns/empty_fire_02.mp3", volume: .9 }, gun_switch_01: { path: "audio/guns/gun_switch_01.mp3", volume: 1 }, bandage_use_01: { path: "audio/ui/bandage_use_01.mp3", volume: 1 }, healthkit_use_01: { path: "audio/ui/healthkit_use_01.mp3", volume: 1 }, soda_use_01: { path: "audio/ui/soda_use_01.mp3", volume: 1 }, pills_use_01: { path: "audio/ui/pills_use_01.mp3", volume: 1 }, stow_weapon_01: { path: "audio/ui/stow_weapon_01.mp3", volume: 1 } }, hits: { stone_bullet_hit_01: { path: "audio/hits/stone_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, wood_bullet_hit_01: { path: "audio/hits/wood_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, wood_bullet_hit_02: { path: "audio/hits/wood_bullet_hit_02.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, wood_bullet_hit_03: { path: "audio/hits/wood_bullet_hit_03.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, wood_bullet_hit_04: { path: "audio/hits/wood_bullet_hit_04.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, bush_bullet_hit_01: { path: "audio/hits/bush_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, metal_bullet_hit_01: { path: "audio/hits/metal_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, metal_bullet_hit_02: { path: "audio/hits/metal_bullet_hit_02.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, metal_bullet_hit_03: { path: "audio/hits/metal_bullet_hit_03.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, metal_bullet_hit_04: { path: "audio/hits/metal_bullet_hit_04.mp3", volume: 1, canCoalesce: !0, maxInstances: 6 }, pan_bullet_hit_01: { path: "audio/hits/pan_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 6 }, brick_bullet_hit_01: { path: "audio/hits/brick_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, punch_hit_01: { path: "audio/hits/punch_hit_01.mp3", volume: 1 }, knife_hit_01: { path: "audio/hits/knife_hit_01.mp3", volume: 1 }, pan_hit_01: { path: "audio/hits/pan_hit_01.mp3", volume: 1 }, axe_hit_01: { path: "audio/hits/axe_hit_01.mp3", volume: 1 }, hook_hit_01: { path: "audio/hits/hook_hit_01.mp3", volume: 1 }, saw_hit_01: { path: "audio/hits/saw_hit_01.mp3", volume: 2.5 }, crowbar_hit_01: { path: "audio/hits/crowbar_hit_01.mp3", volume: 1 }, spade_hit_01: { path: "audio/hits/spade_hit_01.mp3", volume: 1 }, hammer_hit_01: { path: "audio/hits/hammer_hit_01.mp3", volume: 1 }, metal_punch_hit_01: { path: "audio/hits/metal_punch_hit_01.mp3", volume: 1 }, metal_punch_hit_02: { path: "audio/hits/metal_punch_hit_02.mp3", volume: 1 }, player_bullet_hit_01: { path: "audio/hits/player_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, player_bullet_hit_02: { path: "audio/hits/player_bullet_hit_02.mp3", volume: 1, canCoalesce: !0 }, plastic_bullet_hit_01: { path: "audio/hits/plastic_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, toilet_bullet_hit_01: { path: "audio/hits/toilet_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, toilet_bullet_hit_02: { path: "audio/hits/toilet_bullet_hit_02.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, glass_bullet_hit_01: { path: "audio/hits/glass_bullet_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, concrete_hit_01: { path: "audio/hits/concrete_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, frag_grass_01: { path: "audio/hits/frag_grass_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, frag_sand_01: { path: "audio/hits/frag_sand_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, frag_water_01: { path: "audio/hits/frag_water_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, cloth_hit_01: { path: "audio/hits/cloth_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, cloth_hit_02: { path: "audio/hits/cloth_hit_02.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, organic_hit_01: { path: "audio/hits/organic_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, piano_hit_01: { path: "audio/hits/piano_hit_01.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 }, piano_hit_02: { path: "audio/hits/piano_hit_02.mp3", volume: 1, canCoalesce: !0, maxInstances: 3 } }, sfx: { crate_break_01: { path: "audio/sfx/crate_break_01.mp3", volume: 1 }, crate_break_02: { path: "audio/sfx/crate_break_02.mp3", volume: 1 }, tree_break_01: { path: "audio/sfx/tree_break_01.mp3", volume: 1 }, bush_break_01: { path: "audio/sfx/bush_break_01.mp3", volume: 1 }, bush_enter_01: { path: "audio/sfx/bush_enter_01.mp3", volume: 1, canCoalesce: !0 }, bush_enter_02: { path: "audio/sfx/bush_enter_02.mp3", volume: 1, canCoalesce: !0 }, barrel_break_01: { path: "audio/sfx/barrel_break_01.mp3", volume: 1 }, barrel_break_02: { path: "audio/sfx/barrel_break_02.mp3", volume: 1 }, stone_break_01: { path: "audio/sfx/stone_break_01.mp3", volume: 1 }, wall_break_01: { path: "audio/sfx/wall_break_01.mp3", volume: 1 }, ceiling_break_01: { path: "audio/sfx/ceiling_break_01.mp3", volume: 1 }, ceiling_break_02: { path: "audio/sfx/ceiling_break_02.mp3", volume: 1 }, toilet_break_01: { path: "audio/sfx/toilet_break_01.mp3", volume: 1 }, toilet_break_02: { path: "audio/sfx/toilet_break_02.mp3", volume: 1 }, vending_break_01: { path: "audio/sfx/vending_break_01.mp3", volume: 1 }, window_break_01: { path: "audio/sfx/window_break_01.mp3", volume: 1 }, window_break_02: { path: "audio/sfx/window_break_02.mp3", volume: 1 }, drawers_break_01: { path: "audio/sfx/drawers_break_01.mp3", volume: 1 }, oven_break_01: { path: "audio/sfx/oven_break_01.mp3", volume: 1 }, deposit_box_break_01: { path: "audio/sfx/deposit_box_break_01.mp3", volume: 1 }, cloth_break_01: { path: "audio/sfx/cloth_break_01.mp3", volume: 1 }, screen_break_01: { path: "audio/sfx/screen_break_01.mp3", volume: 1 }, pumpkin_break_01: { path: "audio/sfx/pumpkin_break_01.mp3", volume: 1, preload: !1 }, ceramic_break_01: { path: "audio/sfx/ceramic_break_01.mp3", volume: 1 }, footstep_grass_01: { path: "audio/sfx/footstep_grass_01.mp3", volume: 1 }, footstep_grass_02: { path: "audio/sfx/footstep_grass_02.mp3", volume: 1 }, footstep_metal_01: { path: "audio/sfx/footstep_metal_01.mp3", volume: 1 }, footstep_metal_02: { path: "audio/sfx/footstep_metal_02.mp3", volume: 1 }, footstep_metal_03: { path: "audio/sfx/footstep_metal_03.mp3", volume: 1 }, footstep_metal_04: { path: "audio/sfx/footstep_metal_04.mp3", volume: 1 }, footstep_metal_05: { path: "audio/sfx/footstep_metal_05.mp3", volume: 1 }, footstep_wood_01: { path: "audio/sfx/footstep_wood_01.mp3", volume: 1 }, footstep_wood_02: { path: "audio/sfx/footstep_wood_02.mp3", volume: 1 }, footstep_wood_03: { path: "audio/sfx/footstep_wood_03.mp3", volume: 1 }, footstep_sand_01: { path: "audio/sfx/footstep_sand_01.mp3", volume: 1 }, footstep_sand_02: { path: "audio/sfx/footstep_sand_02.mp3", volume: 1 }, footstep_water_01: { path: "audio/sfx/footstep_water_01.mp3", volume: 1 }, footstep_water_02: { path: "audio/sfx/footstep_water_02.mp3", volume: 1 }, footstep_tile_01: { path: "audio/sfx/footstep_tile_01.mp3", volume: 1 }, footstep_tile_02: { path: "audio/sfx/footstep_tile_02.mp3", volume: 1 }, footstep_asphalt_01: { path: "audio/sfx/footstep_asphalt_01.mp3", volume: 1 }, footstep_asphalt_02: { path: "audio/sfx/footstep_asphalt_02.mp3", volume: 1 }, footstep_brick_01: { path: "audio/sfx/footstep_brick_01.mp3", volume: 1 }, footstep_stone_01: { path: "audio/sfx/footstep_stone_01.mp3", volume: .8 }, footstep_carpet_01: { path: "audio/sfx/footstep_carpet_01.mp3", volume: 1 }, punch_swing_01: { path: "audio/sfx/punch_swing_01.mp3", volume: 1 }, knife_swing_01: { path: "audio/sfx/knife_swing_01.mp3", volume: 1 }, medium_swing_01: { path: "audio/sfx/medium_swing_01.mp3", volume: 1 }, heavy_swing_01: { path: "audio/sfx/heavy_swing_01.mp3", volume: 1 }, bullet_whiz_01: { path: "audio/sfx/bullet_whiz_01.mp3", volume: 1 }, bullet_whiz_02: { path: "audio/sfx/bullet_whiz_02.mp3", volume: 1 }, bullet_whiz_03: { path: "audio/sfx/bullet_whiz_03.mp3", volume: 1 }, frag_throw_01: { path: "audio/sfx/frag_throw_01.mp3", volume: 1 }, frag_pin_01: { path: "audio/sfx/frag_pin_01.mp3", volume: 1 }, frag_deploy_01: { path: "audio/ui/frag_pickup_01.mp3", volume: 1 }, frag_water_01: { path: "audio/hits/frag_water_01.mp3", volume: 1 }, strobe_click_01: { path: "audio/sfx/strobe_click_01.mp3", volume: 1 }, explosion_01: { path: "audio/sfx/explosion_01.mp3", volume: 1 }, explosion_02: { path: "audio/sfx/explosion_02.mp3", volume: 1 }, explosion_03: { path: "audio/sfx/explosion_03.mp3", volume: 1 }, explosion_04: { path: "audio/sfx/explosion_04.mp3", volume: 1, maxInstances: 4 }, explosion_05: { path: "audio/sfx/explosion_05.mp3", volume: 1 }, explosion_smoke_01: { path: "audio/sfx/explosion_smoke_01.mp3", volume: 1 }, snowball_01: { path: "audio/sfx/snowball_01.mp3", volume: 1, preload: !1 }, snowball_02: { path: "audio/sfx/snowball_02.mp3", volume: 1, preload: !1 }, potato_01: { path: "audio/sfx/potato_01.mp3", volume: 1, preload: !1 }, potato_02: { path: "audio/sfx/potato_02.mp3", volume: 1, preload: !1 }, stow_weapon_01: { path: "audio/ui/stow_weapon_01.mp3", volume: 1 }, knife_deploy_01: { path: "audio/ui/knife_deploy_01.mp3", volume: 1 }, pan_pickup_01: { path: "audio/ui/pan_pickup_01.mp3", volume: 1 }, knuckles_deploy_01: { path: "audio/ui/knuckles_deploy_01.mp3", volume: 1 }, door_open_01: { path: "audio/sfx/door_open_01.mp3", volume: 1 }, door_close_01: { path: "audio/sfx/door_close_01.mp3", volume: 1 }, door_open_02: { path: "audio/sfx/door_open_02.mp3", volume: 1 }, door_close_02: { path: "audio/sfx/door_close_02.mp3", volume: 1 }, door_open_03: { path: "audio/sfx/door_open_03.mp3", volume: 1 }, door_close_03: { path: "audio/sfx/door_close_03.mp3", volume: 1 }, door_open_04: { path: "audio/sfx/door_open_04.mp3", volume: .8 }, door_error_01: { path: "audio/sfx/door_error_01.mp3", volume: 1 }, vault_change_01: { path: "audio/sfx/vault_change_01.mp3", volume: 1 }, vault_change_02: { path: "audio/sfx/vault_change_02.mp3", volume: 1, preload: !1 }, vault_change_03: { path: "audio/sfx/vault_change_03.mp3", volume: 1, preload: !1 }, cell_control_01: { path: "audio/sfx/cell_control_01.mp3", volume: 1 }, cell_control_02: { path: "audio/sfx/cell_control_02.mp3", volume: 1 }, plane_01: { path: "audio/sfx/plane_01.mp3", volume: 1 }, plane_02: { path: "audio/sfx/plane_02.mp3", volume: 1, preload: !1 }, fighter_01: { path: "audio/sfx/fighter_01.mp3", volume: 1 }, airdrop_chute_01: { path: "audio/sfx/airdrop_chute_01.mp3", volume: 1 }, airdrop_fall_01: { path: "audio/sfx/airdrop_fall_01.mp3", volume: 1 }, airdrop_crash_01: { path: "audio/sfx/airdrop_crash_01.mp3", volume: 1 }, airdrop_crash_02: { path: "audio/sfx/airdrop_crash_02.mp3", volume: 1 }, airdrop_open_01: { path: "audio/sfx/airdrop_open_01.mp3", volume: 1 }, airdrop_open_02: { path: "audio/sfx/airdrop_open_02.mp3", volume: 1 }, button_press_01: { path: "audio/sfx/button_press_01.mp3", volume: 1, maxInstances: 3 }, watering_01: { path: "audio/sfx/watering_01.mp3", volume: 1, maxInstances: 3, preload: !1 }, piano_02: { path: "audio/sfx/piano_02.mp3", volume: 1, preload: !1 }, footstep_08: { path: "audio/sfx/footstep_08.mp3", volume: 1, preload: !1 }, footstep_09: { path: "audio/sfx/footstep_09.mp3", volume: 1, preload: !1 }, howl_01: { path: "audio/sfx/howl_01.mp3", volume: 1, preload: !1 }, wheel_control_01: { path: "audio/sfx/wheel_control_01.mp3", volume: 1, preload: !1 }, log_01: { path: "audio/sfx/log_01.mp3", volume: 1, preload: !1 }, log_02: { path: "audio/sfx/log_02.mp3", volume: 1, preload: !1 }, log_03: { path: "audio/sfx/log_03.mp3", volume: 1, preload: !1 }, log_04: { path: "audio/sfx/log_04.mp3", volume: 1, preload: !1 }, log_05: { path: "audio/sfx/log_05.mp3", volume: 1, preload: !1 }, log_06: { path: "audio/sfx/log_06.mp3", volume: 1, preload: !1 }, log_11: { path: "audio/sfx/log_11.mp3", volume: 4, preload: !1 }, log_12: { path: "audio/sfx/log_12.mp3", volume: 4, preload: !1 }, log_13: { path: "audio/sfx/log_13.mp3", volume: 2, preload: !1 }, log_14: { path: "audio/sfx/log_14.mp3", volume: 2, preload: !1 }, ability_stim_01: { path: "audio/sfx/ability_stim_01.mp3", volume: 4 }, xp_drop_01: { path: "audio/sfx/xp_drop_01.mp3", volume: 1.25, preload: !1 }, xp_drop_02: { path: "audio/sfx/xp_drop_02.mp3", volume: 1.25, preload: !1 }, cluck_01: { path: "audio/sfx/cluck_01.mp3", volume: 1, preload: !1 }, cluck_02: { path: "audio/sfx/cluck_02.mp3", volume: 1, preload: !1 }, feather_01: { path: "audio/sfx/feather_01.mp3", volume: 1, preload: !1 } }, ambient: { ambient_wind_01: { path: "audio/ambient/ambient_wind_01.mp3", volume: 1, loadPriority: 1 }, ambient_waves_01: { path: "audio/ambient/ambient_waves_01.mp3", volume: 1, loadPriority: 1 }, ambient_stream_01: { path: "audio/ambient/ambient_stream_01.mp3", volume: 1, loadPriority: 1 }, piano_music_01: { path: "audio/ambient/piano_music_01.mp3", volume: 1, preload: !1 }, ambient_wind_02: { path: "audio/ambient/ambient_wind_02.mp3", volume: 1, preload: !1 }, ambient_steam_01: { path: "audio/ambient/ambient_steam_01.mp3", volume: 1, preload: !1 }, club_music_01: { path: "audio/ambient/club_music_01.mp3", volume: 1, preload: !1 }, club_music_02: { path: "audio/ambient/club_music_02.mp3", volume: 1, preload: !1 }, ambient_lab_01: { path: "audio/ambient/ambient_lab_01.mp3", volume: .2, preload: !1 } }, ui: { ammo_pickup_01: { path: "audio/ui/ammo_pickup_01.mp3", volume: 1 }, clothes_pickup_01: { path: "audio/ui/clothes_pickup_01.mp3", volume: 1 }, bells_01: { path: "audio/sfx/plane_02.mp3", volume: 1, preload: !1 }, helmet_pickup_01: { path: "audio/ui/helmet_pickup_01.mp3", volume: 1 }, chest_pickup_01: { path: "audio/ui/chest_pickup_01.mp3", volume: 1 }, gun_pickup_01: { path: "audio/ui/gun_pickup_01.mp3", volume: 1 }, scope_pickup_01: { path: "audio/ui/scope_pickup_01.mp3", volume: 1 }, pack_pickup_01: { path: "audio/ui/pack_pickup_01.mp3", volume: 1 }, soda_pickup_01: { path: "audio/ui/soda_pickup_01.mp3", volume: 1 }, pills_pickup_01: { path: "audio/ui/pills_pickup_01.mp3", volume: 1 }, bandage_pickup_01: { path: "audio/ui/bandage_pickup_01.mp3", volume: 1 }, healthkit_pickup_01: { path: "audio/ui/healthkit_pickup_01.mp3", volume: 1 }, frag_pickup_01: { path: "audio/ui/frag_pickup_01.mp3", volume: 1 }, snowball_pickup_01: { path: "audio/ui/snowball_pickup_01.mp3", volume: 1, preload: !1 }, potato_pickup_01: { path: "audio/ui/potato_pickup_01.mp3", volume: 1, preload: !1 }, heavy_pickup_01: { path: "audio/ui/heavy_pickup_01.mp3", volume: 1 }, pan_pickup_01: { path: "audio/ui/pan_pickup_01.mp3", volume: 1 }, perk_pickup_01: { path: "audio/ui/perk_pickup_01.mp3", volume: 1 }, xp_pickup_01: { path: "audio/ui/xp_pickup_01.mp3", volume: 1.5, preload: !1 }, xp_pickup_02: { path: "audio/ui/xp_pickup_02.mp3", volume: 1.5, preload: !1 }, ping_danger_01: { path: "audio/ui/ping_danger_01.mp3", volume: 1 }, ping_coming_01: { path: "audio/ui/ping_coming_01.mp3", volume: 1 }, ping_help_01: { path: "audio/ui/ping_help_01.mp3", volume: 1 }, ping_leader_01: { path: "audio/ui/ping_leader_01.mp3", volume: 1, preload: !1 }, ping_airdrop_01: { path: "audio/ui/ping_airdrop_01.mp3", volume: 1 }, ping_airstrike_01: { path: "audio/ui/ping_airstrike_01.mp3", volume: 1 }, ping_unlock_01: { path: "audio/ui/ping_unlock_01.mp3", volume: 1, preload: !1 }, emote_01: { path: "audio/ui/emote_01.mp3", volume: 1 }, trick_01: { path: "audio/ui/trick_01.mp3", volume: 1.5, preload: !1 }, trick_02: { path: "audio/ui/trick_02.mp3", volume: 1.5, preload: !1 }, trick_03: { path: "audio/ui/trick_03.mp3", volume: 1.5, preload: !1 }, treat_01: { path: "audio/ui/treat_01.mp3", volume: 1, preload: !1 }, loot_drop_01: { path: "audio/ui/loot_drop_01.mp3", volume: 1 }, notification_start_01: { path: "audio/ui/notification_start_01.mp3", volume: 1 }, notification_join_01: { path: "audio/ui/notification_join_01.mp3", volume: 1 }, leader_assigned_01: { path: "audio/ui/leader_assigned_01.mp3", volume: 1, maxInstances: 1 }, leader_dead_01: { path: "audio/ui/leader_dead_01.mp3", volume: 1.75, maxInstances: 1 }, lt_assigned_01: { path: "audio/ui/lt_assigned_01.mp3", volume: 1, preload: !1, maxInstances: 1 }, medic_assigned_01: { path: "audio/ui/medic_assigned_01.mp3", volume: 2, preload: !1, maxInstances: 1 }, marksman_assigned_01: { path: "audio/ui/marksman_assigned_01.mp3", volume: 2, preload: !1, maxInstances: 1 }, recon_assigned_01: { path: "audio/ui/recon_assigned_01.mp3", volume: 1.5, preload: !1, maxInstances: 1 }, grenadier_assigned_01: { path: "audio/ui/grenadier_assigned_01.mp3", volume: 2.5, preload: !1, maxInstances: 1 }, bugler_assigned_01: { path: "audio/ui/bugler_assigned_01.mp3", volume: 2.5, preload: !1, maxInstances: 1 }, last_man_assigned_01: { path: "audio/ui/last_man_assigned_01.mp3", volume: 1.75, preload: !1, maxInstances: 1 }, helmet03_forest_pickup_01: { path: "audio/ui/helmet03_forest_pickup_01.mp3", volume: 1, maxInstances: 1, preload: !1 }, kill_leader_assigned_01: { path: "audio/ui/kill_leader_assigned_01.mp3", volume: 1.5, maxInstances: 1, preload: !1 }, kill_leader_assigned_02: { path: "audio/ui/kill_leader_assigned_02.mp3", volume: 1.5, maxInstances: 1, preload: !1 }, kill_leader_dead_01: { path: "audio/ui/kill_leader_dead_01.mp3", volume: 1.5, maxInstances: 1, preload: !1 }, kill_leader_dead_02: { path: "audio/ui/kill_leader_dead_02.mp3", volume: 1.5, maxInstances: 1, preload: !1 }, spawn_01: { path: "audio/ui/spawn_01.mp3", volume: 3, preload: !1 } }, music: { menu_music: { path: "audio/ambient/menu_music_01.mp3", volume: 1, loadPriority: 2 } } }, Yr = { footstep_grass: { channel: "sfx", sounds: ["footstep_grass_01", "footstep_grass_02"] }, footstep_container: { channel: "sfx", sounds: ["footstep_metal_03"] }, footstep_warehouse: { channel: "sfx", sounds: ["footstep_metal_01", "footstep_metal_02"] }, footstep_house: { channel: "sfx", sounds: ["footstep_wood_02", "footstep_wood_03"] }, footstep_shack: { channel: "sfx", sounds: ["footstep_wood_01"] }, footstep_sand: { channel: "sfx", sounds: ["footstep_sand_01", "footstep_sand_02"] }, footstep_water: { channel: "sfx", sounds: ["footstep_water_01", "footstep_water_02"] }, footstep_tile: { channel: "sfx", sounds: ["footstep_tile_01", "footstep_tile_02"] }, footstep_asphalt: { channel: "sfx", sounds: ["footstep_asphalt_01", "footstep_asphalt_02"] }, footstep_brick: { channel: "sfx", sounds: ["footstep_brick_01"] }, footstep_bunker: { channel: "sfx", sounds: ["footstep_metal_04", "footstep_metal_05"] }, footstep_stone: { channel: "sfx", sounds: ["footstep_stone_01"] }, footstep_carpet: { channel: "sfx", sounds: ["footstep_carpet_01"] }, player_bullet_hit: { channel: "hits", sounds: ["player_bullet_hit_01"] }, metal_punch: { channel: "hits", sounds: ["metal_punch_hit_01", "metal_punch_hit_02"] }, cloth_punch: { channel: "hits", sounds: ["cloth_hit_01"] }, cloth_bullet: { channel: "hits", sounds: ["cloth_hit_02"] }, organic_hit: { channel: "hits", sounds: ["organic_hit_01"] }, piano_hit: { channel: "hits", sounds: ["piano_hit_01", "piano_hit_02"] }, wall_bullet: { channel: "hits", sounds: ["metal_bullet_hit_01"] }, wall_wood_bullet: { channel: "hits", sounds: ["wood_bullet_hit_02"] }, wall_brick_bullet: { channel: "hits", sounds: ["brick_bullet_hit_01"] }, stone_bullet: { channel: "hits", sounds: ["stone_bullet_hit_01"] }, barrel_bullet: { channel: "hits", sounds: ["metal_bullet_hit_03"] }, pan_bullet: { channel: "hits", sounds: ["pan_bullet_hit_01"] }, silo_bullet: { channel: "hits", sounds: ["metal_bullet_hit_04"] }, toilet_porc_bullet: { channel: "hits", sounds: ["toilet_bullet_hit_01"] }, toilet_metal_bullet: { channel: "hits", sounds: ["toilet_bullet_hit_02"] }, glass_bullet: { channel: "hits", sounds: ["glass_bullet_hit_01"] }, cobalt_bullet: { channel: "hits", sounds: ["metal_bullet_hit_02"] }, concrete_hit: { channel: "hits", sounds: ["concrete_hit_01"] }, wood_prop_bullet: { channel: "hits", sounds: ["wood_bullet_hit_03"] }, wood_crate_bullet: { channel: "hits", sounds: ["wood_bullet_hit_04"] }, ammo_crate_bullet: { channel: "hits", sounds: ["plastic_bullet_hit_01"] }, bush_bullet: { channel: "hits", sounds: ["bush_bullet_hit_01"] }, tree_bullet: { channel: "hits", sounds: ["wood_bullet_hit_01"] }, player_bullet_grunt: { channel: "hits", sounds: ["player_bullet_hit_02"] }, bullet_whiz: { channel: "sfx", sounds: ["bullet_whiz_01", "bullet_whiz_02", "bullet_whiz_03"] }, frag_grass: { channel: "hits", sounds: ["frag_grass_01"] }, frag_sand: { channel: "hits", sounds: ["frag_sand_01"] }, frag_water: { channel: "hits", sounds: ["frag_water_01"] }, kill_leader_assigned: { channel: "ui", sounds: ["kill_leader_assigned_01", "kill_leader_assigned_02"] }, kill_leader_dead: { channel: "ui", sounds: ["kill_leader_dead_01", "kill_leader_dead_02"] }, cluck: { channel: "sfx", sounds: ["cluck_01", "cluck_02"] } }, Qr = { activePlayer: { volume: .5, maxRange: 48, list: "players", type: "sound" }, otherPlayers: { volume: .5, maxRange: 48, list: "players", type: "sound" }, hits: { volume: .4, maxRange: 48, list: "hits", type: "sound" }, sfx: { volume: 1, maxRange: 48, list: "sfx", type: "sound" }, ambient: { volume: 1, maxRange: 1, list: "ambient", type: "sound" }, ui: { volume: .75, maxRange: 48, list: "ui", type: "sound" }, music: { volume: 1, maxRange: 1, list: "music", type: "music" } }, Jr = { cathedral: { path: "audio/reverb/cathedral_01.mp3", volume: .7, stereoSpread: .004 }, cave: { path: "audio/reverb/cave_mono_01.mp3", volume: .7, echoVolume: .5, echoDelay: .25, echoLowPass: 800, stereoSpread: .004 } }, ye = { Sounds: Kr, Groups: Yr, Channels: Qr, Reverbs: Jr }, ii = .003, pt = .5; class ea { constructor(e) { s(this, "mute", !1); s(this, "masterVolume", 1); s(this, "soundVolume", 1); s(this, "musicVolume", 1); s(this, "baseVolume", .5); s(this, "sounds", {}); s(this, "loadedFiles", {}); s(this, "preloadedSounds", !1); s(this, "cameraPos", h.create(0, 0)); s(this, "activeLayer", 0); s(this, "underground", !1); s(this, "soundInstances", []); be.Sound.volume = .5, be.Sound.on("fileload", this.loadHandler, this) } preloadSounds() { if (!this.preloadedSounds) { this.preloadedSounds = !0; const e = {}, t = Object.keys(ye.Sounds); for (let o = 0; o < t.length; o++) { const n = t[o], p = ye.Sounds[n], d = Object.keys(p); for (let f = 0; f < d.length; f++) { const w = d[f]; e[w] !== void 0 && console.log(`Sound ${w} defined multiple times!`), e[w] = !0 } } const i = [], r = Object.keys(ye.Channels); for (let o = 0; o < r.length; o++) { const n = r[o], p = ye.Channels[n], d = ye.Sounds[p.list], f = Object.keys(d); for (let w = 0; w < f.length; w++) { const g = f[w], x = d[g]; if (x.preload === void 0 || x.preload) { const S = { canCoalesce: x.canCoalesce, channels: x.maxInstances, volume: x.volume }; i.push({ name: g, channel: n, path: x.path, options: S, priority: x.loadPriority || 0 }) } } } i.sort((o, n) => n.priority - o.priority); for (let o = 0; o < i.length; o++) { const n = i[o]; this.loadSound(n) } const a = ye.Reverbs, m = Object.keys(a); for (let o = 0; o < m.length; o++) { const n = m[o], p = a[n]; be.Sound.registerReverb(p.path, n, p) } } } loadSound(e) { const t = e.name + e.channel; this.sounds[t] || (be.Sound.registerSound(e.path, t, e.options), this.sounds[t] = { path: e.path, name: e.name, channel: e.channel }) } loadHandler(e) { this.loadedFiles[e] = !0 } update(e) { for (let r = this.soundInstances.length - 1; r >= 0; r--) { const a = this.soundInstances[r]; (a.instance.playState == "playFinished" || a.instance.playState == "playInterrupted" || a.instance.playState == "playFailed") && this.soundInstances.splice(r, 1) } const t = [0, 1, 1 / 3, 2 / 3], i = this.underground ? t[this.activeLayer] : 0; be.Sound.setReverbs({ cathedral: i }), be.Sound.update(e) } playSound(e, t = {}) { if (!e || e == "none") return null; t.channel = t.channel || "activePlayer", t.startSilent = t.startSilent || !1, t.forceStart = t.forceStart || !1, t.loop = t.loop || !1, t.soundPos = t.soundPos || null, t.fallOff = t.fallOff || 0, t.filter = t.filter || "", t.delay = t.delay || 0, t.ignoreMinAllowable = t.ignoreMinAllowable || !1, t.rangeMult = t.rangeMult || 1, t.offset = t.offset || 0, t.ambient = t.channel == "ambient" || t.channel == "music", t.detune = t.detune || 0, t.volumeScale = t.volumeScale || 1; let i = null; const r = ye.Channels[t.channel]; if (r && (!this.mute || t.forceStart)) { const a = this.baseVolume * 1 * this.getTypeVolume(r.type) * t.volumeScale, m = t.layer !== void 0 && !y.sameAudioLayer(t.layer, this.activeLayer), o = t.filter ? m || t.forceFilter ? t.filter : "reverb" : "none"; if (t.channel != "activePlayer" && t.soundPos) { const n = h.sub(this.cameraPos, t.soundPos), p = h.length(n); let d = r.maxRange * t.rangeMult; _.eqAbs(d, 0) && (d = 1); const f = _.clamp(Math.abs(p / d), 0, 1), w = Math.pow(1 - f, 1 + t.fallOff * 2); let g = r.volume * w * a; if (g = m ? g * pt : g, g > ii || t.ignoreMinAllowable) { const x = _.clamp(n.x / d * -1, -1, 1); i = be.Sound.play(e + t.channel, { filter: o, loop: t.loop ? -1 : 0, volume: t.startSilent ? 0 : g, pan: x, delay: t.delay, offset: t.offset, ambient: t.ambient, detune: t.detune }) } } else { let n = r.volume * a; n = m ? n * pt : n, i = be.Sound.play(e + t.channel, { filter: o, loop: t.loop ? -1 : 0, volume: t.startSilent ? 0 : n, delay: t.delay, offset: t.offset, ambient: t.ambient, detune: t.detune }) } if (i && (t.loop || t.channel == "music")) { const n = t.channel == "music" ? "music" : "sound"; this.soundInstances.push({ instance: i, type: n }) } } return i } playGroup(e, t = {}) { const i = ye.Groups[e]; if (i) { const r = i.sounds, a = Math.floor(y.random(0, r.length)); return t.channel = i.channel, this.playSound(r[a], t) } return null } updateSound(e, t, i, r = {}) { r.fallOff = r.fallOff || 0, r.rangeMult = r.rangeMult || 1, r.ignoreMinAllowable = r.ignoreMinAllowable || !1, r.volumeScale = r.volumeScale || 1; const a = ye.Channels[t]; if (e && a) { const m = this.baseVolume * 1 * this.getTypeVolume(a.type) * r.volumeScale, o = h.sub(this.cameraPos, i), n = h.length(o); let p = a.maxRange * r.rangeMult; _.eqAbs(p, 0) && (p = 1); const d = _.clamp(Math.abs(n / p), 0, 1), f = Math.pow(1 - d, 1 + r.fallOff * 2); let w = a.volume * f * m; if (w = r.layer === void 0 || y.sameAudioLayer(r.layer, this.activeLayer) ? w : w * pt, w > ii || r.ignoreMinAllowable) { const x = _.clamp(o.x / p * -1, -1, 1); e.volume = w, e.pan = x } } } setMasterVolume(e) { e = _.clamp(e, 0, 1), be.Sound.volume = e } _setInstanceTypeVolume(e, t) { t = _.clamp(t, 0, 1); const i = this.getTypeVolume(e), r = i > 1e-4 ? t / i : 0; for (let a = 0; a < this.soundInstances.length; a++) { const m = this.soundInstances[a]; m.type == e && (m.instance.volume *= r) } } setSoundVolume(e) { this._setInstanceTypeVolume("sound", e), this.soundVolume = e } setMusicVolume(e) { this._setInstanceTypeVolume("music", e), this.musicVolume = e } setVolume(e, t, i) { if (e) { i = i || "sound"; const r = this.getTypeVolume(i); e.volume = t * r } } getVolume(e) { return e ? e.volume : 0 } setMute(e) { return this.mute = e, be.Sound.setMute(this.mute), this.mute } muteToggle() { return this.setMute(!this.mute) } stopSound(e) { e == null || e.stop() } stopAll() { be.Sound.stop() } allLoaded() { const e = Object.keys(this.sounds); for (let t = 0; t < e.length; t++) { const i = this.sounds[e[t]]; if (!this.isSoundLoaded(i.name, i.channel)) return !1 } return !0 } isSoundLoaded(e, t) { const i = this.sounds[e + t]; return i && this.loadedFiles[i.path] } isSoundPlaying(e) { return !!e && e.playState == be.Sound.PLAY_SUCCEEDED } getSoundDefVolume(e, t) { const i = ye.Sounds[t][e], r = ye.Channels[t]; return i && r ? i.volume * r.volume : 1 } getTypeVolume(e) { switch (e) { case "music": return this.musicVolume; case "sound": return this.soundVolume; default: return this.soundVolume } } } function ta() { return new URLSearchParams(self.location.search).has("crazygames") } async function ia() { return new Promise(function(u, e) { const t = document.createElement("script"); t.src = "https://sdk.crazygames.com/crazygames-sdk-v3.js", document.head.appendChild(t), Ee.phone && (document.getElementById("btn-hamburger").style.display = "none"), document.getElementById("crazygamesDiscord").style.display = "block", t.addEventListener("load", async function() { await window.CrazyGames.SDK.init(), Mt("survev-io_728x90", 728, 90), setInterval(() => { const i = document.getElementById("start-menu-wrapper"); getComputedStyle(i).display != "none" && Mt("survev-io_728x90", 728, 90) }, 6e4), u() }), t.addEventListener("error", function() { console.log("CrazyGames SDK load error"), e() }) }) } async function Mt(u, e, t) { return new Promise(async function(i, r) { try { await window.CrazyGames.SDK.banner.requestBanner({ id: u, width: e, height: t }), i() } catch (a) { console.log("Banner request error", a), r() } }) } function mt(u) { const e = { adFinished: u, adError: u, adStarted: () => console.log("Start midgame ad") }; window.CrazyGames.SDK.ad.requestAd("midgame", e) } function ji(u) { let e = u.target; for (; e && e !== document.body;) { const t = getComputedStyle(e).overflowY; if (t === "auto" || t === "scroll") return; e = e.parentElement } u.preventDefault() } window.addEventListener("wheel", ji, { passive: !1 }); window.addEventListener("touchmove", ji, { passive: !1 }); document.addEventListener("keydown", u => { if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(u.key)) { const t = u.target, i = ["INPUT", "TEXTAREA", "SELECT", "BUTTON"]; if (u.key === " " && (i.includes(t.tagName) || t.isContentEditable)) return; u.preventDefault() } }); const ra = { ENV: "website", muteAudio: !1, masterVolume: 1, soundVolume: 1, musicVolume: 1, highResTex: !0, screenShake: !0, anonPlayerNames: !1, touchMoveStyle: "anywhere", touchAimStyle: "anywhere", touchAimLine: !0, profile: null, playerName: "", region: "na", gameModeIdx: 2, teamAutoFill: !0, language: "en", prerollGamesPlayed: 0, totalGamesPlayed: 0, promptAppRate: !0, regionSelected: !1, lastNewsTimestamp: 0, perkModeRole: "", loadout: ne.defaultLoadout(), sessionCookie: "", binds: "", version: 1 }; class aa { constructor() { s(this, "loaded", !1); s(this, "localStorageAvailable", !0); s(this, "config", {}); s(this, "onModifiedListeners", []) } async load(e) { const t = r => { let a = {}; try { a = JSON.parse(r) } catch {} this.config = y.mergeDeep({}, ra, a), this.checkUpgradeConfig(), this.onModified(), this.loaded = !0 }; let i = "{}"; try { i = localStorage.getItem("surviv_config") } catch { this.localStorageAvailable = !1 } t(i), ta() ? (this.config.ENV = "CrazyGames", await ia()) : (this.config.ENV = "website", document.getElementById("btn-start-fullscreen").style.display = "inline-block", document.getElementById("btn-game-fullscreen").style.display = "block", document.getElementById("left-column").style.display = "block"), e() } store() { const e = JSON.stringify(this.config); if (this.localStorageAvailable) try { localStorage.setItem("surviv_config", e) } catch {} } set(e, t) { if (!e) return; const i = e.split("."); let r = this.config; for (; i.length > 1;) r = r[i.shift()]; r[i.shift()] = t, this.store(), this.onModified(e) } get(e) { if (!e) return; const t = e.split("."); let i = this.config; for (let r = 0; r < t.length; r++) i = i[t[r]]; return i } addModifiedListener(e) { this.onModifiedListeners.push(e) } onModified(e) { for (let t = 0; t < this.onModifiedListeners.length; t++) this.onModifiedListeners[t](e) } checkUpgradeConfig() {} } const sa = JSON.parse(`["2 girls 1 cup","2g1c","4r5e","5h1t","5hit","a_s_s","a55","a55hole","acrotomophilia","aeolus","ahole","alabama hot pocket","alaskan pipeline","anal","analprobe","anilingus","anus","apeshit","ar5e","areola","areole","arian","arrse","arse","arsehole","aryan","ass","ass hole","assbag","assbandit","assbang","assbanged","assbanger","assbangs","assbite","assclown","asscock","asscracker","asses","assface","assfuck","assfucker","ass-fucker","assfukka","assgoblin","assh0le","asshat","ass-hat","asshead","assho1e","asshole","assholes","asshopper","ass-jabber","assjacker","asslick","asslicker","assmaster","assmonkey","assmunch","assmuncher","assnigger","asspirate","ass-pirate","assshit","assshole","asssucker","asswad","asswhole","asswipe","asswipes","auto erotic","autoerotic","axwound","azazel","azz","b!tch","b00bs","b17ch","b1tch","babe","babeland","babes","baby batter","baby juice","balls","ball gag","ball gravy","ball kicking","ball licking","ball sack","ball sucking","ballbag","ballsack","bampot","bang","bangbros","banger","bareback","barely legal","barenaked","barf","bastard","bastardo","bastards","bastinado","bawdy","bbw","bdsm","beaner","beaners","beardedclam","beastial","beastiality","beatch","beater","beaver cleaver","beaver lips","beeyotch","bellend","beotch","bestial","bestiality","bi+ch","biatch","big black","big breasts","big knockers","big tits","bigtits","bimbo","bimbos","birdlock","bitch","bitchass","bitched","bitcher","bitchers","bitches","bitchin","bitching","bitchtits","bitchy","black cock","blonde action","blonde on blonde action","blow job","blow your load","blowjob","blowjobs","blue waffle","blumpkin","bod","bodily","boink","boiolas","bollock","bollocks","bollok","bollox","bondage","boned","boner","boners","bong","boob","boobies","boobs","booby","booger","bookie","booobs","boooobs","booooobs","booooooobs","bootee","bootie","booty","booty call","booze","boozer","boozy","bosom","bosomy","bra","brassiere","breast","breasts","breeder","brotherfucker","brown showers","brunette action","buceta","bugger","bukkake","bull shit","bulldyke","bullet vibe","bullshit","bullshits","bullshitted","bullturds","bum","bumblefuck","bung","bung hole","bunghole","bunny fucker","busty","butt","butt fuck","butt plug","buttcheeks","buttfuck","buttfucka","buttfucker","butthole","buttmuch","butt-pirate","buttplug","c.0.c.k","c.o.c.k.","c.u.n.t","c0ck","c-0-c-k","c0cksucker","caca","cahone","camel toe","cameltoe","camgirl","camslut","camwhore","carpet muncher","carpetmuncher","cawk","cervix","chesticle","chinc","chincs","chink","choad","chocolate rosebuds","chode","chodes","cipa","circlejerk","cl1t","cleveland steamer","climax","clit","clitface","clitfuck","clitoris","clitorus","clits","clitty","clover clamps","clusterfuck","cnut","cocain","cocaine","cock","c-o-c-k","cock sucker","cockass","cockbite","cockblock","cockburger","cockeye","cockface","cockfucker","cockhead","cockholster","cockjockey","cockknocker","cockknoker","cocklump","cockmaster","cockmongler","cockmongruel","cockmonkey","cockmunch","cockmuncher","cocknose","cocknugget","cocks","cockshit","cocksmith","cocksmoke","cocksmoker","cocksniffer","cocksuck","cocksucked","cocksucker","cock-sucker","cocksucking","cocksucks","cocksuka","cocksukka","cockwaffle","coital","cok","cokmuncher","coksucka","commie","condom","coochie","coochy","coon","coons","cooter","coprolagnia","coprophilia","corksucker","cornhole","cox","crabs","crack","crackwhore","crap","crappy","creampie","crotte","cum","cumbubble","cumdumpster","cumguzzler","cumjockey","cummer","cummin","cumming","cums","cumshot","cumshots","cumslut","cumstain","cumtart","cunilingus","cunillingus","cunnie","cunnilingus","cunny","cunt","c-u-n-t","cuntass","cuntface","cunthole","cunthunter","cuntlick","cuntlicker","cuntlicking","cuntrag","cunts","cuntslut","cyalis","cyberfuc","cyberfuck","cyberfucked","cyberfucker","cyberfuckers","cyberfucking","d0ng","d0uch3","d0uche","d1ck","d1ld0","d1ldo","dago","dagos","darkie","damn","damned","dammit","date rape","daterape","dawgie-style","deep throat","deepthroat","deggo","dendrophilia","dick","dickbag","dickbeaters","dickdipper","dickface","dickflipper","dickfuck","dickfucker","dickhead","dickheads","dickhole","dickish","dick-ish","dickjuice","dickmilkÂ ","dickmonger","dickripper","dicks","dicksipper","dickslap","dick-sneeze","dicksuck","dicksucker","dicksucking","dicktickler","dickwad","dickweasel","dickweed","dickwhipper","dickwod","dickzipper","diddle","dike","dildo","dildos","diligaf","dillweed","dimwit","dingle","dingleberries","dingleberry","dink","dinks","dipship","dipshit","dirsa","dirty pillows","dirty sanchez","dlck","dog style","dog-fucker","doggie style","doggiestyle","doggie-style","doggin","dogging","doggy style","doggystyle","doggy-style","dolcett","domination","dominatrix","dommes","dong","donkey punch","donkeyribber","doochbag","doofus","dookie","doosh","dopey","double dong","double penetration","doublelift","douch3","douche","douchebag","douchebags","douche-fag","douchewaffle","douchey","dp action","drunk","dry hump","duche","dumass","dumb ass","dumbass","dumbasses","dumbcunt","dumbfuck","dumbshit","dummy","dumshit","dvda","dyke","dykes","eat my ass","ecchi","ejaculate","ejaculated","ejaculates","ejaculating","ejaculatings","ejaculation","ejakulate","enlargement","erect","erection","erotic","erotism","escort","essohbee","eunuch","extacy","extasy","f u c k","f u c k e r","f.u.c.k","f_u_c_k","f4nny","fack","fag","fagbag","fagfucker","fagg","fagged","fagging","faggit","faggitt","faggot","faggotcock","faggs","fagot","fagots","fags","fagtard","faig","faigt","fanny","fannybandit","fannyflaps","fannyfucker","fanyy","fartknocker","fatass","fcuk","fcuker","fcuking","fecal","feck","fecker","felch","felcher","felching","fellate","fellatio","feltch","feltcher","female squirting","femdom","figging","fingerbang","fingerfuck","fingerfucked","fingerfucker","fingerfuckers","fingerfucking","fingerfucks","fingering","fisted","fistfuck","fistfucked","fistfucker","fistfuckers","fistfucking","fistfuckings","fistfucks","fisting","fisty","flamer","flange","floozy","foad","foah","fondle","foobar","fook","fooker","foot fetish","footjob","foreskin","freex","frigg","frigga","frotting","fubar","fuck","f-u-c-k","fuck buttons","fuck off","fucka","fuckass","fuckbag","fuckboy","fuckbrain","fuckbutt","fuckbutter","fucked","fucker","fuckers","fuckersucker","fuckface","fuckhead","fuckheads","fuckhole","fuckin","fucking","fuckings","fuckingshitmotherfucker","fuckme","fucknugget","fucknut","fucknutt","fuckoff","fucks","fuckstick","fucktard","fuck-tard","fucktards","fucktart","fucktwat","fuckup","fuckwad","fuckwhit","fuckwit","fuckwitt","fudge packer","fudgepacker","fuk","fuker","fukker","fukkin","fuks","fukwhit","fukwit","futanari","fux","fux0r","fvck","fxck","gae","gai","gang bang","gangbang","gangbanged","gangbangs","ganja","gay","gay sex","gayass","gaybob","gaydo","gayfuck","gayfuckist","gaylord","gays","gaysex","gaytard","gaywad","genitals","gey","gfy","ghay","ghey","giant cock","gigolo","girl on","girl on top","girls gone wild","glans","goatcx","goatse","god damn","godamn","godamnit","goddam","god-dam","goddammit","goddamn","goddamned","god-damned","goddamnit","gokkun","golden shower","goldenshower","gonad","gonads","goo girl","gooch","goodpoop","gook","gooks","goregasm","gringo","grope","group sex","gspot","g-spot","gtfo","guido","guro","h0m0","h0mo","hand job","handjob","hard core","hard on","hardcore","hardcoresex","he11","heeb","hemp","hentai","heroin","herp","herpes","herpy","heshe","hitler","hiv","ho","hoar","hoare","hobag","hoe","hoer","hom0","homey","homo","homodumbshit","homoerotic","homoey","honkey","honky","hooch","hookah","hooker","hoor","hootch","hooter","hooters","hore","horniest","horny","hot carl","hot chick","hotsex","how to kill","how to murder","huge fat","hump","humped","humping","hussy","hymen","inbred","incest","injun","intercourse","j3rk0ff","jack Off","jackass","jackhole","jackoff","jack-off","jaggi","jagoff","jail bait","jailbait","jap","japs","jelly donut","jerk","jerk off","jerk0ff","jerkass","jerked","jerkoff","jerk-off","jigaboo","jiggaboo","jiggerboo","jism","jiz","jizm","jizz","jizzed","juggs","jungle bunny","junglebunny","junkie","junky","kawk","kike","kikes","kinbaku","kinkster","kinky","kkk","knob","knobbing","knobead","knobed","knobend","knobhead","knobjocky","knobjokey","kock","kondum","kondums","kooch","kooches","kootch","kraut","kum","kummer","kumming","kums","kunilingus","kunja","kunt","kyke","l3i+ch","l3itch","labia","lameass","lardass","leather restraint","leather straight jacket","lech","lemon party","leper","lesbian","lesbians","lesbo","lesbos","lez","lezbian","lezbians","lezbo","lezbos","lezzie","lezzies","lezzy","lmao","lmfao","loin","loins","lolita","lovemaking","lube","lust","lusting","lusty","m0f0","m0fo","m45terbate","ma5terb8","ma5terbate","make me come","male squirting","mams","masochist","massa","masterb8","masterbat","masterbat3","masterbate","master-bate","masterbating","masterbation","masterbations","masturbate","masturbating","masturbation","maxi","mcfagget","menage a trois","menses","menstruate","menstruation","meth","m-fucking","mick","milf","minge","missionary position","mof0","mofo","mo-fo","molest","moolie","moron","mothafuck","mothafucka","mothafuckas","mothafuckaz","mothafucked","mothafucker","mothafuckers","mothafuckin","mothafucking","mothafuckings","mothafucks","mother fucker","motherfuck","motherfucka","motherfucked","motherfucker","motherfuckers","motherfuckin","motherfucking","motherfuckings","motherfuckka","motherfucks","mound of venus","mr hands","mtherfucker","mthrfucker","mthrfucking","muff","muff diver","muffdiver","muffdiving","munging","murder","mutha","muthafecker","muthafuckaz","muthafucker","muthafuckker","muther","mutherfucker","mutherfucking","muthrfucking","n1gga","n1gger","nad","nads","naked","nambla","napalm","nappy","nawashi","nazi","nazism","negro","neonazi","nig nog","nigaboo","nigg3r","nigg4h","nigga","niggah","niggas","niggaz","nigger","niggers","niggle","niglet","nimphomania","nimrod","ninny","nipple","nipples","nob","nob jokey","nobhead","nobjocky","nobjokey","nooky","nsfw images","nude","nudity","numbnuts","nut sack","nutsack","nympho","nymphomania","octopussy","omorashi","one cup two girls","one guy one jar","opiate","opium","oral","orally","organ","orgasim","orgasims","orgasm","orgasmic","orgasms","orgies","orgy","ovary","ovum","ovums","p.u.s.s.y.","p0rn","paddy","paedophile","paki","panooch","pantie","panties","panty","pastie","pasty","pawn","pcp","pecker","peckerhead","pedo","pedobear","pedophile","pedophilia","pedophiliac","peepee","pegging","penetrate","penetration","penial","penile","penis","penisbanger","penisfucker","penispuffer","perversion","peyote","phalli","phallic","phone sex","phonesex","phuck","phuk","phuked","phuking","phukked","phukking","phuks","phuq","piece of shit","pigfucker","pillowbiter","pimp","pimpis","pinko","piss pig","pissed","pissed off","pisser","pissers","pisses","pissflaps","pissin","pissing","pissoff","piss-off","pisspig","playboy","pleasure chest","pms","polack","pole smoker","polesmoker","pollock","ponyplay","poof","poon","poonani","poonany","poontang","poop","poop chute","poopchute","poopuncher","porch monkey","porchmonkey","porn","porno","pornography","pornos","potty","prick","pricks","prig","prince albert piercing","pron","prostitute","prude","pthc","pube","pubes","pubic","pubis","punanny","punany","punkass","punky","punta","puss","pusse","pussi","pussies","pussy","pussylicking","pussypounder","pussys","pust","puto","queaf","queef","queer","queerbait","queerhole","queero","queers","quicky","quim","racy","raghead","raging boner","rape","raped","raper","raping","rapist","raunch","rectal","rectum","rectus","reefer","reetard","reich","renob","retard","retarded","reverse cowgirl","revue","rimjaw","rimjob","rimming","ritard","rosy palm","rosy palm and her 5 sisters","rtard","r-tard","rump","rumprammer","ruski","rusty trombone","s hit","s&m","s.h.i.t.","s.o.b.","s_h_i_t","s0b","sadism","sadist","sand nigger","sandler","sandnigger","sanger","santorum","scag","scantily","scat","schizo","schlong","scissoring","screw","screwed","screwing","scroat","scrog","scrot","scrote","scrotum","scrud","scum","seaman","seamen","seduce","seks","semen","sex","sexo","sexual","sexy","sh!+","sh!t","sh1t","s-h-1-t","shag","shagger","shaggin","shagging","shamedame","shaved beaver","shaved pussy","shemale","shi+","shibari","shit","s-h-i-t","shitass","shitbag","shitbagger","shitblimp","shitbrains","shitbreath","shitcanned","shitcunt","shitdick","shite","shiteater","shited","shitey","shitface","shitfaced","shitfuck","shitfull","shithead","shithole","shithouse","shiting","shitings","shits","shitspitter","shitstain","shitt","shitted","shitter","shitters","shittiest","shitting","shittings","shitty","shiz","shiznit","shota","shrimping","sissy","skag","skank","skeet","skullfuck","slag","slanteye","slave","sleaze","sleazy","slut","slutbag","slutdumper","slutkiss","sluts","smeg","smegma","smut","smutty","snatch","snowballing","snuff","s-o-b","sodom","sodomize","sodomy","son-of-a-bitch","souse","soused","spac","sperm","spic","spick","spik","spiks","splooge","splooge moose","spooge","spook","spread legs","spunk","steamy","stfu","stiffy","stoned","strap on","strapon","strappado","strip","strip club","stroke","stupid","style doggy","suck","suckass","sucked","sucking","suckmydick","sucks","suicide girls","sultry women","sumofabiatch","swastika","swinger","t1t","t1tt1e5","t1tties","tainted love","tampon","tard","taste my","tawdry","tea bagging","teabagging","teat","teets","teez","terd","teste","testee","testes","testical","testicle","testis","threesome","throating","thrust","thug","thundercunt","tied up","tight white","tinkle","tit","titfuck","titi","tits","titt","tittie5","tittiefucker","titties","titty","tittyfuck","tittyfucker","tittywank","titwank","toke","tongue in a","toots","topless","tosser","towelhead","tramp","tranny","transsexual","trashy","tribadism","tub girl","tubgirl","turd","tush","tushy","tw4t","twat","twathead","twatlips","twats","twatty","twatwaffle","twink","twinkie","two girls one cup","twunt","twunter","ugly","unclefucker","undies","undressing","unwed","upskirt","urethra play","urinal","urine","urophilia","uterus","uzi","v14gra","v1gra","vag","vagina","vajayjay","va-j-j","valium","venus mound","viagra","vibrator","violet wand","virgin","vixen","vjayjay","vodka","vomit","vorarephilia","voyeur","vulgar","vulva","w00se","wad","wang","wank","wanker","wankjob","wanky","wazoo","wedgie","weed","weenie","weewee","weiner","weirdo","wench","wet dream","wetback","wh0re","wh0reface","white power","whitey","whiz","whoar","whoralicious","whore","whorealicious","whorebag","whored","whoreface","whorehopper","whorehouse","whores","whoring","wigger","willies","willy","womb","woody","wop","wrapping men","wrinkled starfish","wtf","xrated","x-rated","xxx","yaoi","yeasty","yellow showers","yiffy","yobbo","zoophile","zoophilia","zubb","(ock","[ock",".f uc k","@rse","@rsehol","@unt","[unt","< unt","<.unt","<loth head","<lothhead","<nuts","<o(k","<o<&nbsp;k","<o<ksu<ka","<o<ksu<ker","<oon","<u&nbsp;nt","<u&nbsp;nts","<u*t","<unt","<unt's","<vnt","<vnts","a$$hole","a$$hole$","a$$holes","a.rse","a+*hole","ar$ehole","ar$hole","ar$holes","ar5h0le","ar5h0les","ars3","arse hole","arseh0le","arseh0les","arseho","arsehol","arseholes","arsewipe","arsh0le","arshole","arsholes","ashole","ass h0le","assh0les","b.astard","b.ollocks","b.ugger","b@st@rd","b@st@rds","b00tha","b00thas","b0ll0cks","b0llocks","b3llend","basterd","basyard","basyards","batty boy","batty&nbsp;boi","batty&nbsp;boy","beef curtains","belend","bell end","bell.end","bell-end","bin dippers","bin-dippers","bo11ocks","boabie sooking","boaby sooking","boll0cks","bolocks","bolox","bootha","boothas","bum bandit","bum hole","bumbandit","bum-bandit","bumh0l3","bumh0le","bumhol3","bumhole","c *nt!","c *nts!","c u n t","c u n t.","c#nt","c&nbsp;u&nbsp;n&nbsp;t","c* nt","c.unt","c.untyb.ollocks","c_u_n_t","c00n","c0cksucka","cahnt","cahnts","clunge","cnuts","co(k","coc&nbsp;k","cocksucka","cocksuckers","cocksuckers.","cossor ali","cretin","cripple","critest","cu&nbsp;nt","cu&nbsp;nts","cunting","cunt's","cvnt","cvnts","d1ck!","d1ckh@ed","darky","dick&nbsp;head","dumbfucker","dxxkhead","ethnics","f ck","f o a d","f off","f u c ked","f uc k","f uc king","f uck","f###","f##k","f##king","f#cked","f$cks","f&nbsp;cked","f&nbsp;u&nbsp;c&nbsp;k","f&nbsp;uck","f&nbsp;ucker","f&nbsp;ucking","f()()k","f()()ker","f()()king","f*#kin'","f*&k","f*&k!ng","f.o.a.d","f.o.a.d.","f.u.c.k.","f.uck","f@@@in","f@@@ing","f@ck","f@g","f@gs","f[_]cker","f[_]cking","f^^k","f^^ked","f^^ker","f^^king","f^ck","f^cker","f^cking","f__kin","f__king","f<uk","f>>k","f00k","f00ked","f0oked","fackin","facking","f4ggot","f4gg0t","fagg0t","faggits","fagits","fck","f'ck","fck&nbsp;ing","fck1ng","fckeud","fckin","fcking","fcks","fckw1t","fckwit","fcuked","fcukin","fcuks","feckin","fecking","f---ed","fekking","felched","feltching","f-----g","f---ing","f--k","fkin","fking","flucknuts","fo0ked","f-o-a-d","fookd","fooked","fookin","fookin'","fooking","frig","frigging","frigin","friging","fu <k","fu&kin","fu&king","fu&nbsp;ck","fu&nbsp;cked","fu&nbsp;cker","fu&nbsp;cking","fu(k","fu(ker","fu(kers","fu.ck","fu@k","fu@ker","fu^k","fu^ker","fu^king","fu< kin","fu<k","f-u-<-k","fu<ked","fu<ker","fu<kin","fu<king","fu<kker","fu<kr","fu<ks","fuc&nbsp;ked","fuc&nbsp;ker","fuc&nbsp;king","f-uck","fÃºck","fÃºÃ§k","fÃ¹ck","fÃ»ck","fÃ¼ck","fuck&nbsp;ed","fuck&nbsp;ing","fucke&nbsp;d","fucki&nbsp;ng","fÃºcking","fuckinghell","fuckk","fuckw1t","fuck-wit","fuckwits","fucw1t","fucwit","fudge p@cker","fudgep@cker","fudge-p@cker","fudge-packer","fudgpacker","fukced","fuked","fukin","fuking","fukk","fukked","fukking","fuukn","fvckup","fvck-up","fvckw1t","fvckwit","gang-bang","gash","gayhole","gimp","girlie-gardening","goris","gypo","gypos","gyppo","gyppos","hvns","israelians","ities","k@ffir","k@ffirs","k@fir","k@firs","kaf1r","kaff1r","kaffir","kaffirs","kafir","kafirs","kafr","kants","khunt","kiddie fiddler","kiddie fiddling","kiddie-fiddler","kiddie-fiddling","kiddy fiddler","kiddyfiddler","kiddy-fiddler","kn0b","knob&nbsp;head","knobber","kuffar","m.inge","m.otherf.ucker","m1nge","mofuccer","mofucker","mofuckers","mofucking","mofukcer","mohterfuccer","mohterfuccers","mohterfuck","mohterfucker","mohterfuckers","mohterfucking","mohterfucks","mohterfuk","mohterfukcer","mohterfukcers","mohterfuking","mohterfuks","moterfuccer","moterfuck","moterfucker","moterfuckers","moterfucking","moterfucks","mothafuccer","motha-fucka","mother f---ers","motherfuccer","motherfuccers","motherfukkker","mthafucca","mthafuccas","mthafucka","mthafuckas","mthafukca","mthafukcas","muff-diver","muff-diving","muffs","muth@fucker","muthafuccer","muthafuck","muthafuck@","muthafucka","muthafuckers","muthafucking","muthafucks","muthafukas","niga","nignog","nig-nog","nob&nbsp;head","nonce","p.iss-flaps","p@ki","p@kis","p00f","p00fs","p00fter","p00fters","p0of","paedo","paedophiles","pak1","pakis","peado","peadofile","peadofiles","peedo","peedofile","peedofiles","peedophile","peedophiles","peedos","pench0d","pench0ds","penchod","penchods","phanny","phanny.","pheck","phecking","phelching","pheque","phequing","phucker","phuckin","phucking","phucks","pikey","pillow biter","pillow-biter","piss off","po0f","poff","ponce","poo stabber","poo stabbers","poofs","poofter","pr!ck","pr!ck.","pr1ck","pr1ck!","pr1cks","pr1cks!","prik","pu$$y","ragheads","ret@rd","rim job","s.hit","s1ut","sc u m!","sc um","sh hit","sh!te","sh!tes","sh1te","shirtlifter","shirtlifters","shit stabber","shit stabbers","shitstabber","shitstabbers","spastic","spaz","spaz.","spit roasting","spitroast","spit-roast","spit-roasting","spunking","ÃŸ0ll0Ã§k5","t w a t","t wat","t.wat","t0$$er","t0sser","t0ssers","tea-bagging","to55er","to55ers","tosser,","tossers","tossurs","towel head","tvvat","tvvats","tw at","tw&nbsp;at","tw@","tw@t","tw@ts","tw_t","twa t","twatt","twattish","twunts","up the gary","w anker","w ankers","w#nker","w#nkers","w*nkers, 0","w.ank","w@nk","w@nker","w@nkers","w@nks","w0g","w0gs","w4nker!","w4nkers!","wa nker","wan k er","wan k ers","wan ker","wanka","wanke r","wanked","wankers","wanking","wanks","wank's","wet spam","whanker","whankers","wog","xrse","xrseh","xrsehol","xrsehole","xxxhole","y!ddo!","y!ddo!!","yid","yido","zachariah bishop","blow-job","boner:deboner","bonk:bonkers","candy-ass","chuffnuts","cojones","dipstick","feak","furbox","furburger","gayboy","ginch","gnikcuf","hardon","honkers","kcid","kcuf","lactoids","lesbyterian","lezzo","man-root","nestlecock","onanism","pusy","queve","quimsteak","qveer","sappho","scumbag","scumber","sexpot","shagbucket","shagstress","snarf","sodomite","strollop","suckster","tnuc","toggaf","tribadist","twank","wiseass","wizzer","abbo","abortionist","abuser","alabama hotpocket","alligatorbait","analannie","analsex","arsebagger","arsebandit","arseblaster","arsecowboy","arsefuck","arsefucker","arsehat","arsehore","arsejockey","arsekiss","arsekisser","arselick","arselicker","arselover","arseman","arsemonkey","arsemunch","arsemuncher","arsepacker","arsepirate","arsepuppies","arseranger","arses","arsewhore","assbagger","assblaster","asscowboy","assholz","asshore","assjockey","asskiss","asskisser","assklown","asslover","assman","ass monkey","asspacker","asspuppies","assranger","asswhore","azzhole","backdoorman","badfuck","baldy","ball licker","balllicker","banging","barelylegal","barface","barfface","bassterds","bastardz","basterds","basterdz","bazongas","bazooms","beastality","beat-off","beatoff","beatyourmeat","bicurious","bigass","bigbastard","bigbutt","bitchez","bitchslap","biteme","boffing","bohunk","bollick","bootycall","bountybar","breastjob","breastlover","breastman","brothel","buggered","buggery","bukake","bullcrap","bulldike","bumfuck","bungabunga","butchbabes","butchdike","butchdyke","butt-bang","buttbang","buttface","butt-fuck","butt-fucker","butt-fuckers","buttfuckers","butthead","buttman","buttmunch","buttmuncher","buttpirate","buttstain","buttwipe","byatch","cacker","cameljockey","cawks","chav","cherrypopper","chickslick","clamdigger","clamdiver","clogwog","cnts","cntz","cockblocker","cockcowboy","cockfight","cock-head","cockknob","cocklicker","cocklover","cocknob","cockqueen","cockrider","cocksman","cocksucer","cocktease","cocky","coitus","coondog","copulate","cracker","crackpipe","crack-whore","crotchjockey","crotchmonkey","crotchrot","cumfest","cumm","cumquat","cumqueen","cunntt","cunteyed","cuntfuck","cuntfucker","cuntsucker","cuntz","cybersex","cyberslimer","damnation","damnit","datnigga","deapthroat","dego","devilworshipper","dickbrain","dickforbrains","dickless","dicklick","dicklicker","dickmilk","dilldo","dilldos","dixiedike","dixiedyke","dominatricks","dominatrics","douch","douchbag","drag queen","dragqueen","dragqween","dripdick","dumbbitch","easyslut","eatballs","eatme","eatpussy","enema","excrement","facefucker","facist","faeces","faget","faggots","fagit","fagz","faigs","fark","farted","farting","farty","fastfuck","fatfuck","fatfucker","fatso","feces","felatio","fister","flasher","flid","flipping the bird","flyd","flydie","flydye","footaction","footfuck","footfucker","footlicker","fornicate","freakfuck","freakyfucker","freefuck","fucck","fuckable","fuckbuddy","fuckedup","fuckfest","fuckfreak","fuckfriend","fuckher","fuckina","fuckingbitch","fuckingcunt","fuckinnuts","fuckinright","fuckit","fuckknob","fuckmehard","fuckmonkey","fuckpig","fuckwhore","fuckyou","fugly","Fukah","Fuken","Fukkah","Fukken","funfuck","fuuck","gangbanger","gatorbait","gaygirl","gaymuthafuckinwhore","gayz","getiton","givehead","glazeddonut","godammit","goddamit","goddamnes","goddamnmuthafucker","gonorrehea","gonzagas","gotohell","greaseball","grostulation","gypp","gyppie","gyppy","headfuck","hells","hijacker","hijacking","hillbillies","hindoo","hitlerism","hitlerist","hobo","hoes","holestuffer","homobangers","honger","hookers","hoore","horney","horseshit","hosejob","hotdamn","hotpussy","hottotrot","iblowu","idiot","insest","internet wife","intheass","inthebuff","jackshit","japcrap","jesuschrist","jiggabo","jihad","jijjiboo","jisim","jiss","jizim","jizjuice","jizzim","jizzum","jubblies","juggalo","kissass","knobz","krap","krappy","kumbubble","kumbullbe","kunnilingus","kunts","kuntz","lactate","lady boy","ladyboy","lapdance","lesbain","lesbayn","lesbin","lezbe","lezbefriends","lezz","lezzer","libido","lickme","limpdick","lipshits","lipshitz","livesex","loadedgun","lovebone","lovegoo","lovegun","lovejuice","lovemuscle","lovepistol","loverocket","low life","lowlife","lubejob","luckycameltoe","manhater","manpaste","masokist","massterbait","masstrbait","masstrbate","mastabate","mastabater","masterbaiter","master bates","masterbates","mastrabator","mattressprincess","meatbeater","meatrack","mgger","mggor","molestation","molester","molestor","moneyshot","mooncricket","motha fucker","motha fuker","motha fukkah","motha fukker","mother-fucker","mother fukah","mother fuker","mother fukkah","mother fukker","motherlovebone","muffdive","muffindiver","mufflikcer","muncher","mutha fucker","mutha fukah","mutha fuker","mutha fukkah","mutha fukker","nastt","nastybitch","nastyho","nastyslut","nastywhore","necro","negroes","negroid","niggaracci","niggard","niggarded","niggarding","niggardliness","niggardliness's,","niggardly","niggard's,","niggards","niggerhead","niggerhole","nigger's,","niggled","niggles","niggling","nigglings","niggor","niggur","nigr","nigra","nigre","nigur","niiger","niigr","nipplering","nittit","nlgger","nlggor","nofuckingway","nookey","nookie","nudger","nut case","nutcase","nutfucker","ontherag","orafis","orgasum","oriface","orifice","orifiss","packi","packie","packy","paedofile","pakie","paky","palesimian","panti","pearlnecklace","peckerwood","peeenus","peeenusss","peehole","peenus","peinus","penas","penis-breath","penises","penus","penuus","perv","pervert","phuc","phuker","phukker","phungky","pi55","picaninny","piccaninny","pickaninny","piky","pimper","pimpjuic","pimpjuice","pimpsimp","pindick","piss","pisshead","play boy","play bunny","playbunny","play girl","playgirl","plumper","pocketpool","polac","polak","pooperscooper","pooping","poorwhitetrash","poostabber","popimp","pornflick","pornking","pornprincess","pric","prickhead","pu55i","pu55y","pubiclice","puke","puntang","purinaprincess","pussee","pussie","pussyeater","pussyfucker","pussylicker","pussylips","pussylover","puuke","puuker","queerz","qweers","qweerz","qweir","rag head","rearend","rearentry","recktum","redneck","rentafuck","russki","russkie","sadom","saeema butt","sandm","scank","screwyou","seaman staines","sexed","sexfarm","sexhound","sexhouse","sexing","sexkitten","sexslave","sextogo","sextoy","sextoys","sexwhore","sexymoma","sexy-slim","seymour butts","shat","shhit","shitcan","shiter","shitfit","shitforbrains","shitfucker","shithapens","shithappens","shitlist","shitola","shitoutofluck","shity","shitz","shortfuck","shyt","shyte","shytty","shyty","sixsixsix","sixtynine","sixtyniner","skanck","skankbitch","skankee","skankey","skankfuck","skanks","skankwhore","skanky","skankybitch","skankywhore","skinflute","skum","skumbag","slantyeye","slapper","slavedriver","sleezebag","sleezeball","slideitin","slimeball","slimebucket","slopehead","slopey","slopy","slutt","slutting","slutty","slutwear","slutwhore","slutz","smackthemonkey","smelly","snatchpatch","snot","snowback","snownigger","sodomise","sonofabitch","sonofbitch","spacca","spaghettibender","spaghettinigger","spankthemonkey","spazza","spermacide","spermbag","spermhearder","spermherder","spig","spigotty","spitter","splittail","spreadeagle","squaw","stabber","stripclub","stroking","stupidfuck","stupidfucker","suckdick","sucker","suckme","suckmyass","suckmytit","suckoff","tarbaby","testicles","thicklips","thicko","thirdeye","thirdleg","timbernigger","titbitnipply","titfucker","titfuckin","titjob","titlicker","titlover","tittie","tonguethrust","tonguethruster","tonguetramp","torture","tosspot","trailertrash","trannie","trots","trouser snake","tuckahoe","tunneloflove","twobitwhore","unfuckable","uptheass","upthebutt","urinate","usama bin laden","vaginal","vajina","valjina","vibrater","vietcong","violate","violation","virginbreaker","vullva","waysted","welcher","wetspot","whacker","whigger","whiskeydick","whiskydick","whitenigger","whitetrash","whoor","whop","whorefucker","wife beater","williewanker","wuss","wuzzie","yellowman","zigabo","zipperhea","zipper head","suicide","kill yourself","kys","hang yourself","unalive yourself","nigg","puta","amcik","boobz","boody","boong","cazzo","forni","fotze","ginzo","gippo","gipps","godam","goyim","groid","gubba","guizi","gyopo","gyped","harem","heebs","horis","hoser","hymie","japie","jewed","jigga","jiggs","jiggy","jizin","jizzd","jizzn","kacap","kumer","kurac","kurwa","kushi","kykes","kyopo","kyrpa","lebos","lubra","lugan","lynch","mibun","mocky","nibba","nigar","nigas","niger","nigha","nigor","niqqa","nudie","nymph","pansy","paska","pendy","pizda","pocha","pocho","pohms","quiff","seppo","smack","spank","spics","stagg","trois","ukrop","vittu","wigga","beaney","boches","bungas","chinga","crotch","darkey","doggie","dyefly","dziwka","exkwew","fetish","ficken","geezer","gummer","gwailo","gweilo","gypped","gypsys","hodgie","honkie","huevon","humper","humpin","ikeymo","jewess","jigger","jizzin","kaffer","kaffre","kanake","kanker","katsap","kigger","knulle","kwailo","mabuno","macaca","maumau","menage","mierda","mockey","mockie","moskal","moslem","mtrfck","mulkku","muschi","mzungu","necked","negres","noonan","nooner","orospu","piefke","pimmel","pimped","pooper","pudboy","punani","pusies","qahbeh","racial","redleg","rigger","sambos","shipal","skribz","slanty","sloper","slopes","tantra","tiedup","tittis","tortur","trojan","turnon","yarpie","arabush","asholes","ballgag","bangbro","bluegum","bootlip","buffies","coolies","coonass","cowgirl","dothead","dryhump","fanculo","flikker","gangsta","genital","googirl","horndog","hotcarl","hugefat","humpher","humphim","hustler","israels","jerries","jimfish","khokhol","lezzian","licking","mahbuno","mamhoon","maricon","mideast","mulatto","nigette","pendejo","pierdol","preteen","puddboy","quashie","sanchez","scheiss","schmuck","septics","sheeney","shinola","shylock","slopeys","spludge","squinty","triplex","urethra","vagiina","whities","wichser","africoon","andskota","bassterd","bigblack","blackman","burrhead","chinaman","chinamen","clansman","clansmen","dogstyle","dunecoon","earotics","eatmyass","footstar","foursome","godsdamn","golliwog","homicide","horndawg","hotchick","illegals","klansman","klansmen","klootzak","knockers","kuksuger","lingerie","mosshead","peepshow","peepshpw","poontsee","pplicker","schaffer","schlampe","sharmuta","sharmute","stringer","syphilis","tacohead","thicklip","threeway","wetdream","yourtits","zabourah","arschloch","assrammer","babyjuice","ballgravy","futkretzn","girlontop","hairyback","halfbreed","halfcaste","hillbilly","howtokill","jigarooni","magicwand","marijuana","masturbat","monkleigh","mouliewop","penthouse","poundtown","premature","scallywag","schvartse","schwartze","skurwysyn","sphencter","squirting","stuinties","swallower","tarbabies","tongueina","babybatter","beastility","beaverlips","bigbreasts","bluewaffle","buddhahead","bulletvibe","chinaswede","chingchong","clanswoman","clanswomen","deepaction","doubledong","ejackulate","jellydonut","klanswoman","klanswomen","makemecome","mickeyfinn","missionary","rautenberg","samckdaddy","shawtypimp","socksucker","spierdalaj","spreadlegs","squarehead","styledoggy","tightwhite","udgepacker","venusmound","whitepower","zipperhead","ballkicking","dawgiestyle","diaperdaddy","donkeypunch","howtomurder","meatbeatter","pancakeface","pommiegrant","swampguinea","taintedlove","beefcurtains","blowyourload","brownshowers","christkiller","cloverclamps","currymuncher","dirtypillows","motherfvcker","moundofvenus","pickaninnies","porchmonkies","spearchucker","tigolbitties","transvestite","beavercleaver","girlsgonewild","jacktheripper","junglebunnies","masterblaster","pleasurechest","tigoldbitties","tongethruster","yellowshowers","brunetteaction","femalesquirtin","luckycammeltoe","purinapricness","clevelandsteamer","wrinkledstarfish","princealbertpiercing","niggardliness's","niggard's","nigger's","nicotine","hell","f*ck","f**k","f***k","fu*k","fu**k","fk","fuq","sh*t","damm","d@mn","d@mm","h3ll","h*ll","b*tch","btch","bast4rd","b@stard","bast@rd","@ss","a$$","@$$","cr@p","d!ck","p1ss","p!ss","p@ss","c*nt","c**t","wh*re","wh0r3","slvt","sl*t","sl*tt","d*uche","d*uch3","@sshole","@$$hole","m0therfucker","m0therf*cker","m0th3rfucker","motherf*cker","c*cksucker","c*cksuck3r","cocksuck3r","j@ckass","j@ck@ss","jack@ss","j@ck*ss","b*llshit","b@llshit","bllsht","b*llsh1t","bullsh1t","b@llsh1t","@rsehole","ars3hole","ars*hole","f*ggot","f@gg0t","b@st4rd","sh!thead","sh1thead","sh1th3ad","shith3ad","sh*thead","c*ck","c0k","p*rn","pr0n","porn0","fckr","f*ckr","fc*k","fc*kr","fkn","fn","fqn","fnck","d1k","d!k","dik","dyk","dykk","d*kk","c*m","c*mm","s!ut","p1mp","p!mp","b00b","b*ob","b0b","b00bz","b0bz","b0obs","@ssh0le","@$$h0le","f!ck","f1ck","f*q","f*cking","f**king","f***king","fkng","f*kin","f@king","buggr","buggrr","bugg3r","buggering","f@ggot","f*gg0t","twatface","twatfaced","wankr","w4nk","w4nker","w@nkr","w*nkr","wankd","tossr","toss3r","t0ss3r","t!t","titz","t!tt","t!tz","c_nt","c*ntz","c_ntz","pisd","pissd","pishead","p!sshead","p1sshead","f*cker","f_ckr","f@ckr","fcukr","f_ck3r","f*cked","fc*ked","f_ckd","f_cked","f_cking","fc*king","f_ckn","f_ckng","f@cking","motherfckr","mthrfcukr","mthrfcuker","mothrf*cker","mthrf*cker","d!ckhead","d!ckhed","d!ckh3ad","d1ckh3ad","dickh3ad","d!ckhd","d*ckhead","dickhed","dikhead","dickhd","ballz","ballzy","ballsy","ballsz","b@llz","b@lls","b*llz","b*lls","b00bies","boobi","boobied","co*k","co**k","pr!k","prickr","pr1kr","pr!kr","pr!cker","w0gg","w0gger","wogger","w*gg","w0gg3r","wogging","f4git","f@git","fag0t","f@got","fagott","f4gott","faggets","faggy","fagzz","pissr","p!ssr","piss3r","p1ss3r","p1ssr","p!ssed","p1ssed","p1ssd","tw*t","fuc","fucc","fkk","f*k","d*mn","dammn","d@mmn","sl*tty","slttty","sltttty","sluttz","slttz","sltttz","bitchz","biotch","bitchr","b*tchr","b1tchr","n!gger","nigg*r","nigg@r","n!gg3r","n1gg3r","n1gg@r","n!gg@r","n1gg*r","n!gg*r","n1g","n!gg","n1gg","n*gg","niggr","n!ggr","n1ggr","n*gger","n!gga","n!gg@","n1gg@","nigg@","n1ggah","n!ggah","n*ggah","nigg@h","n!gg@h","n1gg@h","n1g@h","n!g@h","nigguh","n1gguh","n!gguh","n*gguh","n1ggaz","n!ggaz","n*ggaz","nigg@s","n!gg@s","n1gg@s","n1gg@z","nigg@z","n!gg@z","n*gg@z","niggahz","n1ggahz","n!ggahz","n*ggahz","nigg@hz","n!gg@hz","n1gg@hz","niggar","n1ggar","n!ggar","n*ggar","nigg@rs","n1gg@rs","n!gg@rs","n!g@rs","n!g@r","n!g@rz","niggrz","n1ggrz","n!ggrz","n!gg@rz","nigg@rz","niggrs","n1ggrs","n!ggrs","shiit","cr4p","c@cksucker","c0cksuck3r","c0ck$ucker","c*cksucka","c@cksucka","c0cksuck@h","loser","l0ser","looser","l00ser","l0s3r","l*ser","l*s3r","l@s3r","l@ser","l0$er","l0$3r","l0ozer","lozer","l0z3r","l*zer","l*z3r","lo$er","l0zer","loz3r","loos3r","l0oser","l00z3r","looz3r","looz*r","l0o$er","l0os3r","l*ozer"]`), oa = document.createElement("canvas"); function qi(u, e) { return new URLSearchParams(e || window.location.search).get(u) || "" } const Y = { getParameterByName: qi, getCookie: function(u) { const e = `${u}=`, i = decodeURIComponent(document.cookie).split(";"); for (let r = 0; r < i.length; r++) { let a = i[r]; for (; a.charAt(0) == " ";) a = a.substring(1); if (a.indexOf(e) == 0) return a.substring(e.length, a.length) } return "" }, sanitizeNameInput: function(u) { let e = u.trim(); e.length > Qe.PlayerNameMaxLen && (e = e.substring(0, Qe.PlayerNameMaxLen)); const t = ` ${e.toLowerCase()} `; return sa.some(i => t.includes(` ${i} `)) && (e = "nigga"), e }, colorToHexString: function(u) { return `#${`000000${u.toString(16)}`.slice(-6)}` }, colorToDOMString: function(u, e) { return `rgba(${u>>16&255}, ${u>>8&255}, ${u&255}, ${e})` }, htmlEscape: function(u = "") { return u.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") }, truncateString: function(u, e, t) { const i = oa.getContext("2d"); i.font = e; let r = u; for (let a = u.length; a > 0 && i.measureText(r).width > t;) r = `${u.substring(0,--a)}â€¦`; return r }, toggleFullScreen: function(u) { var t, i; let e = document.documentElement; document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || u ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : (t = document.webkitExitFullscreen) == null || t.call(document) : e.requestFullscreen ? e.requestFullscreen() : e.msRequestFullscreen ? (e = document.body, e.msRequestFullscreen()) : e.mozRequestFullScreen ? e.mozRequestFullScreen() : (i = e.webkitRequestFullscreen) == null || i.call(e) }, copyTextToClipboard: function(u) { try { const e = c("<input>"); if (c("body").append(e), e.val(u), P.os == "ios") { const t = e.get(0), i = t.contentEditable, r = t.readOnly; t.contentEditable = "true", t.readOnly = !0; const a = document.createRange(); a.selectNodeContents(t); const m = window.getSelection(); m.removeAllRanges(), m.addRange(a), t.setSelectionRange(0, 999999), t.contentEditable = i, t.readOnly = r } else e.select(); document.execCommand("copy"), e.remove() } catch {} }, getSvgFromGameType: function(u) { var i, r; const e = F[u]; switch (e ? e.type : "") { case "gun": case "melee": case "throwable": case "heal": case "boost": case "helmet": case "chest": case "scope": case "backpack": case "perk": case "xp": return `img/loot/${(i=e.lootImg)==null?void 0:i.sprite.slice(0,-4)}.svg`; case "heal_effect": case "boost_effect": return `img/particles/${(r=e.texture)==null?void 0:r.slice(0,-4)}.svg`; case "emote": return `img/emotes/${e.texture.slice(0,-4)}.svg`; case "crosshair": return `img/crosshairs/${e.texture.slice(0,-4)}.svg`; case "outfit": { const a = e.lootImg; if (a.sprite !== "loot-shirt-01.img") return `img/loot/${a.sprite.slice(0,-4)}.svg`; const m = `<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><path d="M63.993 8.15c-10.38 0-22.796 3.526-30.355 7.22-8.038 3.266-14.581 7.287-19.253 14.509C8.102 39.594 5.051 54.6 7.13 78.482c5.964 2.07 11.333 1.45 16.842-.415-1.727-7.884-1.448-15.764.496-22.204 2.126-7.044 6.404-12.722 12.675-13.701l2.77-.432.074 2.803c.054 2.043.09 4.17.116 6.335l.027 6.312c-.037 8.798-.382 18.286-1.277 27.845 5.637 1.831 14.806 2.954 23.964 3.019l4.597-.058c8.53-.275 16.742-1.449 21.665-3.063-1.093-14.65-1.166-29.434-1.52-41.334l-.097-3.283 3.18.824c6.238 1.617 10.55 7.376 12.76 14.507 2.02 6.51 2.353 14.37.64 22.248a29.764 29.764 0 0 0 12.847 1.181l4.399-.588c1.033-18.811-1.433-37.403-6.27-46.264l-4.408-6.376c-4.647-5.357-10.62-8.399-17.665-11.074-6.746-3.458-18.358-6.614-28.95-6.614zm0 3.05c6.494 0 13.37 1.942 19.274 4.516-3.123 2.758-6.971 4.665-11.067 5.754l-7.852 17.31-6.838-16.882c-4.757-.93-9.26-2.957-12.783-6.174C50.9 13.081 57.809 11.2 63.993 11.2zm.58 28.539l3.512 5.327-3.497 5.053-3.53-5.053zm0 11.888l3.512 5.328-3.497 5.052-3.53-5.053 3.514-5.327zm0 11.733l3.512 5.327-3.497 5.054-3.53-5.054zm0 11.876l3.512 5.327-3.497 5.054-3.53-5.053 3.514-5.327zm25.079 13.715c-6.61 2.055-15.829 2.907-25.277 2.951-9.5.045-18.965-.744-25.902-2.892-.205 1.785-.43 3.569-.678 5.347 5.968 2.132 16.346 3.408 26.497 3.36 10.143-.05 20.355-1.444 25.912-3.433a241.302 241.302 0 0 1-.552-5.333zm1.368 9.086c-6.782 2.308-16.533 3.262-26.53 3.31-2.935.015-5.866-.052-8.724-.213l-4.227-.315c-5.358-.5-10.307-1.382-14.329-2.758-.897 5.43-2.02 10.772-3.413 15.903 2.117 1.06 4.41 1.968 6.835 2.733l3.97 1.096c15.85 3.805 35.88 2.156 49.601-3.513-1.355-5.09-2.387-10.57-3.183-16.243z" fill="${this.colorToHexString(a.tint)}"/></svg>`; return URL.createObjectURL(new Blob([m], { type: "image/svg+xml;charset=utf-8" })) } default: return "" } }, getCssTransformFromGameType: function(u) { const e = F[u]; let t = ""; return e != null && e.lootImg && (t = `rotate(${e.lootImg.rot||0}rad) scaleX(${e.lootImg.mirror?-1:1})`), t }, random64: function() { function u() { return Math.floor(Math.random() * Math.pow(2, 32)).toString(16) } return u() + u() } }; function la() { return Ee.android.device || Ee.apple.device || Vi() } function Vi() { const u = navigator.userAgent.toLowerCase(); return u.includes("ipad") || u.includes("macintosh") && "ontouchend" in document } function Wi() { return Ee.apple.phone || Ee.apple.ipod } function ma() { return Ee.android.device } function na() { const u = window.navigator.userAgent, e = u.indexOf("MSIE "), t = u.indexOf("Trident/"); return e > 0 || t > 0 } function ha() { return window.navigator.userAgent.indexOf("Edge/") > 0 } function ca() { return Wi() && (screen.width == 375 && screen.height == 812 || screen.height == 375 && screen.width == 812 || screen.width == 414 && screen.height == 896 || screen.height == 414 && screen.width == 896) } function ua() { return Wi() ? "ios" : ma() ? "android" : "pc" } function da() { return na() ? "ie" : ha() ? "edge" : "unknown" } function pa(u, e) { try { localStorage.setItem(u, e) } catch {} } function fa(u) { let e = null; try { e = localStorage.getItem(u) } catch {} return e } class wa { constructor() { s(this, "os"); s(this, "browser"); s(this, "model"); s(this, "pixelRatio", window.devicePixelRatio); s(this, "version"); s(this, "mobile"); s(this, "tablet"); s(this, "touch"); s(this, "uiLayout"); s(this, "debug", !1); s(this, "UiLayout", { Lg: 0, Sm: 1 }); s(this, "isLandscape", !0); s(this, "screenWidth", 0); s(this, "screenHeight", 0); this.os = ua(), this.browser = da(), this.model = ca() ? "iphonex" : "unknown"; const e = qi("version"); e && pa("surviv_version", e), this.version = fa("surviv_version") || "1.0.0", this.mobile = la(), this.tablet = Ee.tablet || Vi(), this.touch = this.mobile || this.tablet, this.uiLayout = this.mobile ? this.UiLayout.Sm : this.UiLayout.Lg, this.onResize() } onResize() { this.isLandscape = window.innerWidth > window.innerHeight || window.orientation == 90 || window.orientation == -90, this.screenWidth = window.innerWidth, this.screenHeight = window.innerHeight; const e = this.isLandscape ? this.screenWidth : this.screenHeight; this.uiLayout = this.mobile || e <= 850 || e <= 900 && this.pixelRatio >= 3 ? this.UiLayout.Sm : this.UiLayout.Lg } } const P = new wa; class Ui { constructor() { s(this, "pos", h.create(0, 0)); s(this, "ppu", 16); s(this, "zoom", 1.5); s(this, "targetZoom", 1.5); s(this, "screenWidth", 1); s(this, "screenHeight", 1); s(this, "shakeEnabled", !0); s(this, "shakeInt", 0) } z() { return this.ppu * this.zoom } pointToScreen(e) { return { x: this.screenWidth * .5 + (e.x - this.pos.x) * this.z(), y: this.screenHeight * .5 - (e.y - this.pos.y) * this.z() } } screenToPoint(e) { return { x: this.pos.x + (e.x - this.screenWidth * .5) / this.z(), y: this.pos.y + (this.screenHeight * .5 - e.y) / this.z() } } pixels(e) { return e * this.zoom } scaleToScreen(e) { return e * this.z() } setShakeEnabled(e) { this.shakeEnabled = e } addShake(e, t) { const i = h.length(h.sub(this.pos, e)), r = _.delerp(i, 40, 10) * t; this.shakeInt = Math.max(this.shakeInt, r) } applyShake() { this.shakeEnabled && (this.pos = h.add(this.pos, h.mul(h.randomUnit(), this.shakeInt))), this.shakeInt = 0 } } class ga { constructor() { s(this, "shapes", []) } addLine(e, t, i, r) { this.shapes.push({ type: 0, start: h.copy(e), end: h.copy(t), color: i, fill: r }) } addRay(e, t, i, r, a) { this.shapes.push({ type: 1, pos: h.copy(e), dir: h.copy(t), len: i, color: r, fill: a }) } addCircle(e, t, i, r) { this.shapes.push({ type: 2, pos: h.copy(e), rad: t, color: i, fill: r }) } addAabb(e, t, i, r) { this.shapes.push({ type: 3, min: h.copy(e), max: h.copy(t), color: i, fill: r }) } addCollider(e, t, i) { e.type == U.Type.Aabb ? this.addAabb(e.min, e.max, t, i) : this.addCircle(e.pos, e.rad, t, i) } render(e, t) {} flush() { this.shapes = [] } } const de = new ga, ri = 4, ai = 5; function si(u) { return u.displayCloseIcon ? "img/gui/close.svg" : Y.getSvgFromGameType(u.ping || u.emote) } function Ue(u) { let e = Math.atan2(u.y, u.x) * 180 / Math.PI; return e < 0 && (e += 360), e } function Sa(u, e, t) { return e <= t ? t - e <= 180 ? e <= u && u <= t : t <= u || u <= e : e - t <= 180 ? t <= u && u <= e : e <= u || u <= t } class ya { constructor(e, t, i, r, a) { s(this, "gameElem", c("#ui-game")); s(this, "disable", !1); s(this, "activePlayer", null); s(this, "worldPos", h.create(0, 0)); s(this, "zIdxNext", 0); s(this, "emoteSelector", { ping: "", emote: "" }); s(this, "emoteSoftTicker", 0); s(this, "emoteHardTicker", 0); s(this, "emoteCounter", 0); s(this, "emoteWheelsGreyed", !1); s(this, "teamEmotesGreyed", !1); s(this, "wheelKeyTriggered", !1); s(this, "emoteTimeoutTicker", 0); s(this, "pingKeyTriggered", !1); s(this, "pingKeyDown", !1); s(this, "pingMouseTriggered", !1); s(this, "wheelDisplayed", !1); s(this, "emoteMouseTriggered", !1); s(this, "emoteScreenPos", h.create(0, 0)); s(this, "triggerPing"); s(this, "triggerEmote"); s(this, "emoteTouchedPos", null); s(this, "bigmapPingPos", null); s(this, "onTouchStart"); s(this, "emoteElems", c(".ui-emote")); s(this, "bigmapCollision", c("#big-map-collision")); s(this, "emoteButtonElem", c("#ui-emote-button")); s(this, "emoteWheels", c("#ui-emotes, #ui-team-pings")); s(this, "teamEmotes", c(".ui-emote-bottom-left, .ui-emote-top-left")); s(this, "emoteWheel", c("#ui-emotes")); s(this, "emoteWheelData"); s(this, "teamPingWheel", c("#ui-team-pings")); s(this, "teamPingSelectors", []); s(this, "displayedSelectors"); s(this, "baseScale", 1); s(this, "container", new ie); s(this, "pingContainer", new ie); s(this, "indContainer", new ie); s(this, "pingIndicators", []); s(this, "airdropIndicator"); s(this, "airstrikeIndicator"); s(this, "emoteLifeIn", .75); s(this, "emoteLife", 1); s(this, "emoteLifeOut", .1); s(this, "pingFadeIn", .5); s(this, "pingLife", 4.25); s(this, "pingFadeOut", .1); s(this, "wedgeOpacityReset", P.touch ? 1 : .75); s(this, "teamEmoteOpacityReset", .2); s(this, "emotes", []); s(this, "newPings", []); s(this, "newEmotes", []); s(this, "emoteLoadout", []); s(this, "unlockTypes", {}); s(this, "socialUnlocked", !1); s(this, "emoteWheelSelectors"); s(this, "parentDisplayed"); this.audioManager = e, this.uiManager = t, this.playerBarn = i, this.camera = r, this.map = a, this.triggerPing = () => { if (this.activePlayer) { let n; if (this.emoteSelector.ping && !this.emoteWheelsGreyed) { const p = $e[this.emoteSelector.ping]; p != null && p.pingMap && (n = this.uiManager.getWorldPosFromMapPos(this.bigmapPingPos || this.emoteScreenPos, this.map, this.camera), n || (n = this.camera.screenToPoint(this.emoteScreenPos)), n.x = _.clamp(n.x, 0, this.map.width), n.y = _.clamp(n.y, 0, this.map.height), this.sendPing({ type: this.emoteSelector.ping, pos: n })) } else this.emoteSelector.emote && !this.emoteWheelsGreyed && (n = this.activePlayer.pos, this.sendEmote({ type: this.emoteSelector.emote, pos: n }), this.uiManager.displayMapLarge(!0)); this.inputReset(), this.pingKeyTriggered = this.pingKeyDown } }, this.triggerEmote = () => { if (this.activePlayer) { let n; this.emoteSelector.emote && !this.emoteWheelsGreyed && (n = this.activePlayer.pos, this.sendEmote({ type: this.emoteSelector.emote, pos: n })), this.inputReset() } }, this.onTouchStart = n => { this.wheelDisplayed && (n.stopPropagation(), this.inputReset()) }, P.touch && (this.emoteElems.css("pointer-events", "auto"), this.bigmapCollision.on("touchend", n => { var p, d; n.stopPropagation(), this.bigmapPingPos = { x: (p = n.originalEvent) == null ? void 0 : p.changedTouches[0].pageX, y: (d = n.originalEvent) == null ? void 0 : d.changedTouches[0].pageY }, this.emoteScreenPos = h.create(this.camera.screenWidth / 2, this.camera.screenHeight / 2), this.pingMouseTriggered = !0 }), this.emoteButtonElem.css("pointer-events", "auto"), this.emoteButtonElem.on("touchstart", n => { n.stopPropagation(), this.emoteScreenPos = h.create(this.camera.screenWidth / 2, this.camera.screenHeight / 2), this.emoteMouseTriggered = !0 }), this.emoteElems.on("touchstart", n => { var p, d; n.stopPropagation(), this.emoteTouchedPos = { x: (p = n.originalEvent) == null ? void 0 : p.changedTouches[0].pageX, y: (d = n.originalEvent) == null ? void 0 : d.changedTouches[0].pageY } }), c(document).on("touchstart", this.onTouchStart)), this.emoteWheelData = { middle: { parent: c("#ui-emote-middle"), vA: h.create(-1, 1), vC: h.create(1, 1), ping: "", emote: "", displayCloseIcon: !0 }, top: { parent: c("#ui-emote-top"), vA: h.create(-1, 1), vC: h.create(1, 1), ping: "", emote: "", emoteSlot: fe.Top }, right: { parent: c("#ui-emote-right"), vA: h.create(1, 1), vC: h.create(1, -1), ping: "", emote: "", emoteSlot: fe.Right }, bottom: { parent: c("#ui-emote-bottom"), vA: h.create(1, -1), vC: h.create(-1, -1), ping: "", emote: "", emoteSlot: fe.Bottom }, left: { parent: c("#ui-emote-left"), vA: h.create(-1, -1), vC: h.create(-1, 1), ping: "", emote: "", emoteSlot: fe.Left } }; const m = { middle: { parent: c("#ui-team-ping-middle"), vA: h.create(-1, 1), vC: h.create(1, 1), ping: "", emote: "", displayCloseIcon: !0 }, top: { parent: c("#ui-team-ping-top"), vA: h.create(-1, 1), vC: h.create(1, 1), ping: "ping_danger", emote: "" }, right: { parent: c("#ui-team-ping-right"), vA: h.create(1, 1), vC: h.create(1, -1), ping: "ping_coming", emote: "" }, bottom: { parent: c("#ui-team-ping-bottom"), vA: h.create(1, -1), vC: h.create(-1, -1), ping: "ping_help", emote: "" }, "bottom-left": { parent: c("#ui-team-ping-bottom-left"), vA: h.create(-1, -1), vC: h.create(-1, 0), ping: "", emote: "emote_medical" }, "top-left": { parent: c("#ui-team-ping-top-left"), vA: h.create(-1, 0), vC: h.create(-1, 1), ping: "", emote: "emote_ammo", ammoEmote: !0 } }; for (const n in m) if (m.hasOwnProperty(n)) { const p = m[n], d = Ue(p.vA), f = Ue(p.vC); this.teamPingSelectors.push({ parent: p.parent, angleA: d, angleC: f, highlight: p.parent.find(".ui-emote-hl"), highlightDisplayed: !1, ping: p.ping, emote: p.emote, ammoEmote: p == null ? void 0 : p.ammoEmote, displayCloseIcon: p == null ? void 0 : p.displayCloseIcon }) } this.displayedSelectors = this.teamPingSelectors, this.container.scale.set(this.baseScale, this.baseScale), this.container.addChild(this.pingContainer); const o = function(n, p = 16777215) { const d = new ie, f = new ie, w = N.groupColors[n] || p, g = re.from("ping-border.img"); g.scale.set(.4, .4), g.anchor.set(.5, .5), g.tint = w, g.alpha = 0, g.visible = !0, d.addChild(g); const x = re.from("ping-team-danger.img"); x.scale.set(.4, .4), x.anchor.set(.5, .5), x.tint = w, x.alpha = 0, x.visible = !0, d.addChild(x); const S = re.from("ping-team-danger.img"); S.scale.set(.5, .5), S.anchor.set(.5, .5), S.tint = w, S.alpha = 0, S.visible = !0, f.addChild(S); const z = re.from("ping-indicator.img"); return z.scale.set(.5, .5), z.anchor.set(.5, 0), z.alpha = 0, z.visible = !0, f.addChild(z), { elem: c("#ui-team-indicators").find(`.ui-indicator-ping[data-id=${n}]`), borderElem: c("#ui-team-indicators").find(`.ui-indicator-ping-border[data-id=${n}]`), pingContainer: d, indContainer: f, borderSprite: { sprite: g, baseScale: .4 }, pingSprite: { sprite: x, baseScale: .4 }, indSpriteOuter: { sprite: z, baseScale: .5, baseTint: Number(z.tint) }, indSpriteInner: { sprite: S, baseScale: .5, baseTint: Number(S.tint) }, displayed: !1, fadeIn: 0, life: 0, fadeOut: 0, pos: h.create(0, 0) } }; for (let n = 0; n < 4; n++) { const p = o(n); this.pingContainer.addChild(p.pingContainer), this.indContainer.addChild(p.indContainer), this.pingIndicators.push({ ping: p }) } this.airdropIndicator = o(ri, $e.ping_airdrop.tint), this.pingContainer.addChild(this.airdropIndicator.pingContainer), this.indContainer.addChild(this.airdropIndicator.indContainer), this.pingIndicators.push({ ping: this.airdropIndicator }), this.airstrikeIndicator = o(ai, $e.ping_airstrike.tint), this.pingContainer.addChild(this.airstrikeIndicator.pingContainer), this.indContainer.addChild(this.airstrikeIndicator.indContainer), this.pingIndicators.push({ ping: this.airstrikeIndicator }) } free() { P.touch && (c(document).off("touchstart", this.onTouchStart), this.emoteButtonElem.off("touchstart"), this.emoteElems.off("touchstart"), this.bigmapCollision.off("touchend")), this.init() } init() { this.emoteWheelsGreyed = !1, this.emoteWheels.css("opacity", 1), this.teamEmotesGreyed = !1, this.teamEmotes.css("opacity", 1), this.disable = !1, this.inputReset() } inputReset() { this.pingMouseTriggered = !1, this.pingKeyTriggered = !1, this.emoteMouseTriggered = !1, this.wheelDisplayed = !1, this.displayWheel(this.teamPingWheel, !1), this.displayWheel(this.emoteWheel, !1), this.emoteTouchedPos = null, this.bigmapPingPos = null, this.emoteTimeoutTicker = 0; for (let e = 0; e < this.displayedSelectors.length; e++) { const t = this.displayedSelectors[e], i = qe[t.emote], r = i == null ? void 0 : i.teamOnly; this.teamEmotesGreyed && r ? t.parent.css("opacity", this.teamEmoteOpacityReset) : t.parent.css("opacity", this.wedgeOpacityReset), t.highlight.css("display", "none"), t.highlightDisplayed = !1 } } sendPing(e) { this.newPings.push({ type: e.type, pos: e.pos }), this.incrementEmote() } addPing(e, t) { if (this.activePlayer) { const i = $e[e.type]; if (i) { this.uiManager.createPing(e.type, e.pos, e.playerId, this.activePlayer.__id, this.playerBarn, t); let r = null, a = i.sound; if (e.type == "ping_airdrop") r = this.pingIndicators[ri].ping; else if (e.type == "ping_airstrike") r = this.pingIndicators[ai].ping; else { const m = this.playerBarn.getPlayerInfo(e.playerId); if (m) { const n = this.playerBarn.getPlayerInfo(this.activePlayer.__id).groupId, p = m.groupId; if (n == p) { const f = this.playerBarn.getGroupInfo(p).playerIds.indexOf(e.playerId); f !== -1 && (r = this.pingIndicators[f].ping) } } const o = this.playerBarn.getPlayerStatus(e.playerId); o && o.role == "leader" && (a = i.soundLeader) } t || e.type != "ping_airstrike" ? this.audioManager.playSound(a, { channel: "ui" }) : this.audioManager.playSound(a, { channel: "ui", fallOff: 1, soundPos: e.pos, rangeMult: 20 }), r && (r.pos = e.pos, r.pingSprite.sprite.texture = X.from(i.texture), r.indSpriteInner.sprite.texture = X.from(i.texture), r.indSpriteInner.sprite.tint = i.mapEvent ? i.tint : r.indSpriteInner.baseTint, r.indSpriteOuter.sprite.tint = i.mapEvent ? i.tint : r.indSpriteOuter.baseTint, r.fadeIn = this.pingFadeIn, r.life = this.pingLife, r.fadeOut = this.pingFadeOut, r.mapEvent = i.mapEvent, r.worldDisplay = i.worldDisplay) } } } sendEmote(e) { this.newEmotes.push({ type: e.type, pos: e.pos }), this.incrementEmote() } addEmote(e) { var i; const t = qe[e.type]; if (t) { let r = null; for (let a = 0; a < this.emotes.length; a++) this.emotes[a].alive || r ? this.emotes[a].alive && this.emotes[a].playerId == e.playerId && (this.emotes[a].alive = !1) : r = this.emotes[a]; if (r || (r = {}, r.alive = !1, r.pos = h.create(0, 0), r.container = new ie, r.circleOuter = re.from("emote-circle-outer.img"), r.circleOuter.anchor.set(.5, .5), r.baseScale = .55, r.circleOuter.scale.set(r.baseScale * .8, r.baseScale * .8), r.circleOuter.tint = 0, r.circleOuter.visible = !0, r.container.addChild(r.circleOuter), r.sprite = new re, r.sprite.anchor.set(.5, .5), r.container.addChild(r.sprite), r.sprite.scale.set(r.baseScale, r.baseScale), r.posOffset = h.create(0, 4), r.container.scale.set(1, 1), r.container.visible = !1, this.emotes.push(r)), r.alive = !0, r.isNew = !0, r.type = e.type, r.playerId = e.playerId, r.pos = h.create(0, 0), r.lifeIn = this.emoteLifeIn, r.life = this.emoteLife, r.lifeOut = this.emoteLifeOut, r.zIdx = this.zIdxNext++, t.texture && (r.sprite.texture = X.from(t.texture)), r.container.visible = !1, r.baseScale = .55, r.sound = t.sound, r.channel = t.channel, e.type == "emote_loot") { const a = F[e.itemType]; if (a != null && a.lootImg) { r.sprite.texture = X.from(a.lootImg.sprite); const m = F[a.ammo]; r.circleOuter.tint = m ? m.lootImg.tintDark : 0, a.lootImg.rot ? r.sprite.rotation = a.lootImg.rot : r.sprite.rotation = 0, a.lootImg.mirror ? r.sprite.scale.set(r.baseScale * -1, r.baseScale) : r.sprite.scale.set(r.baseScale, r.baseScale), (i = a.sound) != null && i.deploy && (a.type == "gun" ? (r.sound = a.sound.deploy, r.channel = "activePlayer") : r.sound = "") } } else r.circleOuter.tint = 0, r.sprite.rotation = 0, r.sprite.scale.set(r.baseScale, r.baseScale) } } incrementEmote() { this.emoteCounter++, this.emoteCounter >= N.player.emoteThreshold && (this.emoteHardTicker = this.emoteHardTicker > 0 ? this.emoteHardTicker : N.player.emoteHardCooldown * 1.5) } update(e, t, i, r, a, m, o, n, p, d) { const f = this.playerBarn, w = this.camera; let g = h.create(n.mousePos.x, n.mousePos.y); n.lostFocus && this.inputReset(), p.isBindPressed(E.TeamPingMenu) && !this.pingKeyDown && !d && (this.pingKeyDown = !0, this.pingKeyTriggered = !0), p.isBindReleased(E.TeamPingMenu) && this.pingKeyDown && (this.pingKeyDown = !1, this.pingKeyTriggered = this.wheelDisplayed), p.isBindPressed(E.TeamPingSingle) && !this.pingMouseTriggered && !this.emoteMouseTriggered && (this.emoteScreenPos = h.copy(g), this.pingMouseTriggered = !0), p.isBindReleased(E.TeamPingSingle) && this.pingMouseTriggered && this.triggerPing(), p.isBindPressed(E.EmoteMenu) && (!this.pingMouseTriggered && !this.emoteMouseTriggered && this.pingKeyDown && (this.emoteScreenPos = h.copy(g), this.pingMouseTriggered = !0), this.pingMouseTriggered || (this.emoteScreenPos = h.copy(g), this.emoteMouseTriggered = !0)), p.isBindReleased(E.EmoteMenu) && (this.pingKeyTriggered && this.pingMouseTriggered && this.triggerPing(), this.emoteMouseTriggered && this.triggerEmote()), this.activePlayer = i, (t != i.__id || i.netData.dead) && !this.disable && (this.free(), this.disable = !0); const x = m.perkMode && !i.netData.role; if (!this.disable && !x && (this.wheelKeyTriggered = this.pingKeyTriggered || this.emoteMouseTriggered, this.emoteSoftTicker -= e, this.emoteCounter >= N.player.emoteThreshold && this.emoteHardTicker > 0 ? (this.emoteHardTicker -= e, this.emoteHardTicker < 0 && (this.emoteCounter = 0)) : this.emoteSoftTicker < 0 && this.emoteCounter > 0 && (this.emoteCounter--, this.emoteSoftTicker = N.player.emoteSoftCooldown * 1.5), !this.pingMouseTriggered && !this.emoteMouseTriggered || this.wheelDisplayed || (this.parentDisplayed = this.pingMouseTriggered ? this.teamPingWheel : this.emoteWheel, this.parentDisplayed.css({ display: "block", left: this.emoteScreenPos.x, top: this.emoteScreenPos.y }), this.displayWheel(this.parentDisplayed, !0), this.wheelDisplayed = !0, this.displayedSelectors = this.pingMouseTriggered ? this.teamPingSelectors : this.emoteWheelSelectors, this.worldPos = w.screenToPoint(this.emoteScreenPos)), this.wheelDisplayed)) if (this.emoteTimeoutTicker += e, this.emoteTimeoutTicker > 10) this.inputReset(); else { this.emoteHardTicker > 0 && !this.emoteWheelsGreyed ? (this.emoteWheels.css("opacity", .5), this.emoteWheelsGreyed = !0) : this.emoteHardTicker <= 0 && this.emoteWheelsGreyed && (this.emoteWheels.css("opacity", 1), this.emoteWheelsGreyed = !1), !this.teamEmotesGreyed && r == we.Solo && (this.teamEmotes.css("opacity", this.teamEmoteOpacityReset), this.teamEmotesGreyed = !0); let v = null; if (P.touch && (g = this.emoteTouchedPos), g) { const b = h.sub(g, this.emoteScreenPos); b.y *= -1; const M = h.length(b), A = Ue(b), D = i.localData.weapons[i.localData.curWeapIdx], B = F[D.type]; let T = ""; B != null && B.ammo && (T = B.ammo); for (let C = 0; C < this.displayedSelectors.length; C++) { const R = this.displayedSelectors[C]; if (R.ammoEmote) { const K = { "9mm": "emote_ammo9mm", "12gauge": "emote_ammo12gauge", "762mm": "emote_ammo762mm", "556mm": "emote_ammo556mm", "50AE": "emote_ammo50ae", "308sub": "emote_ammo308sub", flare: "emote_ammoflare", "45acp": "emote_ammo45acp" }, ae = R.emote; if (R.emote = K[T] || "emote_ammo", R.texture = qe[R.emote].texture, ae != R.emote) { const $ = R.parent.find(".ui-emote-image"), j = si(R); $.css("background-image", `url(${j})`) } } const V = R.ping || R.emote, O = qe[R.emote], Z = (O == null ? void 0 : O.teamOnly) && r == we.Solo; M <= 35 && !V && this.emoteHardTicker <= 0 && !Z || Sa(A, R.angleC, R.angleA) && M > 35 && V && this.emoteHardTicker <= 0 && !Z ? v = R : R.highlightDisplayed && (R.parent.css("opacity", this.wedgeOpacityReset), R.highlight.css("display", "none"), R.highlightDisplayed = !1) } } v && (this.emoteSelector = v, v.highlightDisplayed || (v.parent.css("opacity", 1), v.highlight.css("display", "block"), v.highlightDisplayed = !0), P.touch && this.emoteTouchedPos && (this.pingMouseTriggered ? this.triggerPing() : this.triggerEmote())) } for (let v = 0; v < this.emotes.length; v++) { const b = this.emotes[v]; if (b.alive) { let M = !1, A = h.create(0, 0), D = 0; const B = f.getPlayerById(b.playerId); if (B && !B.netData.dead && (A = h.copy(B.pos), D = B.layer, M = !0), !M) { const T = a.getDeadBodyById(b.playerId); T && (A = h.copy(T.pos), D = T.layer, M = !0) } if (M) { b.isNew && this.audioManager.playSound(b.sound, { channel: b.channel, soundPos: A, layer: D }), b.isNew = !1, b.pos = A, b.lifeIn > 0 ? b.lifeIn -= e : b.life > 0 ? b.life -= e : b.lifeOut > 0 && (b.lifeOut -= e); const T = y.sameLayer(D, this.activePlayer.layer) ? 3 : D; o.addPIXIObj(b.container, T, 5e4, b.zIdx), b.alive = b.alive && b.lifeOut > 0 } else b.alive = !1 } } const S = h.create(w.screenWidth * .5 / w.z(), w.screenHeight * .5 / w.z()), z = { min: h.sub(w.pos, S), max: h.add(w.pos, S) }, I = f.getPlayerInfo(i.__id).groupId, k = f.getGroupInfo(I); for (let v = 0; v < this.pingIndicators.length; v++) { const b = this.pingIndicators[v].ping, M = k.playerIds[v], A = b.indContainer, D = b.pingContainer; if (M != null || b.mapEvent) { f.getPlayerInfo(M); const B = M == this.activePlayer.__id, T = f.getPlayerStatus(M), C = b.borderSprite.sprite, R = b.pingSprite.sprite, V = b.indSpriteOuter.sprite, O = b.indSpriteInner.sprite; let W = !0; if (b.fadeIn -= e, b.life -= e, b.fadeOut -= b.life > 0 ? 0 : e, b.fadeOut > 0) { const Z = b.pos, K = h.normalizeSafe(h.sub(Z, w.pos), h.create(1, 0)), ae = ke.intersectRayAabb(w.pos, K, z.min, z.max), $ = Math.atan2(K.y, -K.x) + Math.PI * .5, j = w.pointToScreen(ae), Q = ke.testCircleAabb(Z, N.player.radius, z.min, z.max), he = w.pixels(b.borderSprite.baseScale), ze = w.pixels(b.pingSprite.baseScale); if (C.scale.set(he, he), R.scale.set(ze, ze), T != null && T.dead) continue; const Ce = 64; W = b.fadeOut < 0; const Ot = Q ? w.pointToScreen(Z).x : _.clamp(j.x, Ce, w.screenWidth - Ce), Nt = Q ? w.pointToScreen(Z).y : _.clamp(j.y, Ce, w.screenHeight - Ce), Ft = w.pointToScreen(Z).x, jt = w.pointToScreen(Z).y; R.position.x = Ft, R.position.y = jt, C.position.x = Ft, C.position.y = jt, V.position.x = Ot, V.position.y = Nt, V.rotation = $, O.position.x = Ot, O.position.y = Nt; const ut = C.alpha <= 0 ? 1 : C.alpha - e; C.alpha = ut; const qt = w.pixels(b.borderSprite.baseScale * (2 - ut)); if (C.scale.set(qt, qt), O.alpha = Q ? 0 : ut, b.fadeIn > 0) { const it = 1 - b.fadeIn / this.pingFadeIn; D.alpha = 1, A.alpha = 1, R.alpha = 1, V.alpha = Q ? 0 : it } else V.alpha = Q ? 0 : 1; if (b.life < 0) { const it = b.fadeOut / this.pingFadeOut; D.alpha = it, A.alpha = it } b.displayed || (D.visible = b.worldDisplay, A.visible = !B || b.mapEvent, b.displayed = !0) } W && b.displayed && (D.visible = !1, A.visible = !1, b.displayed = !1) } else D.visible = !1, A.visible = !1, b.displayed = !1 } } displayWheel(e, t) { e.css("display", t ? "block" : "none") } updateEmoteWheel(e) { this.emoteLoadout = e; const t = { top: e[fe.Top], right: e[fe.Right], bottom: e[fe.Bottom], left: e[fe.Left] }; for (const i in t) if (t.hasOwnProperty(i)) { const r = t[i]; qe[r] && this.emoteWheelData[i] && (this.emoteWheelData[i].emote = r) } this.emoteWheelSelectors = []; for (const i in this.emoteWheelData) if (this.emoteWheelData.hasOwnProperty(i)) { const r = this.emoteWheelData[i], a = Ue(r.vA), m = Ue(r.vC); this.emoteWheelSelectors.push(Object.assign({ angleA: a, angleC: m, highlight: r.parent.find(".ui-emote-hl"), highlightDisplayed: !1 }, r)); const o = r.parent.find(".ui-emote-image"), n = si(r); o.css("background-image", `url(${n})`) } } render(e) { for (let t = 0; t < this.emotes.length; t++) { const i = this.emotes[t]; if (i.container.visible = i.alive, i.alive) { let r = 0; if (i.lifeIn > 0) { const n = 1 - i.lifeIn / this.emoteLifeIn; r = _.easeOutElastic(n) } else i.life > 0 ? r = 1 : i.lifeOut > 0 && (r = i.lifeOut / this.emoteLifeOut); const a = h.add(i.pos, h.mul(i.posOffset, 1 / _.clamp(e.zoom, .75, 1))), m = e.pointToScreen(a), o = r * i.baseScale * _.clamp(e.zoom, .9, 1.75); i.container.position.set(m.x, m.y), i.container.scale.set(o, o) } } } } const ft = N.GasMode, Ie = 100 * 1e3, oi = 512; class Gi { constructor(e, t) { s(this, "gasColorDOMString", ""); s(this, "display", null); s(this, "canvas", null); if (this.canvasMode = e, this.gasColor = t, e) this.canvas = document.createElement("canvas"), this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, this.display = new re(X.from(this.canvas)), this.gasColorDOMString = Y.colorToDOMString(t, .6); else { this.display = new Se; const i = this.display; i.clear(), i.beginFill(t, .6), i.moveTo(-Ie, -Ie), i.lineTo(Ie, -Ie), i.lineTo(Ie, Ie), i.lineTo(-Ie, Ie), i.closePath(), i.beginHole(), i.moveTo(0, 1); for (let r = 1; r < oi; r++) { const a = r / oi, m = Math.sin(Math.PI * 2 * a), o = Math.cos(Math.PI * 2 * a); i.lineTo(m, o) } i.endHole(), i.closePath() } this.display.visible = !1 } free() { this.display.destroy(!0) } resize() { this.canvas != null && (this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, this.display.texture.update()) } render(e, t, i) { if (this.canvas != null) { const r = this.canvas, a = r.getContext("2d"); a.clearRect(0, 0, r.width, r.height), a.beginPath(), a.fillStyle = this.gasColorDOMString, a.rect(0, 0, r.width, r.height), a.arc(e.x, e.y, t, 0, Math.PI * 2, !0), a.fill() } else { const r = h.copy(e); let a = t; a < .1 && (a = 1, r.x += Ie * .5); const m = this.display; m.position.set(r.x, r.y), m.scale.set(a, a) } this.display.visible = i } } class xa { constructor() { s(this, "display", new ie); s(this, "circleGfx", new Se); s(this, "lineGfx", new Se); s(this, "safePos", h.create(0, 0)); s(this, "safeRad", 0); s(this, "playerPos", h.create(0, 0)); this.display.addChild(this.circleGfx), this.display.addChild(this.lineGfx), this.circleGfx.visible = !1, this.lineGfx.visible = !1 } render(e, t, i, r, a) { if (this.circleGfx.visible = r, this.lineGfx.visible = a, r || a) { const m = !h.eq(this.safePos, e, 1e-4), o = Math.abs(this.safeRad - t) > 1e-4, n = !h.eq(this.playerPos, i, 1e-4); if (m && (this.safePos.x = e.x, this.safePos.y = e.y), o && (this.safeRad = t), n && (this.playerPos.x = i.x, this.playerPos.y = i.y), m && this.circleGfx.position.set(this.safePos.x, this.safePos.y), o && (this.circleGfx.clear(), this.circleGfx.lineStyle(1.5, 16777215), this.circleGfx.drawCircle(0, 0, t)), m || o || n) { const d = h.length(h.sub(i, e)) < t ? .5 : 1; this.lineGfx.clear(), this.lineGfx.lineStyle(2, 65280, d), this.lineGfx.moveTo(i.x, i.y), this.lineGfx.lineTo(e.x, e.y) } } } } class za { constructor(e) { s(this, "mode", ft.Inactive); s(this, "circleT", 0); s(this, "duration", 0); s(this, "gasRenderer"); s(this, "circleOld"); s(this, "circleNew"); const t = (Math.sqrt(2) + .01) * 1024; this.circleOld = { pos: h.create(0, 0), rad: t }, this.circleNew = { pos: h.create(0, 0), rad: t }, this.gasRenderer = new Gi(e, 16711680) } free() { this.gasRenderer.free() } resize() { this.gasRenderer.resize() } isActive() { return this.mode != ft.Inactive } getCircle() { const e = this.mode == ft.Moving ? this.circleT : 0; return { pos: h.lerp(e, this.circleOld.pos, this.circleNew.pos), rad: _.lerp(e, this.circleOld.rad, this.circleNew.rad) } } setProgress(e) { this.circleT = e } setFullState(e, t, i, r) { if (t.mode != this.mode) { const a = Math.ceil(t.duration * (1 - e)); r.setWaitingForPlayers(!1), r.displayGasAnnouncement(t.mode, a) } this.mode = t.mode, this.duration = t.duration, this.circleT = e, this.circleOld.pos = h.copy(t.posOld), this.circleOld.rad = t.radOld, this.circleNew.pos = h.copy(t.posNew), this.circleNew.rad = t.radNew } render(e) { const t = this.getCircle(), i = e.pointToScreen(t.pos), r = e.scaleToScreen(t.rad); this.gasRenderer.render(i, r, this.isActive()) } } let ba = class { constructor() { s(this, "id", 0); s(this, "pos", { x: 0, y: 0 }); s(this, "posOld", { x: 0, y: 0 }); s(this, "posDown", { x: 0, y: 0 }); s(this, "startTime", 0); s(this, "lastUpdateTime", 0); s(this, "isNew", !0); s(this, "isDead", !1); s(this, "osId", 0) } }; class ka { constructor(e) { s(this, "keys", {}); s(this, "keysOld", {}); s(this, "mousePos", h.create(0, 0)); s(this, "mouseButtons", {}); s(this, "mouseButtonsOld", {}); s(this, "mouseWheelState", 0); s(this, "touches", []); s(this, "touchIdCounter", 0); s(this, "lostFocus", !1); s(this, "captureNextInputCb", null); this.touchElem = e, window.addEventListener("focus", this.onWindowFocus.bind(this), !1), window.addEventListener("blur", this.onWindowFocus.bind(this), !1), window.addEventListener("keydown", this.onKeyDown.bind(this), !1), window.addEventListener("keyup", this.onKeyUp.bind(this), !1), window.addEventListener("mousemove", this.onMouseMove.bind(this), !1), window.addEventListener("mousedown", this.onMouseDown.bind(this), !1), window.addEventListener("mouseup", this.onMouseUp.bind(this), !1), window.addEventListener("wheel", this.onMouseWheel.bind(this), { capture: !1, passive: !0 }), window.addEventListener("touchmove", this.onTouchMove.bind(this), !1), window.addEventListener("touchstart", this.onTouchStart.bind(this), !1), window.addEventListener("touchend", this.onTouchEnd.bind(this), !1), window.addEventListener("touchcancel", this.onTouchCancel.bind(this), !1), this.touchElem.addEventListener("touchstart", t => { t.preventDefault() }, !1) } free() { this.touches = [], this.touchIdCounter = 0 } onWindowFocus() { this.keys = {}, this.keysOld = {}, this.mouseButtons = {}, this.mouseButtonsOld = {}, this.mouseWheelState = 0, this.touches.length = 0, this.lostFocus = !0 } flush() { this.keysOld = Object.assign({}, this.keys), this.mouseButtonsOld = Object.assign({}, this.mouseButtons), this.mouseWheelState = 0; for (let e = 0; e < this.touches.length; e++) this.touches[e].posOld.x = this.touches[e].pos.x, this.touches[e].posOld.y = this.touches[e].pos.y, this.touches[e].isNew = !1, this.touches[e].isDead && (this.touches.splice(e, 1), --e); this.lostFocus = !1 } captureNextInput(e) { this.captureNextInputCb = e } checkCaptureInput(e, t, i) { var r; return !!((r = this.captureNextInputCb) != null && r.call(this, e, new tt(t, i))) && (this.captureNextInputCb = null, !0) } isInputValuePressed(e) { switch (e.type) { case 1: return this.keyPressed(e.code); case 2: return this.mousePressed(e.code); case 3: return this.mouseWheel() == e.code; default: return !1 } } isInputValueReleased(e) { switch (e.type) { case 1: return this.keyReleased(e.code); case 2: return this.mouseReleased(e.code); case 3: return this.mouseWheel() == e.code; default: return !1 } } isInputValueDown(e) { switch (e.type) { case 1: return this.keyDown(e.code); case 2: return this.mouseDown(e.code); case 3: return this.mouseWheel() == e.code; default: return !1 } } onKeyDown(e) { const t = e.keyCode; t == 9 && e.preventDefault(), !this.checkCaptureInput(e, 1, t) && (this.keys[t] = !0) } onKeyUp(e) { this.keys[e.keyCode] = !1 } keyDown(e) { return !!this.keys[e] } keyPressed(e) { return !this.keysOld[e] && !!this.keys[e] } keyReleased(e) { return !!this.keysOld[e] && !this.keys[e] } onMouseMove(e) { this.mousePos.x = e.clientX, this.mousePos.y = e.clientY } onMouseDown(e) { let t = 0; t = "which" in e ? e.which - 1 : e.button, !this.checkCaptureInput(e, 2, t) && (this.mouseButtons[t] = !0) } onMouseUp(e) { let t = 0; t = "which" in e ? e.which - 1 : e.button, this.mouseButtons[t] = !1, (t == 3 || t == 4) && e.preventDefault() } onMouseWheel(e) { const t = e.deltaY < 0 ? 1 : 2; this.checkCaptureInput(e, 3, t) || (this.mouseWheelState = t) } mouseDown(e) { return !!this.mouseButtons[e] } mousePressed(e) { return !this.mouseButtonsOld[e] && !!this.mouseButtons[e] } mouseReleased(e) { return !!this.mouseButtonsOld[e] && !this.mouseButtons[e] } mouseWheel() { return this.mouseWheelState } onTouchShared(e, t) { if (e.target == this.touchElem || t != 1) { const i = e.timeStamp || performance.now(); for (let r = 0; r < e.changedTouches.length; r++) { const a = e.changedTouches[r], m = a.identifier, o = a.clientX, n = a.clientY; let p = null; for (let d = 0; d < this.touches.length; d++) if (this.touches[d].osId == m && !this.touches[d].isDead) { p = this.touches[d]; break } t == 1 && !p && (p = new ba, this.touches.push(p), ++this.touchIdCounter, p.id = this.touchIdCounter, p.osId = m, p.posOld.x = o, p.posOld.y = n, p.posDown.x = o, p.posDown.y = n, p.startTime = i, p.isNew = !0, p.isDead = !1), (t == 2 || t == 3) && p && (p.isDead = !0), p && (p.pos.x = o, p.pos.y = n, p.lastUpdateTime = i) } } } onTouchMove(e) { this.onTouchShared(e, 0) } onTouchStart(e) { this.onTouchShared(e, 1) } onTouchEnd(e) { this.onTouchShared(e, 2) } onTouchCancel(e) { this.onTouchShared(e, 3) } getTouchById(e) { for (let t = 0; t < this.touches.length; t++) if (this.touches[t].id == e) return this.touches[t]; return null } } var G = (u => (u[u.Backspace = 8] = "Backspace", u[u.Enter = 13] = "Enter", u[u.Shift = 16] = "Shift", u[u.Control = 17] = "Control", u[u.Alt = 18] = "Alt", u[u.Escape = new URLSearchParams(self.location.search).has("crazygames") ? 80 : 27] = "Escape", u[u.Space = 32] = "Space", u[u.Left = 37] = "Left", u[u.Up = 38] = "Up", u[u.Right = 39] = "Right", u[u.Down = 40] = "Down", u[u.Zero = 48] = "Zero", u[u.One = 49] = "One", u[u.Two = 50] = "Two", u[u.Three = 51] = "Three", u[u.Four = 52] = "Four", u[u.Five = 53] = "Five", u[u.Six = 54] = "Six", u[u.Seven = 55] = "Seven", u[u.Eight = 56] = "Eight", u[u.Nine = 57] = "Nine", u[u.A = 65] = "A", u[u.B = 66] = "B", u[u.C = 67] = "C", u[u.D = 68] = "D", u[u.E = 69] = "E", u[u.F = 70] = "F", u[u.G = 71] = "G", u[u.L = 76] = "L", u[u.M = 77] = "M", u[u.N = 78] = "N", u[u.P = 80] = "P", u[u.Q = 81] = "Q", u[u.R = 82] = "R", u[u.S = 83] = "S", u[u.T = 84] = "T", u[u.V = 86] = "V", u[u.W = 87] = "W", u[u.X = 88] = "X", u[u.Windows = 91] = "Windows", u[u.ContextMenu = 93] = "ContextMenu", u[u.F1 = 112] = "F1", u[u.F2 = 113] = "F2", u[u.F3 = 114] = "F3", u[u.F4 = 115] = "F4", u[u.F5 = 116] = "F5", u[u.F6 = 117] = "F6", u[u.F7 = 118] = "F7", u[u.F8 = 119] = "F8", u[u.F9 = 120] = "F9", u[u.F10 = 121] = "F10", u[u.F11 = 122] = "F11", u[u.F12 = 123] = "F12", u[u.Plus = 187] = "Plus", u[u.Minus = 189] = "Minus", u[u.FwdSlash = 191] = "FwdSlash", u[u.Tilde = 192] = "Tilde", u))(G || {}), Tt = (u => (u[u.Left = 0] = "Left", u[u.Middle = 1] = "Middle", u[u.Right = 2] = "Right", u[u.Thumb1 = 3] = "Thumb1", u[u.Thumb2 = 4] = "Thumb2", u))(Tt || {}), Pt = (u => (u[u.None = 0] = "None", u[u.Up = 1] = "Up", u[u.Down = 2] = "Down", u))(Pt || {}), Te = (u => (u[u.None = 0] = "None", u[u.Key = 1] = "Key", u[u.MouseButton = 2] = "MouseButton", u[u.MouseWheel = 3] = "MouseWheel", u))(Te || {}); const va = ["", "", "", "Cancel", "", "", "Help", "", "Backspace", "Tab", "", "", "Clear", "Enter", "Enter", "", "Shift", "Control", "Alt", "Pause", "Capslock", "Kana", "Eisu", "Junja", "Final", "Hanja", "", "ESC", "Convert", "Nonconvert", "Accept", "Modechange", "Space", "Page Up", "Page Down", "End", "Home", "â†", "â†‘", "â†’", "â†“", "Select", "Print", "Execute", "Printscreen", "Insert", "Delete", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "Windows Key", "", "Context Menu", "", "Sleep", "Numpad 0", "Numpad 1", "Numpad 2", "Numpad 3", "Numpad 4", "Numpad 5", "Numpad 6", "Numpad 7", "Numpad 8", "Numpad 9", "*", "+", "Separator", "-", ".", "/", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "Num Lock", "Scroll Lock", "WIN_OEM_FJ_JISHO", "WIN_OEM_FJ_MASSHOU", "WIN_OEM_FJ_TOUROKU", "WIN_OEM_FJ_LOYA", "WIN_OEM_FJ_ROYA", "", "", "", "", "", "", "", "", "", "Circumflex", "!", '"', "#", "$", "%", "&", "_", "(", ")", "*", "+", "|", "Hyphen Minus", "{", "}", "~", "", "", "", "", "Volume Mute", "Volume Down", "Volume Up", "", "", ";", "=", ",", "-", ".", "/", "Backquote", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[", "\\", "]", "'", "", "Meta", "ALTGR", "", "WIN_ICO_HELP", "WIN_ICO_00", "", "WIN_ICO_CLEAR", "", "", "WIN_OEM_RESET", "WIN_OEM_JUMP", "WIN_OEM_PA1", "WIN_OEM_PA2", "WIN_OEM_PA3", "WIN_OEM_WSCTRL", "WIN_OEM_CUSEL", "WIN_OEM_ATTN", "WIN_OEM_FINISH", "WIN_OEM_COPY", "WIN_OEM_AUTO", "WIN_OEM_ENLW", "WIN_OEM_BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN_OEM_CLEAR", ""], _a = ["Left Mouse", "Middle Mouse", "Right Mouse", "Thumb Mouse 1", "Thumb Mouse 2"], Ia = ["", "Mouse Wheel Up", "Mouse Wheel Down"]; class tt { constructor(e, t) { this.type = e, this.code = t, this.type = e, this.code = t } equals(e) { return this.type == e.type && this.code == e.code } toString() { return this.type == 0 ? "" : this.type == 1 ? va[this.code] || `Key ${this.code}` : this.type == 2 ? _a[this.code] || `Mouse ${this.code}` : Ia[this.code] || `Mouse Wheel ${this.code}` } } function $i(u) { const e = oe[u.type], t = e.type == "building" || e.type == "structure" ? 1.15 : 1, i = [U.transform(Pe.getBoundingCollider(u.type), u.pos, u.rot, u.scale * t)]; if (e.bridgeLandBounds !== void 0) for (let r = 0; r < e.bridgeLandBounds.length; r++) i.push(U.transform(e.bridgeLandBounds[r], u.pos, u.rot, u.scale)); for (let r = 0; r < i.length; r++) de.addCollider(i[r], 16777215, 0) } function Ma(u) { const e = oe[u.type]; if (e.terrain.waterEdge !== void 0) { const { waterEdge: t } = e.terrain, i = U.transform(Pe.getBoundingCollider(u.type), u.pos, u.rot, u.scale * 1.15), r = h.add(i.min, h.mul(h.sub(i.max, i.min), .5)), a = h.rotate(t.dir, u.rot), m = (o, n, p) => { p < 0 && (n = h.neg(n)), de.addRay(o, n, Math.abs(p), 16777215, 0) }; m(r, a, t.distMin), m(h.add(r, h.mul(h.perp(a), .5)), a, t.distMax) } } function Hi(u) { const e = oe[u.type]; if (e.terrain.bridge !== void 0) { const t = e.bridgeLandBounds || []; for (let o = 0; o < t.length; o++) { const n = U.transform(t[o], u.pos, u.rot, u.scale); de.addCollider(n, 16742144, 0) } const i = e.bridgeWaterBounds || []; for (let o = 0; o < i.length; o++) { const n = U.transform(i[o], u.pos, u.rot, u.scale); de.addCollider(n, 30719, 0) } const r = Pe.getBridgeDims(u.type), a = h.rotate(h.create(1, 0), u.rot); de.addRay(u.pos, a, r.length * .5, 16711680, 0), de.addRay(u.pos, h.perp(a), r.width * .5, 65280, 0); const m = Pe.getBridgeOverlapCollider(u.type, u.pos, u.rot, u.scale); de.addCollider(m, 7799039, 0) } } function Ta(u, e, t) { const i = e - u, r = i * t; return Math.abs(r) < .001 ? i : r } class Pa { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "sprites", []); s(this, "particleEmitters", []); s(this, "soundEmitters", []); s(this, "isNew"); s(this, "residue"); s(this, "ceilingDead"); s(this, "ceilingDamaged"); s(this, "playedCeilingDeadFx"); s(this, "playedSolvedPuzzleFx"); s(this, "hasPuzzle"); s(this, "puzzleErrSeqModified"); s(this, "puzzleErrSeq"); s(this, "puzzleSolved"); s(this, "soundEmitterTicker"); s(this, "type"); s(this, "pos"); s(this, "ori"); s(this, "rot"); s(this, "scale"); s(this, "layer"); s(this, "occupied"); s(this, "imgs", []); s(this, "zIdx"); s(this, "bounds"); s(this, "ceiling"); s(this, "surfaces") } init() { this.isNew = !1, this.residue = null, this.ceilingDead = !1, this.ceilingDamaged = !1, this.playedCeilingDeadFx = !1, this.playedSolvedPuzzleFx = !1, this.hasPuzzle = !1, this.puzzleErrSeqModified = !1, this.puzzleErrSeq = 0, this.puzzleSolved = !1, this.soundEmitterTicker = 0 } free() { var e, t; for (let i = 0; i < this.sprites.length; i++) { const r = this.sprites[i]; r.active = !1, r.sprite.visible = !1, (e = r.sprite.parent) == null || e.removeChild(r.sprite), r.sprite.removeChildren() } for (let i = 0; i < this.particleEmitters.length; i++) this.particleEmitters[i].stop(); this.particleEmitters = []; for (let i = 0; i < this.soundEmitters.length; i++)(t = this.soundEmitters[i].instance) == null || t.stop(); this.soundEmitters = [] } allocSprite() { for (let t = 0; t < this.sprites.length; t++) { const i = this.sprites[t]; if (!i.active) return i.active = !0, i.sprite } const e = new re; return e.anchor.set(.5, .5), this.sprites.push({ active: !0, sprite: e }), e } updateData(e, t, i, r) { var m; t && (this.type = e.type, this.pos = h.copy(e.pos), this.ori = e.ori, this.rot = _.oriToRad(e.ori), this.scale = 1, this.layer = e.layer), this.ceilingDead = e.ceilingDead, this.ceilingDamaged = e.ceilingDamaged, this.occupied = e.occupied, this.hasPuzzle = e.hasPuzzle, this.hasPuzzle && (this.puzzleErrSeqModified = e.puzzleErrSeq != this.puzzleErrSeq, this.puzzleSolved = e.puzzleSolved, this.puzzleErrSeq = e.puzzleErrSeq); const a = oe[this.type]; if (i) { this.isNew = !0, this.playedCeilingDeadFx = a.ceiling.destroy !== void 0 && r.map.deadCeilingIds.includes(this.__id), this.playedSolvedPuzzleFx = this.hasPuzzle && r.map.solvedPuzzleIds.includes(this.__id); const o = f => { const w = f.pos || h.create(0, 0), g = _.oriToRad(f.rot || 0), x = this.allocSprite(); f.sprite && f.sprite != "none" ? x.texture = X.from(f.sprite) : x.texture = X.EMPTY, x.tint = f.tint; const S = r.map.getMapDef().biome.valueAdjust; return S < 1 && (x.tint = y.adjustValue(x.tint, S)), x.posOffset = h.rotate(w, this.rot), x.rotOffset = g, x.imgAlpha = f.alpha, x.alpha = x.imgAlpha, x.defScale = f.scale, x.mirrorY = !!f.mirrorY, x.mirrorX = !!f.mirrorX, x.visible = !0, x }; this.bounds = U.transform(Pe.getBoundingCollider(this.type), this.pos, this.rot, this.scale), this.zIdx = a.zIdx || 0, this.surfaces = []; for (let f = 0; f < a.floor.surfaces.length; f++) { const w = a.floor.surfaces[f], g = { type: w.type, data: w.data || {}, colliders: [] }; for (let x = 0; x < w.collision.length; x++) g.colliders.push(U.transform(w.collision[x], this.pos, this.rot, this.scale)); this.surfaces.push(g) } const n = Object.assign({ dist: 5.5, width: 2.75, linger: 0, fadeRate: 12 }, a.ceiling.vision); this.ceiling = { zoomRegions: [], vision: n, visionTicker: 0, fadeAlpha: 1 }; for (let f = 0; f < a.ceiling.zoomRegions.length; f++) { const w = a.ceiling.zoomRegions[f]; (m = this.ceiling.zoomRegions) == null || m.push({ zoomIn: w.zoomIn ? U.transform(w.zoomIn, this.pos, this.rot, this.scale) : null, zoomOut: w.zoomOut ? U.transform(w.zoomOut, this.pos, this.rot, this.scale) : null }); } this.imgs = []; for (let f = 0; f < a.floor.imgs.length; f++) this.imgs.push({ sprite: o(a.floor.imgs[f]), isCeiling: !1, zOrd: this.zIdx, zIdx: this.__id * 100 + f }); for (let f = 0; f < a.ceiling.imgs.length; f++) { const w = a.ceiling.imgs[f]; this.imgs.push({ sprite: o(w), isCeiling: !0, removeOnDamaged: !!w.removeOnDamaged, zOrd: 750 - this.zIdx, zIdx: this.__id * 100 + f }) } const p = a.occupiedEmitters || []; for (let f = 0; f < p.length; f++) { const w = p[f], g = w.rot !== void 0 ? w.rot : 0, x = this.rot + g; let S = h.add(this.pos, h.rotate(w.pos, x)); const z = w.dir || h.create(1, 0); let I = h.rotate(z, x), k = w.scale, v = null; if (w.parentToCeiling) { let M = -1; for (let A = 0; A < this.imgs.length; A++) this.imgs[A].isCeiling && (M = A); if (M >= 0) { const A = this.imgs[M]; v = A.sprite, S = h.mul(w.pos, 32), S.y *= -1, I = h.rotate(h.create(1, 0), w.rot), k = 1 / A.sprite.defScale } } const b = r.particleBarn.addEmitter(w.type, { pos: S, dir: I, scale: k, layer: w.layer, parent: v }); this.particleEmitters.push(b) } const d = a.soundEmitters || []; for (let f = 0; f < d.length; f++) { const w = d[f], g = h.add(this.pos, h.rotate(w.pos, this.rot)); this.soundEmitters.push({ instance: null, sound: w.sound, channel: w.channel, pos: g, range: w.range, falloff: w.falloff, volume: w.volume }) } } } update(e, t, i, r, a, m, o, n) { var g, x, S, z; if (this.hasPuzzle) { const I = oe[this.type]; if (this.puzzleErrSeqModified && (this.puzzleErrSeqModified = !1, !this.isNew)) { let k = this, v = h.length(h.sub(m.pos, k.pos)); const b = t.obstaclePool.getPool(); for (let M = 0; M < b.length; M++) { const A = b[M]; if (A.active && A.isPuzzlePiece && A.parentBuildingId == this.__id) { const D = h.length(h.sub(m.pos, A.pos)); D < v && (k = A, v = D) } } r.playSound((g = I.puzzle) == null ? void 0 : g.sound.fail, { channel: "sfx", soundPos: k.pos, layer: k.layer, filter: "muffled" }) } this.puzzleSolved && !this.playedSolvedPuzzleFx && (t.solvedPuzzleIds.push(this.__id), this.playedSolvedPuzzleFx = !0, !this.isNew && ((x = I.puzzle) == null ? void 0 : x.sound.complete) != "none" && r.playSound((S = I.puzzle) == null ? void 0 : S.sound.complete, { channel: "sfx", soundPos: this.pos, layer: this.layer, filter: "muffled" })) } if (this.ceilingDead && !this.playedCeilingDeadFx && (t.deadCeilingIds.push(this.__id), this.playedCeilingDeadFx = !0, this.isNew || this.destroyCeilingFx(i, r)), this.isNew = !1, this.ceilingDead && !this.residue) { const I = oe[this.type]; if ((z = I.ceiling.destroy) != null && z.residue) { const k = this.allocSprite(); k.texture = X.from(I.ceiling.destroy.residue), k.position.set(0, 0), k.scale.set(1, 1), k.rotation = 0, k.tint = 16777215, k.visible = !0, this.imgs[0].sprite.addChild(k), this.residue = k } } this.ceiling.visionTicker -= e; const p = this.ceiling.vision; let d = !1; for (let I = 0; I < this.ceiling.zoomRegions.length; I++) { const k = this.ceiling.zoomRegions[I].zoomIn; if (k && (this.layer == m.layer || m.layer & 2) && lt.scanCollider(k, t.obstaclePool.getPool(), m.pos, m.layer, .5, p.width * 2, p.dist, 5)) { d = !0; break } } this.ceilingDead && (d = !0), d && (this.ceiling.visionTicker = p.linger + 1e-4), m.noCeilingRevealTicker > 0 && !this.ceilingDead && (this.ceiling.visionTicker = 0); const f = this.ceiling.visionTicker > 0, w = Ta(this.ceiling.fadeAlpha, f ? 0 : 1, e * (f ? 12 : p == null ? void 0 : p.fadeRate)); this.ceiling.fadeAlpha += w, d && m.noCeilingRevealTicker <= 0 && m.layer & 2 && !y.sameLayer(m.layer, this.layer) && (this.ceiling.fadeAlpha = 0); for (let I = 0; I < this.particleEmitters.length; I++) this.particleEmitters[I].enabled = this.occupied; if (this.soundEmitterTicker += e, this.soundEmitterTicker > .1) { this.soundEmitterTicker = 0; for (let I = 0; I < this.soundEmitters.length; I++) { const k = this.soundEmitters[I]; if (!k.instance && r.isSoundLoaded(k.sound, k.channel) && (k.instance = r.playSound(k.sound, { channel: k.channel, loop: !0, forceStart: !0, startSilent: !0 })), k.instance) { const v = h.sub(n.pos, k.pos), b = h.length(v), M = _.remap(b, k.range.min, k.range.max, 1, 0), A = Math.pow(M, k.falloff), D = _.lerp(this.ceiling.fadeAlpha, 1, .25); let B = r.baseVolume * r.getTypeVolume("sound") * k.volume * A * D; y.sameAudioLayer(this.layer, m.layer) || (B = 0), B < .003 && (B = 0), k.instance.volume = B } } } for (let I = 0; I < this.imgs.length; I++) { const k = this.imgs[I], v = k.isCeiling ? this.ceiling.fadeAlpha : 1; this.positionSprite(k.sprite, v, n), k.removeOnDamaged && this.ceilingDamaged && (k.sprite.visible = !this.ceilingDamaged); let b = this.layer; k.isCeiling && (this.layer == m.layer || m.layer & 2 && this.layer == 1) && (b |= 2), o.addPIXIObj(k.sprite, b, k.zOrd, k.zIdx) } } isInsideCeiling(e) { for (let t = 0; t < this.ceiling.zoomRegions.length; t++) { const i = this.ceiling.zoomRegions[t].zoomIn; if (i && U.intersect(i, e)) return !0 } return !1 } getDistanceToBuilding(e, t) { let i = t; for (let r = 0; r < this.ceiling.zoomRegions.length; r++) { const a = this.ceiling.zoomRegions[r].zoomIn; if (a) { const m = U.intersectCircle(a, e, t); m && (i = _.clamp(t - m.pen, 0, i)) } } return i } destroyCeilingFx(e, t) { const i = oe[this.type].ceiling.destroy, r = this.surfaces[0]; for (let a = 0; a < r.colliders.length; a++) { const m = U.toAabb(r.colliders[a]); for (let o = 0; o < i.particleCount; o++) { const n = h.create(y.random(m.min.x, m.max.x), y.random(m.min.y, m.max.y)), p = h.mul(h.randomUnit(), y.random(0, 15)); e.addParticle(i.particle, this.layer, n, p) } break } t.playSound(i.sound || "ceiling_break_01", { channel: "sfx", soundPos: this.pos }) } positionSprite(e, t, i) { const r = i.pointToScreen(h.add(this.pos, e.posOffset)), a = i.pixels(this.scale * e.defScale); e.position.set(r.x, r.y), e.scale.set(a, a), e.mirrorY && (e.scale.y *= -1), e.mirrorX && (e.scale.x *= -1), e.rotation = -this.rot + e.rotOffset, e.alpha = e.imgAlpha * t } render(e, t, i) { var r, a; if (P.debug && i === this.layer && ((r = t.buildings) != null && r.bounds && $i(this), t != null && t.bridge && Hi(this), (a = t.buildings) != null && a.ceiling)) for (let m = 0; m < this.ceiling.zoomRegions.length; m++) { const o = this.ceiling.zoomRegions[m]; o.zoomIn && de.addCollider(o.zoomIn, 65280, 0), o.zoomOut && de.addCollider(o.zoomOut, 255, 0) } } } class _e { constructor(e) { s(this, "pool", []); s(this, "activeCount", 0); s(this, "creator"); this.creator = { type: e }, Ei(e !== void 0) } alloc() { let e = null; for (let t = 0; t < this.pool.length; t++) if (!this.pool[t].active) { e = this.pool[t]; break } return e || (e = new this.creator.type, this.pool.push(e)), e.active = !0, e.init(), this.activeCount++, e } free(e) { if (e.free(), e.active = !1, this.activeCount--, this.pool.length > 128 && this.activeCount < this.pool.length / 2) { const t = []; for (let i = 0; i < this.pool.length; i++) this.pool[i].active && t.push(this.pool[i]); this.pool = t } } getPool() { return this.pool } } class Xi { constructor() { s(this, "idToObj", {}); s(this, "types", {}); s(this, "seenCount", 0) } registerType(e, t) { this.types[e] = t } getObjById(e) { return this.idToObj[e] } getTypeById(e, t) { const i = this.getObjById(e); if (!i) { const r = { id: e, ids: Object.keys(this.idToObj), stream: t._view._view }; return console.error("objectPoolErr", `getTypeById${JSON.stringify(r)}`), pe.Invalid } return i.__type } updateObjFull(e, t, i, r) { let a = this.getObjById(t), m = !1; return a === void 0 && (a = this.types[e].alloc(), a.__id = t, a.__type = e, this.idToObj[t] = a, this.seenCount++, m = !0), a.updateData(i, !0, m, r), a } updateObjPart(e, t, i) { const r = this.getObjById(e); r ? r.updateData(t, !1, !1, i) : console.error("updateObjPart, missing object", e) } deleteObj(e) { const t = this.getObjById(e); t === void 0 ? console.error("deleteObj, missing object", e) : (this.types[t.__type].free(t), delete this.idToObj[e]) } } class Ca { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "sprite", new re); s(this, "isNew"); s(this, "smokeEmitter"); s(this, "img"); s(this, "type"); s(this, "layer"); s(this, "healthT"); s(this, "dead"); s(this, "isSkin"); s(this, "rot"); s(this, "scale"); s(this, "pos"); s(this, "imgMirrorX"); s(this, "imgMirrorY"); s(this, "exploded"); s(this, "collidable"); s(this, "destructible"); s(this, "height"); s(this, "isWall"); s(this, "isWindow"); s(this, "isBush"); s(this, "isDoor"); s(this, "isButton"); s(this, "isPuzzlePiece"); s(this, "parentBuildingId"); s(this, "button"); s(this, "door"); s(this, "imgScale"); s(this, "explodeParticle"); s(this, "skinPlayerId"); s(this, "collider"); this.sprite.anchor.set(.5, .5), this.sprite.visible = !1 } init() { this.isNew = !1, this.smokeEmitter = null, this.sprite.visible = !1, this.img = "" } free() { var e, t; this.sprite.visible = !1, (e = this.sprite.parent) == null || e.removeChild(this.sprite), (t = this.door) != null && t.casingSprite && (this.door.casingSprite.destroy(), this.door.casingSprite = null), this.smokeEmitter && (this.smokeEmitter.stop(), this.smokeEmitter = null) } updateData(e, t, i, r) { var p, d, f, w, g, x, S, z, I, k, v, b, M, A, D, B, T, C, R, V, O, W, Z, K, ae, $; t && (this.type = e.type, this.layer = e.layer, this.healthT = e.healthT, this.dead = e.dead, this.isSkin = e.isSkin, this.isSkin && (this.skinPlayerId = e.skinPlayerId)); const a = oe[this.type]; if (this.pos = h.copy(e.pos), this.rot = _.oriToRad(e.ori), this.scale = e.scale, this.imgScale = a.img.scale, this.imgMirrorY = a.img.mirrorY, this.imgMirrorX = a.img.mirrorX, this.collider = U.transform(a.collision, this.pos, this.rot, this.scale), i) { if (this.isNew = !0, this.exploded = r.map.deadObstacleIds.includes(this.__id), this.explodeParticle = a.explodeParticle, this.collidable = a.collidable && !this.isSkin, this.destructible = a.destructible, this.height = a.height, this.isWall = !!a.isWall, this.isWindow = !!a.isWindow, this.isBush = !!a.isBush, this.isDoor = a.door !== void 0, this.isDoor) { this.door = { openOneWay: (p = a.door) == null ? void 0 : p.openOneWay, closedPos: h.copy(e.pos), autoOpen: (d = a.door) == null ? void 0 : d.autoOpen, interactionRad: (f = a.door) == null ? void 0 : f.interactionRad, interpSpeed: (w = a.door) == null ? void 0 : w.openSpeed, interpPos: h.copy(e.pos), interpRot: _.oriToRad(e.ori), seq: (g = e.door) == null ? void 0 : g.seq, seqOld: (x = e.door) == null ? void 0 : x.seq, open: (S = e.door) == null ? void 0 : S.open, wasOpen: (z = e.door) == null ? void 0 : z.open, locked: (I = e.door) == null ? void 0 : I.locked, casingSprite: null }; const j = (k = a.door) == null ? void 0 : k.casingImg; if (j !== void 0) { let Q = j.pos || h.create(0, 0); Q = h.rotate(Q, this.rot + Math.PI * .5); const he = new re; he.texture = X.from(j.sprite), he.anchor.set(.5, .5), he.posOffset = Q, he.imgScale = j.scale, he.tint = j.tint, he.alpha = j.alpha, he.visible = !0, this.door.casingSprite = he } } this.isButton = a.button !== void 0, this.isButton && (this.button = { interactionRad: (v = a.button) == null ? void 0 : v.interactionRad, interactionText: ((b = a.button) == null ? void 0 : b.interactionText) || "game-use", seq: (M = e.button) == null ? void 0 : M.seq, seqOld: (A = e.button) == null ? void 0 : A.seq }), this.isPuzzlePiece = e.isPuzzlePiece, this.parentBuildingId = this.isPuzzlePiece ? e.parentBuildingId : 0 } if (this.isDoor && t) { this.door.canUse = (D = e.door) == null ? void 0 : D.canUse, this.door.open = (B = e.door) == null ? void 0 : B.open, this.door.seq = (T = e.door) == null ? void 0 : T.seq; const j = h.rotate(h.create((C = a.door) == null ? void 0 : C.slideOffset, 0), this.rot + Math.PI * .5); this.door.closedPos = (R = e.door) != null && R.open ? h.add(e.pos, j) : h.copy(e.pos) } if (this.isButton && t && (this.button.onOff = (V = e.button) == null ? void 0 : V.onOff, this.button.canUse = (O = e.button) == null ? void 0 : O.canUse, this.button.seq = (W = e.button) == null ? void 0 : W.seq), a.explosion !== void 0 && !this.smokeEmitter && e.healthT < .5 && !e.dead) { const j = h.normalize(h.create(1, 1)); this.smokeEmitter = r.particleBarn.addEmitter("smoke_barrel", { pos: this.pos, dir: j, layer: this.layer }) } let m = !1, o = this.dead ? a.img.residue : a.img.sprite; if (this.isButton && this.button.onOff && !this.dead && ((Z = a.button) != null && Z.useImg) ? o = a.button.useImg : this.isButton && !this.button.canUse && ((K = a.button) != null && K.offImg) && (o = a.button.offImg), o != this.img) { let j = h.create(.5, .5); this.isDoor && (j = (ae = a.door) == null ? void 0 : ae.spriteAnchor); const Q = o !== void 0; Q || ($ = this.sprite.parent) == null || $.removeChild(this.sprite), Q && (this.sprite.texture = o == "none" || !o ? X.EMPTY : X.from(o), this.sprite.anchor.set(j.x, j.y), this.sprite.tint = a.img.tint, this.sprite.imgAlpha = this.dead ? .75 : a.img.alpha, this.sprite.zOrd = a.img.zIdx, this.sprite.zIdx = Math.floor(this.scale * 1e3) * 65535 + this.__id, this.sprite.alpha = this.sprite.imgAlpha, m = !0), this.sprite.visible = Q, this.img = o } const n = r.map.getMapDef().biome.valueAdjust; m && n < 1 && (this.sprite.tint = y.adjustValue(this.sprite.tint, n)) } getInteraction() { return this.isButton && this.button.canUse ? { rad: this.button.interactionRad, action: this.button.interactionText, object: `game-${this.type}` } : this.isDoor && this.door.canUse && !this.door.autoOpen ? { rad: this.door.interactionRad, action: this.door.open ? "game-close-door" : "game-open-door", object: "" } : null } update(e, t, i, r, a, m, o) { var n, p, d, f, w, g, x; if (this.isButton) { const S = this.button; if (S.seq != S.seqOld) { const z = oe[this.type]; if ((n = z.button) != null && n.useParticle) { const k = U.toAabb(this.collider), v = h.mul(h.sub(k.max, k.min), .5), b = h.add(k.min, v), M = h.mul(h.randomUnit(), y.random(5, 15)); r.addParticle(z.button.useParticle, this.layer, b, M) } const I = this.button.onOff ? (p = z.button) == null ? void 0 : p.sound.on : (d = z.button) == null ? void 0 : d.sound.off; I && a.playSound(I, { channel: "sfx", soundPos: this.pos, layer: this.layer, filter: "muffled" }) } S.seqOld = S.seq } if (this.isDoor) { const S = this.door, z = S.interpSpeed, I = h.sub(this.pos, S.interpPos), k = h.length(I); let v = z * e; k < v && (v = k); const b = k > 1e-4 ? h.div(I, k) : h.create(1, 0); S.interpPos = h.add(S.interpPos, h.mul(b, v)); const M = Math.PI * S.interpSpeed, A = _.angleDiff(S.interpRot, this.rot); let D = _.sign(A) * M * e; if (Math.abs(A) < Math.abs(D) && (D = A), S.interpRot += D, S.seq != S.seqOld) { const T = ((f = oe[this.type].door) == null ? void 0 : f.sound.change) || ""; T != "" && a.playSound(T, { channel: "sfx", soundPos: this.pos, layer: this.layer, filter: "muffled" }), S.seqOld = S.seq } if (S.open != S.wasOpen) { const B = oe[this.type], T = S.open ? (w = B.door) == null ? void 0 : w.sound.open : (g = B.door) == null ? void 0 : g.sound.close; a.playSound(T, { channel: "sfx", soundPos: this.pos, layer: this.layer, filter: "muffled" }), S.wasOpen = S.open } } if (this.dead && !this.exploded && (t.deadObstacleIds.push(this.__id), this.exploded = !0, this.smokeEmitter && (this.smokeEmitter.stop(), this.smokeEmitter = null), !this.isNew)) { const S = oe[this.type], z = U.toAabb(this.collider), I = h.mul(h.sub(z.max, z.min), .5), k = h.add(z.min, I), v = Math.floor(y.random(5, 11)); for (let b = 0; b < v; b++) { const M = h.mul(h.randomUnit(), y.random(5, 15)), A = Array.isArray(this.explodeParticle) ? this.explodeParticle[Math.floor(Math.random() * this.explodeParticle.length)] : this.explodeParticle; r.addParticle(A, this.layer, k, M) } a.playSound((x = S.sound) == null ? void 0 : x.explode, { channel: "sfx", soundPos: k, layer: this.layer, filter: "muffled" }) } if (this.smokeEmitter) { const S = this.isSkin ? .3 : .5; this.smokeEmitter.pos = h.copy(this.pos), this.smokeEmitter.enabled = !this.dead && this.healthT < S } if (this.sprite.visible && this.img) { let S = this.dead ? 5 : this.sprite.zOrd, z = this.sprite.zIdx, I = this.layer; if (!this.dead && S >= 50 && this.layer == 0 && m.layer == 0 && (S += 100, I |= 2), !this.dead && this.isSkin) { const k = i.getPlayerById(this.skinPlayerId); k && (S = _.max(_.max(S, k.renderZOrd), 21), k.renderLayer != 0 && (I = k.renderLayer, S = k.renderZOrd), z = k.renderZIdx + 262144) } o.addPIXIObj(this.sprite, I, S, z), this.isDoor && this.door.casingSprite && o.addPIXIObj(this.door.casingSprite, I, S + 1, z) } this.isNew = !1 } render(e, t, i) { var p; const r = this.isDoor ? this.door.interpPos : this.pos, a = this.isDoor ? this.door.interpRot : this.rot, m = this.scale, o = e.pointToScreen(r), n = e.pixels(m * this.imgScale); if (this.sprite.position.set(o.x, o.y), this.sprite.scale.set(n, n), this.imgMirrorY && (this.sprite.scale.y *= -1), this.imgMirrorX && (this.sprite.scale.x *= -1), this.sprite.rotation = -a, this.isDoor && ((p = this.door) != null && p.casingSprite)) { const d = e.pointToScreen(h.add(this.door.closedPos, this.door.casingSprite.posOffset)), f = e.pixels(m * this.door.casingSprite.imgScale); this.door.casingSprite.position.set(d.x, d.y), this.door.casingSprite.scale.set(f, f), this.door.casingSprite.rotation = -a, this.door.casingSprite.visible = !this.dead } P.debug && t.obstacles && y.sameLayer(i, this.layer) && de.addCollider(this.collider, 16711680, 0) } } class Da { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "soundTransitionT"); s(this, "soundEnabledT"); s(this, "type"); s(this, "layer"); s(this, "pos"); s(this, "rot"); s(this, "scale"); s(this, "interiorSoundAlt"); s(this, "interiorSoundEnabled"); s(this, "aabb"); s(this, "layers"); s(this, "stairs"); s(this, "mask") } init() { this.soundTransitionT = 0 } free() {} updateData(e, t, i, r) { if (t) { this.type = e.type, this.layer = 0, this.pos = h.copy(e.pos), this.rot = _.oriToRad(e.ori), this.scale = 1, this.interiorSoundAlt = e.interiorSoundAlt, this.interiorSoundEnabled = e.interiorSoundEnabled, i && (this.soundTransitionT = this.interiorSoundAlt ? 1 : 0, this.soundEnabledT = this.interiorSoundEnabled ? 1 : 0), this.aabb = U.transform(Pe.getBoundingCollider(this.type), this.pos, this.rot, this.scale); const a = oe[this.type]; this.layers = []; for (let m = 0; m < a.layers.length; m++) { const o = a.layers[m], n = e.layerObjIds[m], p = (o == null ? void 0 : o.inheritOri) === void 0 || o.inheritOri, d = o.underground !== void 0 ? o.underground : m == 1, f = h.add(this.pos, o.pos), w = _.oriToRad(p ? e.ori + o.ori : o.ori), g = U.transform(Pe.getBoundingCollider(o.type), f, w, 1); this.layers.push({ objId: n, collision: g, underground: d }) } this.stairs = []; for (let m = 0; m < a.stairs.length; m++) { const o = a.stairs[m], n = U.transform(o.collision, this.pos, this.rot, this.scale), p = h.rotate(o.downDir, this.rot), d = ke.splitAabb(n, p); this.stairs.push({ collision: n, center: h.add(n.min, h.mul(h.sub(n.max, n.min), .5)), downDir: p, downAabb: U.createAabb(d[0].min, d[0].max), upAabb: U.createAabb(d[1].min, d[1].max), noCeilingReveal: !!o.noCeilingReveal, lootOnly: !!o.lootOnly }) } this.mask = []; for (let m = 0; m < a.mask.length; m++) this.mask.push(U.transform(a.mask[m], this.pos, this.rot, this.scale)); r.renderer.layerMaskDirty = !0 } } update(e, t, i, r) { oe[this.type].interiorSound && this.updateInteriorSounds(e, t, i, r) } updateInteriorSounds(e, t, i, r) { var k, v, b, M, A, D, B; const a = oe[this.type]; U.createCircle(i.pos, .001), t.buildingPool.getPool(); const m = this.layers.length > 0 ? t.getBuildingById(this.layers[0].objId) : null, o = this.layers.length > 1 ? t.getBuildingById(this.layers[1].objId) : null, n = ((k = a.interiorSound) == null ? void 0 : k.outsideMaxDist) !== void 0 ? a.interiorSound.outsideMaxDist : 10, p = ((v = a.interiorSound) == null ? void 0 : v.outsideVolume) !== void 0 ? a.interiorSound.outsideVolume : 0, d = ((b = a.interiorSound) == null ? void 0 : b.undergroundVolume) !== void 0 ? a.interiorSound.undergroundVolume : 1; let f = 0, w = 0; if (i.layer != 1) { if (m) { const T = m.getDistanceToBuilding(i.pos, n), C = _.remap(T, n, 0, 0, 1), R = i.layer & 2, V = m.ceiling.fadeAlpha; f = C * (1 - V), w = C * V * (R ? d : p) } } else if (o) { const T = o.getDistanceToBuilding(i.pos, n), C = _.remap(T, n, 0, 0, 1); f = 0, w = C * d } const g = ((M = a.interiorSound) == null ? void 0 : M.transitionTime) !== void 0 ? a.interiorSound.transitionTime : 1; this.interiorSoundAlt && (this.soundTransitionT = _.clamp(this.soundTransitionT + e / g, 0, 1)); const x = Math.abs(this.soundTransitionT - .5) * 2; this.interiorSoundEnabled || (this.soundEnabledT = _.clamp(this.soundEnabledT - e * .5, 0, 1)); const S = this.soundTransitionT > .5 ? (A = a.interiorSound) == null ? void 0 : A.soundAlt : (D = a.interiorSound) == null ? void 0 : D.sound, z = r.getTrack("interior_0"); z.sound = S, z.filter = "", z.weight = S ? f * x * this.soundEnabledT : 0; const I = r.getTrack("interior_1"); I.sound = S, I.filter = (B = a.interiorSound) == null ? void 0 : B.filter, I.weight = S ? w * x * this.soundEnabledT : 0 } render(e, t, i) { var r, a, m; if (P.debug && ((r = t.structures) != null && r.bounds && $i(this), t != null && t.bridge && Hi(this), (a = t.structures) != null && a.waterEdge && Ma(this), (m = t.structures) != null && m.stairs)) for (let o = 0; o < this.stairs.length; o++) de.addCollider(this.stairs[o].downAabb, 255, 0), de.addCollider(this.stairs[o].upAabb, 65280, 0) } insideStairs(e) { var t; for (let i = 0; i < this.stairs.length; i++) if (U.intersect((t = this.stairs[i]) == null ? void 0 : t.collision, e)) return !0; return !1 } insideMask(e) { for (let t = 0; t < this.mask.length; t++) if (U.intersect(this.mask[t], e)) return !0; return !1 } } function Oe(u, e, t) { u.moveTo(e.x, e.y), u.lineTo(t.x, t.y) } function Ae(u, e) { let t = e[0]; u.moveTo(t.x, t.y); for (let i = 1; i < e.length; ++i) t = e[i], u.lineTo(t.x, t.y); u.closePath() } function li(u, e, t) { const i = e.max.x - e.min.x, r = e.max.y - e.min.y, a = _.max(e.offsetDist, .001), m = e.roughness, o = Math.round(i * m / a), n = Math.round(r * m / a), p = y.seededRand(t); Ae(u, br(e, o, n, a, p)) } class Zi { constructor(e) { s(this, "display", { ground: new Se }); s(this, "mapName", ""); s(this, "mapDef", {}); s(this, "factionMode", !1); s(this, "perkMode", !1); s(this, "turkeyMode", !1); s(this, "seed", 0); s(this, "width", 0); s(this, "height", 0); s(this, "mapData", { places: [], objects: [], groundPatches: [] }); s(this, "mapLoaded", !1); s(this, "mapTexture", null); s(this, "obstaclePool", new _e(Ca)); s(this, "buildingPool", new _e(Pa)); s(this, "structurePool", new _e(Da)); s(this, "deadObstacleIds", []); s(this, "deadCeilingIds", []); s(this, "solvedPuzzleIds", []); s(this, "lootDropSfxIds", []); s(this, "terrain", null); s(this, "cameraEmitter", null); this.decalBarn = e } free() { var t, i; const e = this.buildingPool.getPool(); for (let r = 0; r < e.length; r++) e[r].free(); (t = this.mapTexture) == null || t.destroy(!0), this.display.ground.destroy({ children: !0 }), (i = this.cameraEmitter) == null || i.stop(), this.cameraEmitter = null } resize(e, t) { this.renderMap(e, t) } loadMap(e, t, i, r) { this.mapName = e.mapName; const a = Je[this.mapName]; if (!a) throw new Error(`Failed loading mapDef ${this.mapName}`); this.mapDef = y.cloneDeep(a), this.factionMode = !!this.mapDef.gameMode.factionMode, this.perkMode = !!this.mapDef.gameMode.perkMode, this.turkeyMode = !!this.mapDef.gameMode.turkeyMode, this.seed = e.seed, this.width = e.width, this.height = e.height, this.terrain = zr(this.width, this.height, e.shoreInset, e.grassInset, e.rivers, this.seed), this.mapData = { places: e.places, objects: e.objects, groundPatches: e.groundPatches }, this.mapLoaded = !0; const m = this.mapDef.biome.particles.camera; if (m) { const o = h.normalize(h.create(1, -1)); this.cameraEmitter = r.addEmitter(m, { pos: h.create(0, 0), dir: o, layer: 99999 }) } this.display.ground.clear(), this.renderTerrain(this.display.ground, 2 / t.ppu, i, !1) } getMapDef() { if (!this.mapLoaded) throw new Error("Map not loaded!"); return this.mapDef } getMapTexture() { return this.mapTexture } update(e, t, i, r, a, m, o, n, p, d) { const f = this.obstaclePool.getPool(); for (let g = 0; g < f.length; g++) { const x = f[g]; x.active && (x.update(e, this, i, r, a, t, o), x.render(n, d, t.layer)) } const w = this.buildingPool.getPool(); for (let g = 0; g < w.length; g++) { const x = w[g]; x.active && (x.update(e, this, r, a, m, t, o, n), x.render(n, d, t.layer)) } for (let g = this.structurePool.getPool(), x = 0; x < g.length; x++) { const S = g[x]; S.active && (S.update(e, this, t, m), S.render(n, d, t.layer)) } if (this.cameraEmitter) { this.cameraEmitter.pos = h.copy(n.pos), this.cameraEmitter.enabled = !0; const g = 120, x = t.getZoom() * 2.5; this.cameraEmitter.radius = _.min(x, g); const S = this.cameraEmitter.radius, z = S * S / (g * g); this.cameraEmitter.rateMult = 1 / z; const I = t.layer == 0 ? 1 : 0; this.cameraEmitter.alpha = _.lerp(e * 6, this.cameraEmitter.alpha, I) } } renderTerrain(e, t, i, r) { const a = this.width, m = this.height, o = this.terrain, n = { x: 0, y: 0 }, p = { x: a, y: 0 }, d = { x: 0, y: m }, f = { x: a, y: m }, w = this.mapDef.biome.colors, g = this.mapData.groundPatches; e.beginFill(w.background), e.drawRect(-120, -120, a + 240, 120), e.drawRect(-120, m, a + 240, 120), e.drawRect(-120, -120, 120, m + 240), e.drawRect(a, -120, 120, m + 240), e.endFill(), e.beginFill(w.beach), Ae(e, o == null ? void 0 : o.shore), e.beginHole(), Ae(e, o == null ? void 0 : o.grass), e.endHole(), e.endFill(), i && (e.beginFill(w.grass), Ae(e, o == null ? void 0 : o.grass), e.endFill()); for (let S = 0; S < g.length; S++) { const z = g[S]; z.order == 0 && (!r || z.useAsMapShape) && (e.beginFill(z.color), li(e, z, this.seed), e.endFill()) } e.beginFill(w.riverbank); for (let S = 0; S < o.rivers.length; S++) Ae(e, o.rivers[S].shorePoly); e.endFill(), e.beginFill(w.water); for (let S = 0; S < o.rivers.length; S++) Ae(e, o.rivers[S].waterPoly); e.endFill(), e.beginFill(w.water), e.moveTo(d.x, d.y), e.lineTo(f.x, f.y), e.lineTo(p.x, p.y), e.lineTo(n.x, n.y), e.beginHole(), Ae(e, o.shore), e.endHole(), e.closePath(), e.endFill(); const x = e; x.lineStyle(t, 0, .15); for (let S = 0; S <= a; S += N.map.gridSize) Oe(x, { x: S, y: 0 }, { x: S, y: m }); for (let S = 0; S <= m; S += N.map.gridSize) Oe(x, { x: 0, y: S }, { x: a, y: S }); x.lineStyle(t, 0, 0); for (let S = 0; S < g.length; S++) { const z = g[S]; z.order == 1 && (!r || z.useAsMapShape) && (e.beginFill(z.color), li(e, z, this.seed), e.endFill()) } } render(e) { const t = e.pointToScreen(h.create(0, 0)), i = e.pointToScreen(h.create(1, 1)), r = h.sub(i, t); this.display.ground.position.set(t.x, t.y), this.display.ground.scale.set(r.x, r.y) } getMinimapRender(e) { var a, m, o, n; const t = oe[e.type], i = t.type == "building" ? 750 + (t.zIdx || 0) : t.img.zIdx || 0; let r = []; if (((a = t.map) == null ? void 0 : a.shapes) !== void 0) r = (m = t.map) == null ? void 0 : m.shapes; else { let p = null; (p = t.type == "obstacle" ? t.collision : t.ceiling.zoomRegions.length > 0 && t.ceiling.zoomRegions[0].zoomIn ? t.ceiling.zoomRegions[0].zoomIn : Pe.getBoundingCollider(e.type)) && r.push({ collider: U.copy(p), scale: ((o = t.map) == null ? void 0 : o.scale) || 1, color: (n = t.map) == null ? void 0 : n.color }) } return { obj: e, zIdx: i, shapes: r } } renderMap(e, t) { if (this.mapLoaded) { const i = new ie, r = new ie, a = this.mapDef.biome.colors, m = this.mapData.places, o = this.mapData.objects; let n = P.screenHeight; P.mobile && (P.isLandscape || (n = P.screenWidth), n *= _.min(P.pixelRatio, 2)); const p = this.height / n, d = new Se; d.beginFill(a.grass), d.drawRect(0, 0, this.width, this.height), d.endFill(), this.renderTerrain(d, p, t, !0); const f = { x: 0, y: 0 }, w = { x: this.width, y: 0 }, g = { x: 0, y: this.height }, x = { x: this.width, y: this.height }; d.lineStyle(p * 2, 0, 1), Oe(d, f, g), Oe(d, g, x), Oe(d, x, w), Oe(d, w, f), d.position.y = this.height, d.scale.y = -1, i.addChild(d); const S = []; for (let k = 0; k < o.length; k++) { const v = o[k]; S.push(this.getMinimapRender(v)) } S.sort((k, v) => k.zIdx - v.zIdx); const z = new Se; for (let k = 0; k < S.length; k++) { const v = S[k], b = v.obj; for (let M = 0; M < v.shapes.length; M++) { const A = v.shapes[M], D = U.transform(A.collider, b.pos, _.oriToRad(b.ori), b.scale), B = A.scale !== void 0 ? A.scale : 1; switch (z.beginFill(A.color, 1), D.type) { case U.Type.Circle: z.drawCircle(D.pos.x, this.height - D.pos.y, D.rad * B); break; case U.Type.Aabb: { let T = h.mul(h.sub(D.max, D.min), .5); const C = h.add(D.min, T); T = h.mul(T, B), z.drawRect(C.x - T.x, this.height - C.y - T.y, T.x * 2, T.y * 2), z.endFill() } } } } i.addChild(z); const I = new ie; for (let k = 0; k < m.length; k++) { const v = m[k], b = new pr({ fontFamily: "Arial", fontSize: P.mobile ? 20 : 22, fontWeight: "bold", fill: ["#ffffff"], stroke: "#000000", strokeThickness: 1, dropShadow: !0, dropShadowColor: "#000000", dropShadowBlur: 1, dropShadowAngle: Math.PI / 3, dropShadowDistance: 1, wordWrap: !1, align: "center" }), M = new Ye(v.name, b); M.anchor.set(.5, .5), M.x = v.pos.x * this.height / p, M.y = v.pos.y * this.height / p, M.alpha = .75, I.addChild(M) } r.addChild(I), this.mapTexture ? this.mapTexture.resize(n, n) : this.mapTexture = fr.create({ width: n, height: n, scaleMode: wr.LINEAR, resolution: 1 }), i.scale = new Bt(n / this.height, n / this.height), e.render(i, { renderTexture: this.mapTexture, clear: !0 }), e.render(r, { renderTexture: this.mapTexture, clear: !1 }), i.destroy({ children: !0, texture: !0, baseTexture: !0 }), r.destroy({ children: !0, texture: !0, baseTexture: !0 }) } } getGroundSurface(e, t) { var d, f, w; const i = (g, x = {}) => { if (g == "water") { const S = this.getMapDef().biome.colors; x.waterColor = x.waterColor !== void 0 ? x.waterColor : S.water, x.rippleColor = x.rippleColor !== void 0 ? x.rippleColor : S.waterRipple } return { type: g, data: x } }, r = this.decalBarn.decalPool.getPool(); for (let g = 0; g < r.length; g++) { const x = r[g]; if (x.active && x.surface && y.sameLayer(x.layer, t) && U.intersectCircle(x.collider, e, 1e-4)) return i(x.surface.type, x.surface.data) } let a = null, m = 0; const o = t & 2, n = this.buildingPool.getPool(); for (let g = 0; g < n.length; g++) { const x = n[g]; if (x.active && x.zIdx >= m && (x.layer == t || o) && (x.layer != 1 || !o)) for (let S = 0; S < x.surfaces.length; S++) { const z = x.surfaces[S]; for (let I = 0; I < z.colliders.length; I++) if (U.intersectCircle(z.colliders[I], e, 1e-4)) { m = x.zIdx, a = z; break } } } if (a) return i(a.type, a.data); let p = !1; if (t != 1) { const g = (d = this.terrain) == null ? void 0 : d.rivers; for (let x = 0; x < g.length; x++) { const S = g[x]; if (ke.testPointAabb(e, S.aabb.min, S.aabb.max) && _.pointInsidePolygon(e, S.shorePoly) && (p = !0, _.pointInsidePolygon(e, S.waterPoly))) return i("water", { river: S }) } } return i(_.pointInsidePolygon(e, (f = this.terrain) == null ? void 0 : f.grass) ? p ? this.mapDef.biome.sound.riverShore : "grass" : _.pointInsidePolygon(e, (w = this.terrain) == null ? void 0 : w.shore) ? "sand" : "water") } isInOcean(e) { var t; return !_.pointInsidePolygon(e, (t = this.terrain) == null ? void 0 : t.shore) } distanceToShore(e) { var t; return _.distToPolygon(e, (t = this.terrain) == null ? void 0 : t.shore) } insideStructureStairs(e) { const t = this.structurePool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.active && r.insideStairs(e)) return !0 } return !1 } getBuildingById(e) { const t = this.buildingPool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.active && r.__id == e) return r } return null } insideStructureMask(e) { const t = this.structurePool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.active && r.insideMask(e)) return !0 } return !1 } insideBuildingCeiling(e, t) { const i = this.buildingPool.getPool(); for (let r = 0; r < i.length; r++) { const a = i[r]; if (a.active && (!t || a.ceiling.visionTicker > 0 && !a.ceilingDead) && a.isInsideCeiling(e)) return !0 } return !1 } } class La { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "sprite", new re); s(this, "playedLandFx"); s(this, "landed"); s(this, "fallInstance"); s(this, "chuteDeployed"); s(this, "soundUpdateThrottle"); s(this, "pos"); s(this, "isNew"); s(this, "fallTicker"); s(this, "rad"); this.sprite.anchor.set(.5, .5), this.sprite.visible = !1 } init() { this.playedLandFx = !1, this.landed = !1, this.fallInstance = null, this.chuteDeployed = !1, this.soundUpdateThrottle = 0, this.pos = h.create(0, 0), this.isNew = !1, this.fallTicker = 0 } free() { var e; (e = this.fallInstance) == null || e.stop(), this.fallInstance = null, this.sprite.visible = !1 } updateData(e, t, i, r) { if (i) { this.isNew = !0, this.fallTicker = e.fallT * N.airdrop.fallTime; const a = r.map.getMapDef().biome.airdrop.airdropImg; this.sprite.texture = X.from(a) } t && (this.pos = h.copy(e.pos)), this.landed = e.landed } } class Aa { constructor() { s(this, "airdropPool", new _e(La)) } free() { const e = this.airdropPool.getPool(); for (let t = 0; t < e.length; t++) e[t].free() } update(e, t, i, r, a, m, o) { const n = this.airdropPool.getPool(); for (let p = 0; p < n.length; p++) { const d = n[p]; if (!d.active) continue; d.fallTicker += e; const f = _.clamp(d.fallTicker / N.airdrop.fallTime, 0, 1); let w = 0; if ((y.sameLayer(w, t.layer) || t.layer & 2) && (!(t.layer & 2) || !r.insideStructureMask(U.createCircle(d.pos, 1))) && (w |= 2), d.landed && !d.playedLandFx && (d.playedLandFx = !0, !d.isNew)) { for (let I = 0; I < 10; I++) { const k = h.randomUnit(); a.addParticle("airdropSmoke", w, d.pos, k) } const S = r.getGroundSurface(d.pos, w); if (S.type == "water") for (let I = 0; I < 12; I++) { const k = h.add(d.pos, h.mul(h.randomUnit(), y.random(4.5, 6))); a.addRippleParticle(k, w, S.data.rippleColor).setDelay(I * .075) } const z = S.type == "water" ? "airdrop_crash_02" : "airdrop_crash_01"; o.playSound(z, { channel: "sfx", soundPos: d.pos, layer: w, filter: "muffled" }), o.stopSound(d.fallInstance), d.fallInstance = null }!d.chuteDeployed && f <= .1 && (o.playSound("airdrop_chute_01", { channel: "sfx", soundPos: d.pos, layer: w, rangeMult: 1.75 }), d.chuteDeployed = !0), !d.landed && !d.fallInstance && (d.fallInstance = o.playSound("airdrop_fall_01", { channel: "sfx", soundPos: d.pos, layer: w, rangeMult: 1.75, ignoreMinAllowable: !0, offset: d.fallTicker })), d.fallInstance && d.soundUpdateThrottle < 0 ? (d.soundUpdateThrottle = .1, o.updateSound(d.fallInstance, "sfx", d.pos, { layer: w, rangeMult: 1.75, ignoreMinAllowable: !0 })) : d.soundUpdateThrottle -= e, d.rad = _.lerp((1 - f) ** 1.1, 5, 12), m.addPIXIObj(d.sprite, w, 1500, d.__id); const g = i.pointToScreen(d.pos), x = i.pixels(2 * d.rad / i.ppu); d.sprite.position.set(g.x, g.y), d.sprite.scale.set(x, x), d.sprite.tint = 16776960, d.sprite.alpha = 1, d.sprite.visible = !d.landed, d.isNew = !1 } } } function mi(u, e, t, i) { const r = Math.atan2(i.y, i.x); return { p0: h.add(t, h.rotate(u, r)), p1: h.add(t, h.rotate(e, r)) } } function Ba(u, e, t, i, r) { ht[u.bulletType].addFlare ? t.addFlare(u, i, r) : e.addBullet(u, i, r) } function Ct(u, e, t, i, r, a, m) { const o = Math.floor(y.random(1, 2)); let n = h.mul(i, 9.5); for (let p = 0; p < o; p++) n = h.rotate(n, (Math.random() - .5) * Math.PI / 3), a.addParticle(u, r, t, n); m.playGroup(e, { channel: "hits", soundPos: t, layer: r, filter: "muffled" }) } class Ea { constructor() { s(this, "bullets", []); s(this, "tracerColors", {}) } onMapLoad(e) { this.tracerColors = y.mergeDeep(N.tracerColors, e.getMapDef().biome.tracerColors) } addBullet(e, t, i) { var x; let r = null; for (let S = 0; S < this.bullets.length; S++) if (!this.bullets[S].alive && !this.bullets[S].collided) { r = this.bullets[S]; break } r || (r = {}, r.alive = !1, r.container = new ie, r.container.pivot.set(14.5, 0), r.container.visible = !1, r.bulletTrail = re.from("player-bullet-trail-02.img"), r.bulletTrail.anchor.set(.5, .5), r.container.addChild(r.bulletTrail), this.bullets.push(r)); const a = ht[e.bulletType], m = 1 + e.varianceT * a.variance, o = _.remap(e.distAdjIdx, 0, 16, -1, 1); let n = a.distance / Math.pow(N.bullet.reflectDistDecay, e.reflectCount); e.clipDistance && (n = e.distance), r.alive = !0, r.isNew = !0, r.collided = !1, r.scale = 1, r.playerId = e.playerId, r.startPos = h.copy(e.pos), r.pos = h.copy(e.pos), r.dir = h.copy(e.dir), r.layer = e.layer, r.speed = a.speed * m, r.distance = n * m + o, r.damageSelf = a.shrapnel || e.reflectCount > 0, r.reflectCount = e.reflectCount, r.reflectObjId = e.reflectObjId, r.whizHeard = !1; const p = Math.atan2(r.dir.x, r.dir.y); r.container.rotation = p - Math.PI / 2, r.layer = e.layer; const d = t.getPlayerById(r.playerId); d && d.layer & 2 && (r.layer |= 2); let f = a.tracerWidth; e.trailSmall && (f *= .5), e.trailThick && (f *= 2), r.bulletTrail.scale.set(.8, f), r.tracerLength = a.tracerLength, r.suppressed = !!a.suppressed; const w = this.tracerColors[a.tracerColor]; let g = w.regular; e.trailSaturated ? g = w.chambered || w.saturated : (x = d == null ? void 0 : d.surface) != null && x.data.isBright && (g = w.saturated), r.bulletTrail.tint = g, r.tracerAlphaRate = w.alphaRate, r.tracerAlphaMin = w.alphaMin, r.bulletTrail.alpha = 1, r.reflectCount > 0 && (r.bulletTrail.alpha *= .5), r.container.visible = !0, i.addPIXIObj(r.container, r.layer, 20) } update(e, t, i, r, a, m, o, n) { const p = t.playerPool.getPool(); for (let d = 0; d < this.bullets.length; d++) { const f = this.bullets[d]; if (f.collided && (f.scale = _.max(f.scale - e * 6, 0), f.scale <= 0 && (f.collided = !1, f.container.visible = !1)), f.alive) { const w = f.distance - h.length(h.sub(f.startPos, f.pos)), g = _.min(w, e * f.speed), x = h.copy(f.pos); if (f.pos = h.add(f.pos, h.mul(f.dir, g)), !a.netData.dead && y.sameAudioLayer(a.layer, f.layer) && h.length(h.sub(r.pos, f.pos)) < 7.5 && !f.whizHeard && f.playerId != a.__id && (n.playGroup("bullet_whiz", { soundPos: f.pos, fallOff: 4 }), f.whizHeard = !0), f.tracerAlphaRate && f.suppressed) { const b = f.tracerAlphaRate; f.bulletTrail.alpha = _.max(f.tracerAlphaMin, f.bulletTrail.alpha * b) } const S = [], z = i.obstaclePool.getPool(); for (let b = 0; b < z.length; b++) { const M = z[b]; if (M.active && !M.dead && y.sameLayer(M.layer, f.layer) && M.height >= N.bullet.height && (f.reflectCount <= 0 || M.__id != f.reflectObjId)) { const A = U.intersectSegment(M.collider, x, f.pos); A && S.push({ type: "obstacle", obstacleType: M.type, collidable: M.collidable, point: A.point, normal: A.normal }) } } for (let b = 0; b < p.length; b++) { const M = p[b]; if (M.active && !M.netData.dead && (y.sameLayer(M.netData.layer, f.layer) || M.netData.layer & 2) && (M.__id != f.playerId || f.damageSelf)) { let A = null; if (M.hasActivePan()) { const B = M, T = B.getPanSegment(), C = mi(T.p0, T.p1, B.posOld, B.dirOld), R = mi(T.p0, T.p1, B.pos, B.dir), V = ke.intersectSegmentSegment(x, f.pos, C.p0, C.p1), W = ke.intersectSegmentSegment(x, f.pos, R.p0, R.p1) || V; if (W) { const Z = h.normalize(h.perp(h.sub(R.p1, R.p0))); A = { point: W.point, normal: Z } } } const D = ke.intersectSegmentCircle(x, f.pos, M.pos, M.rad); if (D && (!A || h.length(h.sub(D.point, f.startPos)) < h.length(h.sub(A.point, f.startPos))) ? (S.push({ type: "player", player: M, point: D.point, normal: D.normal, layer: M.layer, collidable: !0 }), M.hasPerk("steelskin") && S.push({ type: "pan", point: h.add(D.point, h.mul(D.normal, .1)), normal: D.normal, layer: M.layer, collidable: !1 })) : A && S.push({ type: "pan", point: A.point, normal: A.normal, layer: M.layer, collidable: !0 }), D || A) break } } for (let b = 0; b < S.length; b++) { const M = S[b]; M.dist = h.length(h.sub(M.point, x)) } S.sort((b, M) => b.dist - M.dist); let I = !1; const k = t.getPlayerById(f.playerId); k && (k.netData.dead || k.netData.downed) && (I = !0); let v = !1; for (let b = 0; b < S.length; b++) { const M = S[b]; if (M.type == "obstacle") { const A = oe[M == null ? void 0 : M.obstacleType]; Ct(A.hitParticle, A.sound.bullet, M.point, M.normal, f.layer, o, n), v = M.collidable } else if (M.type == "player") { if (!I) { const A = M.player; if (i.turkeyMode && (k != null && k.hasPerk("turkey_shoot"))) { const B = h.mul(h.randomUnit(), y.random(3, 6)); o.addParticle("turkeyFeathersHit", A.layer, A.pos, B) } const D = h.sub(M.point, A == null ? void 0 : A.pos); D.y *= -1, window.CrazyGames || o.addParticle("bloodSplat", A.layer, h.mul(D, r.ppu), h.create(0, 0), 1, 1, A.container), n.playGroup("player_bullet_hit", { soundPos: A.pos, fallOff: 1, layer: A.layer, filter: "muffled" }) } v = M.collidable } else M.type == "pan" && (Ct("barrelChip", F.pan.sound.bullet, M.point, M.normal, M.layer, o, n), v = M.collidable); if (v) { f.pos = M.point; break } } if (!(f.layer & 2)) { const b = i.structurePool.getPool(); let M = f.layer; for (let A = 0; A < b.length; A++) { const D = b[A]; if (D.active) { let B = !1, T = !1; for (let C = 0; C < D.stairs.length; C++) { const R = D.stairs[C]; if (!(R != null && R.lootOnly) && U.intersectSegment(R == null ? void 0 : R.collision, f.pos, x)) { B = !0; break } } for (let C = 0; C < D.mask.length; C++) if (U.intersectSegment(D.mask[C], f.pos, x)) { T = !0; break } B && !T && (M |= 2) } } M != f.layer && (f.layer = M, m.addPIXIObj(f.container, f.layer, 20)) }(v || _.eqAbs(w, g)) && (f.collided = !0, f.alive = !1), f.isNew = !1 } } } createBulletHit(e, t, i) { const r = e.getPlayerById(t); r && i.playGroup("player_bullet_hit", { soundPos: r.pos, fallOff: 1, layer: r.layer, filter: "muffled" }) } render(e, t) { e.pixels(1); for (let i = 0; i < this.bullets.length; i++) { const r = this.bullets[i]; if (r.alive || r.collided) { const a = h.length(h.sub(r.pos, r.startPos)), m = e.pointToScreen(r.pos); r.container.position.set(m.x, m.y); const o = e.pixels(1), n = _.min(r.tracerLength * 15, a / 2); r.container.scale.set(o * n * r.scale, o) } } } } function Ra() { const u = { fontFamily: "Arial", fontWeight: "bold", fontSize: P.pixelRatio > 1 ? 30 : 24, align: "center", fill: 16777215, stroke: 0, strokeThickness: 0, dropShadow: !0, dropShadowColor: "#000000", dropShadowBlur: 1, dropShadowAngle: Math.PI / 3, dropShadowDistance: 1 }, e = new Ye("", u); return e.anchor.set(.5, .5), e.scale.set(.5, .5), e } class Oa { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active", !1); s(this, "pos", h.create(0, 0)); s(this, "container", new ie); s(this, "sprite", re.from("skull.img")); s(this, "nameText", Ra()); s(this, "nameTextSet"); s(this, "layer"); s(this, "playerId"); this.container.addChild(this.sprite), this.sprite.anchor.set(.5, .5), this.sprite.scale.set(.4, .4), this.sprite.tint = 5921370, this.nameText.anchor.set(.5, -1), this.nameText.tint = y.rgbToInt(y.hsvToRgb(0, 0, .5)), this.container.addChild(this.nameText), this.container.visible = this.sprite } init() {} free() { this.container.visible = !1 } updateData(e, t, i, r) { this.pos = h.copy(e.pos), t && (this.layer = e.layer, this.playerId = e.playerId), i && (this.nameTextSet = !1, this.container.visible = !0) } } class Na { constructor() { s(this, "deadBodyPool", new _e(Oa)) } update(e, t, i, r, a, m) { const o = this.deadBodyPool.getPool(); for (let n = 0; n < o.length; n++) { const p = o[n]; if (p.active) { p.nameTextSet || (p.nameText.text = t.getPlayerName(p.playerId, i.__id, !1), p.nameTextSet = !0); const d = U.createCircle(p.pos, 1), f = r.insideStructureStairs(d); let w = p.layer, g = 12; p.layer == 0 && i.layer == 0 && f && (w |= 2, g += 100), m.addPIXIObj(p.container, w, g, p.__id); const x = a.pointToScreen(p.pos), S = a.pixels(1); p.container.position.set(x.x, x.y), p.container.scale.set(S, S) } } } getDeadBodyById(e) { const t = this.deadBodyPool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.active && r.playerId == e) return r } return null } } function wt(u, e, t) { return u == 0 ? e : u == 1 ? t : y.lerpColor(u, e, t) } class Fa { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "decalRender", null); s(this, "isNew"); s(this, "goreT"); s(this, "hasGore"); s(this, "type"); s(this, "pos"); s(this, "rot"); s(this, "scale"); s(this, "layer"); s(this, "goreKills"); s(this, "collider"); s(this, "surface") } init() { this.isNew = !1, this.goreT = 0 } free() { this.decalRender && (this.decalRender.free(), this.decalRender = null) } updateData(e, t, i, r) { if (t) { const a = oe[e.type]; this.type = e.type, this.pos = h.copy(e.pos), this.rot = _.oriToRad(e.ori), this.scale = e.scale, this.layer = e.layer, this.goreKills = e.goreKills, this.collider = U.transform(a.collision, this.pos, this.rot, this.scale), this.surface = a.surface ? y.cloneDeep(a.surface) : null, this.hasGore = a.gore !== void 0, this.isNew = i, this.isNew && (this.decalRender = r.decalBarn.allocDecalRender(), this.decalRender.init(this, r.map, r.renderer)) } } update(e, t) { var i, r, a, m, o, n, p, d, f, w; if (this.hasGore) { const g = oe[this.type]; let x = _.delerp(this.goreKills, (i = g.gore) == null ? void 0 : i.fade.start, (r = g.gore) == null ? void 0 : r.fade.end); if (x = Math.pow(x, (a = g.gore) == null ? void 0 : a.fade.pow), this.goreT = this.isNew ? x : _.lerp(e * ((m = g.gore) == null ? void 0 : m.fade.speed), this.goreT, x), ((o = g.gore) == null ? void 0 : o.tint) !== void 0) { const S = wt(this.goreT, g.img.tint, g.gore.tint); this.decalRender.setTint(S) }((n = g.gore) == null ? void 0 : n.alpha) !== void 0 && (this.decalRender.spriteAlpha = _.lerp(this.goreT, g.img.alpha, g.gore.alpha)), ((p = g.gore) == null ? void 0 : p.waterColor) !== void 0 && this.surface && (this.surface.data.waterColor = wt(this.goreT, (d = g.surface) == null ? void 0 : d.data.waterColor, g.gore.waterColor)), ((f = g.gore) == null ? void 0 : f.rippleColor) !== void 0 && this.surface && (this.surface.data.rippleColor = wt(this.goreT, (w = g.surface) == null ? void 0 : w.data.rippleColor, g.gore.rippleColor)) } this.isNew = !1 } } class ja { constructor() { s(this, "sprite", new re); s(this, "pos"); s(this, "rot"); s(this, "scale"); s(this, "layer"); s(this, "zIdx"); s(this, "zOrd"); s(this, "imgScale"); s(this, "spriteAlpha"); s(this, "valueAdjust"); s(this, "inWater"); s(this, "flicker"); s(this, "flickerMin"); s(this, "flickerMax"); s(this, "flickerTarget"); s(this, "flickerRate"); s(this, "flickerCooldown"); s(this, "active"); s(this, "deactivated"); s(this, "fadeout"); s(this, "fadeAlpha"); this.sprite.anchor.set(.5, .5), this.sprite.visible = !1 } init(e, t, i) { const r = oe[e.type]; this.pos = h.copy(e.pos), this.rot = e.rot, this.scale = e.scale, this.layer = e.layer, this.zIdx = r.img.zIdx, this.zOrd = e.__id; const a = r.img; if (this.sprite.texture = X.from(a.sprite), this.sprite.alpha = 1, this.sprite.visible = !0, this.imgScale = r.img.scale, this.spriteAlpha = a.alpha, this.valueAdjust = a.ignoreAdjust ? 1 : t.getMapDef().biome.valueAdjust, this.setTint(a.tint), this.inWater = !1, r.height < .25) { const m = t.getGroundSurface(e.pos, e.layer); this.inWater = m.type == "water" } this.flicker = r.img.flicker, this.flicker && (this.flickerMin = r.img.flickerMin, this.flickerMax = r.img.flickerMax, this.flickerTarget = this.imgScale, this.flickerRate = r.img.flickerRate, this.flickerCooldown = 0), this.active = !0, this.deactivated = !1, this.fadeout = r.lifetime !== void 0, this.fadeAlpha = 1 } free() { this.deactivated = !0 } setTint(e) { this.valueAdjust < 1 && (e = y.adjustValue(e, this.valueAdjust)), this.sprite.tint = e } update(e, t, i) { this.deactivated && this.fadeout && (this.fadeAlpha = _.lerp(e * 3, this.fadeAlpha, 0), this.fadeAlpha < .01 && (this.fadeAlpha = 0)), this.deactivated && (!this.fadeout || _.eqAbs(this.fadeAlpha, 0)) && (this.sprite.visible = !1, this.active = !1), this.flicker && (this.flickerCooldown < 0 ? (this.flickerTarget = y.random(this.flickerMin, this.flickerMax), this.flickerCooldown = y.random(.05, this.flickerRate)) : (this.imgScale = _.lerp(this.flickerRate - this.flickerCooldown, this.imgScale, this.flickerTarget), this.flickerCooldown -= e)); const r = t.pointToScreen(this.pos), a = t.pixels(this.scale * this.imgScale); this.sprite.position.set(r.x, r.y), this.sprite.scale.set(a, a), this.sprite.rotation = -this.rot, this.sprite.alpha = this.spriteAlpha * (this.inWater ? .3 : 1) * this.fadeAlpha, i.addPIXIObj(this.sprite, this.layer, this.zIdx, this.zOrd) } } class Ki { constructor() { s(this, "decalPool", new _e(Fa)); s(this, "decalRenders", []) } allocDecalRender() { let e = null; for (let t = 0; t < this.decalRenders.length; t++) { const i = this.decalRenders[t]; if (!i.active) { e = i; break } } return e || (e = new ja, this.decalRenders.push(e)), e } update(e, t, i, r) { const a = this.decalPool.getPool(); for (let m = 0; m < a.length; m++) { const o = a[m]; o.active && o.update(e) } for (let m = 0; m < this.decalRenders.length; m++) { const o = this.decalRenders[m]; o.active && o.update(e, t, i) } } render(e, t, i) {} } class qa { constructor() { s(this, "active"); s(this, "pos"); s(this, "vel"); s(this, "layer"); s(this, "particle"); s(this, "ticker"); s(this, "colCount"); this.active = !1 } init(e, t, i, r) { this.pos = h.copy(e), this.vel = h.copy(t), this.layer = i, this.particle = r, this.ticker = 0, this.colCount = 0, this.active = !0 } update(e, t, i) { const r = h.copy(this.pos); this.pos = h.add(this.pos, h.mul(this.vel, e)), this.vel = h.mul(this.vel, 1 / (1 + e * 5)); const a = [], m = t.obstaclePool.getPool(); for (let p = 0; p < m.length; p++) { const d = m[p]; d.active && !d.dead && y.sameLayer(this.layer, d.layer) && a.push(d.collider) } const o = i.playerPool.getPool(); for (let p = 0; p < o.length; p++) { const d = o[p]; d.active && !d.dead && y.sameLayer(this.layer, d.layer) && a.push(U.createCircle(d.pos, d.rad, 0)) } const n = []; for (let p = 0; p < a.length; p++) { const d = U.intersectSegment(a[p], r, this.pos); if (d) { const f = h.length(h.sub(d.point, r)); n.push({ point: d.point, normal: d.normal, dist: f }) } } if (n.sort((p, d) => p.dist - d.dist), n.length > 0) { const p = n[0], d = h.normalizeSafe(this.vel, h.create(1, 0)), f = h.length(this.vel), w = h.sub(d, h.mul(p.normal, h.dot(p.normal, d) * 2)), g = this.colCount++ > 0 ? .35 : 1; this.pos = h.add(p.point, h.mul(p.normal, .01)), this.vel = h.mul(w, f * g) } this.particle.pos = h.copy(this.pos), this.ticker += e, this.ticker >= this.particle.life && (this.particle.free(), this.active = !1) } } class Va { constructor(e) { s(this, "active"); s(this, "type"); s(this, "done"); s(this, "pos"); s(this, "layer"); s(this, "ticker"); s(this, "lifetime"); s(this, "soundInstance"); s(this, "soundUpdateThrottle"); this.active = !1 } init(e, t, i) { const r = Ut[e].explosionEffectType, a = ni[r]; this.active = !0, this.done = !1, this.type = e, this.pos = h.copy(t), this.layer = i, this.ticker = 0, this.lifetime = a.lifetime, this.soundInstance = null, this.soundUpdateThrottle = 0 } free() { this.active = !1 } update(e, t, i, r, a, m) { const o = Ut[this.type].explosionEffectType, n = ni[o]; if (this.ticker == 0) { let f = !0; if (this.type == "explosion_bomb_iron") { const z = U.createCircle(this.pos, .5); a.insideBuildingCeiling(z, !0) && (f = !1) } if (f && (n.burst.particle && i.addParticle(n.burst.particle, this.layer, this.pos, h.create(0, 0), n.burst.scale, 0, null), n.scatter)) for (let z = 0; z < n.scatter.count; z++) { const I = i.addParticle(n.scatter.particle, this.layer, this.pos, h.create(0, 0), 1, 0, null), k = t.addPhysicsParticle(), v = h.mul(h.randomUnit(), y.random(n.scatter.speed.min, n.scatter.speed.max)); k.init(this.pos, v, this.layer, I) } const w = a.getGroundSurface(this.pos, this.layer), g = w.type == "water" ? n.burst.sound.water : n.burst.sound.grass; let x = 0; n.burst.sound.detune != null && (x = n.burst.sound.detune); let S = 1; if (n.burst.sound.volume != null && (S = n.burst.sound.volume), this.soundInstance = r.playSound(g, { channel: "sfx", soundPos: this.pos, layer: this.layer, filter: "muffled", rangeMult: 2, ignoreMinAllowable: !0, detune: x, volumeScale: S }), w.type == "water") for (let z = 0; z < n.rippleCount; z++) { const I = n.rippleCount * .5, k = h.add(this.pos, h.mul(h.randomUnit(), y.random(0, I))); i.addRippleParticle(k, this.layer, w.data.rippleColor).setDelay(z * .06) } } if (this.soundInstance && this.soundUpdateThrottle < 0) { this.soundUpdateThrottle = .1; let f = 1; n.burst.sound.volume != null && (f = n.burst.sound.volume), r.updateSound(this.soundInstance, "sfx", this.pos, { layer: this.layer, filter: "muffled", volumeScale: f }) } else this.soundUpdateThrottle -= e; this.ticker += e; const p = _.min(this.ticker / n.shakeDur, 1), d = _.lerp(p, n.shakeStr, 0); m.addShake(this.pos, d), this.ticker >= this.lifetime && (this.active = !1) } } class Wa { constructor() { s(this, "explosions"); s(this, "physicsParticles"); this.explosions = [], this.physicsParticles = [] } addExplosion(e, t, i) { let r = null; for (let a = 0; a < this.explosions.length; a++) if (!this.explosions[a].active) { r = this.explosions[a]; break } r || (r = new Va(this), this.explosions.push(r)), r.init(e, t, i) } addPhysicsParticle() { let e = null; for (let t = 0; t < this.physicsParticles.length; t++) { const i = this.physicsParticles[t]; if (!i.active) { e = i; break } } return e || (e = new qa, this.physicsParticles.push(e)), e } update(e, t, i, r, a, m, o) { for (let n = 0; n < this.explosions.length; n++) { const p = this.explosions[n]; p.active && (p.update(e, this, a, m, t, r), p.active || p.free()) } for (let n = 0; n < this.physicsParticles.length; n++) { const p = this.physicsParticles[n]; p.active && p.update(e, t, i) } } } const ni = { frag: { burst: { particle: "explosionBurst", scale: 1, sound: { grass: "explosion_01", water: "explosion_02" } }, rippleCount: 10, shakeStr: .2, shakeDur: .35, lifetime: 2 }, smoke: { burst: { particle: "explosionBurst", scale: 0, sound: { grass: "explosion_smoke_01", water: "explosion_smoke_01" } }, rippleCount: 10, shakeStr: 0, shakeDur: 0, lifetime: 6 }, strobe: { burst: { particle: "explosionBurst", scale: .25, sound: { grass: "explosion_04", water: "explosion_02" } }, rippleCount: 3, shakeStr: 0, shakeDur: 0, lifetime: 2 }, barrel: { burst: { particle: "explosionBurst", scale: 1, sound: { grass: "explosion_01", water: "explosion_02" } }, rippleCount: 10, shakeStr: .2, shakeDur: .35, lifetime: 2 }, usas: { burst: { particle: "explosionUSAS", scale: .75, sound: { grass: "explosion_03", water: "explosion_02" } }, rippleCount: 10, shakeStr: .12, shakeDur: .25, lifetime: 1.25 }, rounds: { burst: { particle: "explosionRounds", scale: .32, sound: { grass: "explosion_04", water: "explosion_04", detune: 500, volume: .5 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, rounds_sg: { burst: { particle: "explosionRounds", scale: .32, sound: { grass: "explosion_04", water: "explosion_04", detune: 500, volume: .2 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, mirv: { burst: { particle: "explosionMIRV", scale: 1, sound: { grass: "explosion_01", water: "explosion_02" } }, rippleCount: 10, shakeStr: .2, shakeDur: .35, lifetime: 2 }, mirv_mini: { burst: { particle: "explosionMIRV", scale: .75, sound: { grass: "explosion_03", water: "explosion_02" } }, rippleCount: 3, shakeStr: .1, shakeDur: .2, lifetime: 1.25 }, martyr_nade: { burst: { particle: "explosionBurst", scale: .75, sound: { grass: "explosion_03", water: "explosion_02" } }, rippleCount: 3, shakeStr: .1, shakeDur: .2, lifetime: 1.25 }, snowball: { burst: { particle: "", scale: .75, sound: { grass: "snowball_01", water: "frag_water_01" } }, scatter: { particle: "snowball_impact", count: 5, speed: { min: 5, max: 25 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, snowball_heavy: { burst: { particle: "", scale: .75, sound: { grass: "snowball_02", water: "frag_water_01" } }, scatter: { particle: "snowball_impact", count: 8, speed: { min: 5, max: 25 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, potato: { burst: { particle: "", scale: .75, sound: { grass: "potato_01", water: "frag_water_01" } }, scatter: { particle: "potato_impact", count: 5, speed: { min: 5, max: 25 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, potato_heavy: { burst: { particle: "", scale: .75, sound: { grass: "potato_02", water: "frag_water_01" } }, scatter: { particle: "potato_impact", count: 8, speed: { min: 5, max: 25 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: 1 }, potato_cannonball: { burst: { particle: "explosionPotato", scale: .75, sound: { grass: "explosion_05", water: "explosion_02" } }, scatter: { particle: "potato_impact", count: 8, speed: { min: 5, max: 25 } }, rippleCount: 10, shakeStr: .12, shakeDur: .25, lifetime: 1.25 }, potato_smgshot: { burst: { particle: "", scale: .2, sound: { grass: "potato_01", water: "potato_02", detune: 250, volume: .5 } }, scatter: { particle: "potato_smg_impact", count: 2, speed: { min: 5, max: 25 } }, rippleCount: 1, shakeStr: 0, shakeDur: 0, lifetime: .5 }, bomb_iron: { burst: { particle: "explosionBomb", scale: 2, sound: { grass: "explosion_01", water: "explosion_02" } }, rippleCount: 12, shakeStr: .25, shakeDur: .4, lifetime: 2 } }; class Ua { constructor() { s(this, "bullets", []) } addFlare(e, t, i) { let r = null; for (let g = 0; g < this.bullets.length; g++) if (!this.bullets[g].alive && !this.bullets[g].collided) { r = this.bullets[g]; break } r || (r = {}, r.alive = !1, r.flareContainer = new ie, r.flareContainer.visible = !1, r.flare = re.from("part-flare-01.img"), r.flare.anchor.set(.5, .5), r.flareContainer.addChild(r.flare), r.trailContainer = new ie, r.trailContainer.visible = !1, r.trailContainer.pivot.set(14.5, 0), r.bulletTrail = re.from("player-bullet-trail-02.img"), r.bulletTrail.anchor.set(.5, .5), r.trailContainer.addChild(r.bulletTrail), this.bullets.push(r)); const a = ht[e.bulletType], m = 1 + e.varianceT * a.variance, o = _.remap(e.distAdjIdx, 0, 32, -1, 1), n = a.distance / Math.pow(N.bullet.reflectDistDecay, e.reflectCount); r.alive = !0, r.isNew = !0, r.collided = !1, r.flareScale = .01, r.trailScale = 1, r.timeAlive = 0, r.maxTimeAlive = 2.5, r.startPos = h.copy(e.pos), r.pos = h.copy(e.pos), r.dir = h.copy(e.dir), r.layer = e.layer, r.speed = a.speed * m, r.distance = n * m + o; const p = Math.atan2(r.dir.x, r.dir.y); r.flareContainer.rotation = p - Math.PI / 2, r.trailContainer.rotation = p - Math.PI / 2, r.layer = e.layer; const d = t.getPlayerById(r.playerId); d && d.layer & 2 && (r.layer |= 2); const f = N.tracerColors[a.tracerColor]; let w = f.regular; d != null && d.isOnBrightSurface && (w = f.saturated), r.bulletTrail.scale.set(.8, a.tracerWidth), r.tracerLength = a.tracerLength, r.bulletTrail.tint = w, r.tracerAlphaRate = f.alphaRate, r.tracerAlphaMin = f.alphaMin, r.bulletTrail.alpha = 1, r.flare.scale.set(1, 1), r.flare.tint = a.flareColor, r.flare.alpha = .8, r.maxFlareScale = a.maxFlareScale, r.smokeThrottle = 0, r.flareContainer.visible = !0, r.trailContainer.visible = !0 } update(e, t, i, r, a, m, o, n) { for (let p = 0; p < this.bullets.length; p++) { const d = this.bullets[p]; if (d.collided && (d.flareScale = _.max(d.flareScale - e * .5, 0), d.flare.alpha = _.max(d.flare.alpha - e, 0), d.trailScale = _.max(d.trailScale - e * 6, 0), d.bulletTrail.alpha = _.max(d.bulletTrail.alpha - e, 0), d.pos = h.add(d.pos, h.mul(d.dir, e * d.speed)), d.flare.alpha <= 0 && (d.collided = !1, d.flareContainer.visible = !1, d.trailContainer.visible = !1)), d.alive) { if (d.tracerAlphaRate) { const x = a.__id == d.playerId ? d.tracerAlphaRate : d.tracerAlphaRate * .9; d.bulletTrail.alpha = _.max(d.tracerAlphaMin, d.bulletTrail.alpha * x) } d.timeAlive += e, d.flareScale = _.easeOutExpo(d.timeAlive / d.maxTimeAlive) * (d == null ? void 0 : d.maxFlareScale), d.smokeThrottle <= 0 ? d.smokeThrottle = .05 : d.smokeThrottle -= e; const f = d.distance - h.length(h.sub(d.startPos, d.pos)), w = _.min(f, e * d.speed); d.pos = h.add(d.pos, h.mul(d.dir, w)), _.eqAbs(f, w) && (d.collided = !0, d.alive = !1); let g = 0; (y.sameLayer(g, a.layer) || a.layer & 2) && (!(a.layer & 2) || !i.insideStructureMask(U.createCircle(d.pos, 1))) && (g |= 2), m.addPIXIObj(d.trailContainer, g, 1e3, 0), m.addPIXIObj(d.flareContainer, g, 1e3, 1), d.isNew = !1 } } } render(e) { for (let t = 0; t < this.bullets.length; t++) { const i = this.bullets[t]; if (i.alive || i.collided) { const r = e.pointToScreen(i.pos); i.flareContainer.position.set(r.x, r.y); const a = e.pixels(1); i.flareContainer.scale.set(a * i.flareScale, a * i.flareScale); const m = h.length(h.sub(i.pos, i.startPos)); i.trailContainer.position.set(r.x, r.y); const o = _.min(i.tracerLength * 15, m / 2); i.trailContainer.scale.set(a * o * i.trailScale, a) } } } } class Ga { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "ticker", 0); s(this, "playDropSfx", !1); s(this, "container", new re); s(this, "sprite", new re); s(this, "emitter", null); s(this, "updatedData"); s(this, "pos"); s(this, "isOld"); s(this, "layer"); s(this, "type"); s(this, "count"); s(this, "isPreloadedGun"); s(this, "ownerId"); s(this, "rad"); s(this, "imgScale"); this.container.anchor.set(.5, .5), this.container.scale.set(1, 1), this.sprite.anchor.set(.5, .5), this.sprite.scale.set(.8, .8), this.container.addChild(this.sprite) } init() { this.updatedData = !1 } free() { this.container.visible = !1, this.emitter && (this.emitter.stop(), this.emitter = null) } updateData(e, t, i, r) { var a, m, o, n; if (this.updatedData = !0, this.pos = h.copy(e.pos), t && (this.layer = e.layer, this.type = e.type, this.count = e.count, this.isOld = e.isOld, this.isPreloadedGun = e.isPreloadedGun, this.ownerId = e.hasOwner ? e.ownerId : 0), i) { const p = F[this.type]; this.ticker = 0, this.isOld && (this.ticker = 10), !this.isOld && p.sound.drop && !r.map.lootDropSfxIds.includes(this.__id) && (this.playDropSfx = !0), this.rad = N.lootRadius[p.type], this.imgScale = ((a = p.lootImg) == null ? void 0 : a.scale) * 1.25; const d = p.lootImg.innerScale || .8; this.sprite.scale.set(d, d), this.sprite.texture = X.from((m = p.lootImg) == null ? void 0 : m.sprite), this.sprite.tint = (o = p.lootImg) == null ? void 0 : o.tint, this.container.texture = p.lootImg.border ? X.from(p.lootImg.border) : X.EMPTY, this.isPreloadedGun && (this.container.texture = X.from("loot-circle-outer-06.img")); const f = F[p.ammo]; f ? this.container.tint = f.lootImg.tintDark : p.lootImg.borderTint ? this.container.tint = p.lootImg.borderTint : this.container.tint = 0, p.type == "xp" && p.emitter && (this.emitter = r.particleBarn.addEmitter(p.emitter, { pos: this.pos, layer: this.layer })), this.sprite.rotation = (n = p == null ? void 0 : p.lootImg) != null && n.rot ? p.lootImg.rot : 0, this.sprite.scale.x = p.lootImg.mirror ? -d : d, this.container.visible = !0 }(i || t) && r.renderer.addPIXIObj(this.container, this.layer, 13, this.__id) } } class $a { constructor() { s(this, "lootPool", new _e(Ga)); s(this, "closestLoot", null) } update(e, t, i, r, a, m) { var p; this.closestLoot = null; let o = Number.MAX_VALUE; const n = this.lootPool.getPool(); for (let d = 0; d < n.length; d++) { const f = n[d]; if (f.active) { if (y.sameLayer(f.layer, t.layer) && !t.netData.dead && (f.ownerId == 0 || f.ownerId == t.__id)) { const z = f.pos, I = P.touch ? t.rad + f.rad * N.player.touchLootRadMult : f.rad, k = h.sub(t.pos, z), v = h.lengthSqr(k); v < I * I && v < o && (o = v, this.closestLoot = f) } if (f.ticker += e, f.playDropSfx) { i.lootDropSfxIds.push(f.__id), f.playDropSfx = !1; const z = F[f.type]; r.playSound((p = z.sound) == null ? void 0 : p.drop, { channel: "sfx", soundPos: f.pos, layer: f.layer, filter: "muffled" }) } f.emitter && (f.emitter.pos = h.add(f.pos, h.create(0, .1)), f.emitter.layer = f.layer); const w = _.delerp(f.ticker, 0, 1), g = _.easeOutElastic(w, .75), x = a.pointToScreen(f.pos), S = a.pixels(f.imgScale * g); P.debug && m.loot && t.layer === f.layer && de.addCircle(f.pos, f.rad, 16711680, 0), f.container.position.set(x.x, x.y), f.container.scale.set(S, S) } } } getClosestLoot() { return this.closestLoot } } class l { constructor(e, t) { this.min = e, this.max = t } getRandom() { return y.random(this.min, this.max) } } function xe(u) { return u instanceof l ? u.getRandom() : u } function Ha(u) { return u instanceof Function ? u() : u } class hi { constructor() { s(this, "active", !1); s(this, "ticker", 0); s(this, "def", {}); s(this, "sprite", new re); s(this, "hasParent", !1); s(this, "pos"); s(this, "vel"); s(this, "rot"); s(this, "delay"); s(this, "life"); s(this, "drag"); s(this, "rotVel"); s(this, "rotDrag"); s(this, "scaleUseExp"); s(this, "scale"); s(this, "scaleEnd"); s(this, "scaleExp"); s(this, "alphaUseExp"); s(this, "alpha"); s(this, "alphaEnd"); s(this, "alphaExp"); s(this, "alphaIn"); s(this, "alphaInStart"); s(this, "alphaInEnd"); s(this, "emitterIdx"); s(this, "valueAdjust"); this.sprite.anchor.set(.5, .5), this.sprite.scale.set(1, 1), this.sprite.visible = !1 } init(e, t, i, r, a, m, o, n, p, d) { var g, x, S, z; const f = Rt[t]; this.active = !0, this.ticker = 0, n ? (this.hasParent = !0, n.addChild(this.sprite)) : (this.hasParent = !1, e.addPIXIObj(this.sprite, i, p)), this.pos = h.copy(r), this.vel = h.copy(a), this.rot = o, this.def = f, this.delay = 0, this.life = xe(f.life), this.drag = xe(f.drag), this.rotVel = xe(f.rotVel) * (Math.random() < .5 ? -1 : 1), this.rotDrag = xe(f.drag) / 2, this.scaleUseExp = f.scale.exp !== void 0, this.scale = xe(f.scale.start) * m, this.scaleEnd = this.scaleUseExp ? 0 : xe((g = f.scale) == null ? void 0 : g.end) * m, this.scaleExp = this.scaleUseExp ? f.scale.exp : 0, this.alphaUseExp = f.alpha.exp !== void 0, this.alpha = xe(f.alpha.start), this.alphaEnd = this.alphaUseExp ? 0 : xe((x = f.alpha) == null ? void 0 : x.end), this.alphaExp = this.alphaUseExp ? f.alpha.exp : 0, this.alphaIn = f.alphaIn !== void 0, this.alphaInStart = this.alphaIn ? xe((S = f.alphaIn) == null ? void 0 : S.start) : 0, this.alphaInEnd = this.alphaIn ? xe((z = f.alphaIn) == null ? void 0 : z.end) : 0, this.emitterIdx = -1; const w = Array.isArray(f.image) ? f.image[Math.floor(Math.random() * f.image.length)] : f.image; this.sprite.texture = X.from(w), this.sprite.visible = !1, this.valueAdjust = f.ignoreValueAdjust ? 1 : d, this.setColor(Ha(f.color)) } free() { this.active = !1, this.sprite.visible = !1 } setDelay(e) { this.delay = e } setColor(e) { this.valueAdjust < 1 && (e = y.adjustValue(e, this.valueAdjust)), this.sprite.tint = e } } class Xa { constructor() { s(this, "active", !1); s(this, "enabled"); s(this, "type"); s(this, "pos"); s(this, "dir"); s(this, "scale"); s(this, "layer"); s(this, "duration"); s(this, "radius"); s(this, "ticker"); s(this, "nextSpawn"); s(this, "spawnCount"); s(this, "parent"); s(this, "alpha"); s(this, "rateMult"); s(this, "zOrd") } init(e, t = {}) { const i = Qi[e]; this.active = !0, this.enabled = !0, this.type = e, this.pos = t.pos ? h.copy(t.pos) : h.create(0, 0), this.dir = t.dir ? h.copy(t.dir) : h.create(0, 1), this.scale = t.scale !== void 0 ? t.scale : 1, this.layer = t.layer || 0, this.duration = t.duration !== void 0 ? t.duration : Number.MAX_VALUE, this.radius = t.radius !== void 0 ? t.radius : i.radius, this.ticker = 0, this.nextSpawn = 0, this.spawnCount = 0, this.parent = t.parent || null, this.alpha = 1, this.rateMult = t.rateMult !== void 0 ? t.rateMult : 1; const r = Rt[i.particle]; this.zOrd = i.zOrd !== void 0 ? i.zOrd : r.zOrd !== void 0 ? r.zOrd : 20 } free() { this.active = !1 } stop() { this.duration = this.ticker } } class Yi { constructor(e) { s(this, "particles", []); s(this, "emitters", []); s(this, "valueAdjust", 1); this.renderer = e; for (let t = 0; t < 256; t++) this.particles[t] = new hi } onMapLoad(e) { this.valueAdjust = e.getMapDef().biome.valueAdjust } free() { var e; for (let t = 0; t < this.particles.length; t++) { const i = this.particles[t].sprite; (e = i.parent) == null || e.removeChild(i), i.destroy({ children: !0 }) } } addParticle(e, t, i, r, a, m, o, n) { let p = null; for (let d = 0; d < this.particles.length; d++) if (!this.particles[d].active) { p = this.particles[d]; break } return p || (p = new hi, this.particles.push(p)), a = a !== void 0 ? a : 1, m = m !== void 0 ? m : Math.random() * Math.PI * 2, n = n !== void 0 ? n : Rt[e].zOrd || 20, p.init(this.renderer, e, t, i, r, a, m, o, n, this.valueAdjust), p } addRippleParticle(e, t, i) { const r = this.addParticle("waterRipple", t, e, h.create(0, 0), 1, 0, null); return r.setColor(i), r } addEmitter(e, t = {}) { let i = null; for (let r = 0; r < this.emitters.length; r++) if (!this.emitters[r].active) { i = this.emitters[r]; break } return i || (i = new Xa, this.emitters.push(i)), i.init(e, t), i } update(e, t, i) { var r, a, m, o, n, p, d, f, w, g; for (let x = 0; x < this.emitters.length; x++) { const S = this.emitters[x]; if (S.active && S.enabled) { S.ticker += e, S.nextSpawn -= e; const z = Qi[S.type]; for (; S.nextSpawn <= 0 && S.spawnCount < z.maxCount;) { const I = S.scale * S.radius, k = h.add(S.pos, y.randomPointInCircle(I)), v = h.rotate(S.dir, (Math.random() - .5) * z.angle), b = h.mul(v, xe(z.speed)), M = xe(z.rot), A = this.addParticle(z.particle, S.layer, k, b, S.scale, M, S.parent, S.zOrd); A.emitterIdx = x; let D = xe(z.rate); if (z.maxRate) { const B = _.easeInExpo(_.min(1, S.ticker / z.maxElapsed)), T = xe(z.maxRate); D = _.lerp(B, D, T) } S.nextSpawn += D * S.rateMult, S.spawnCount++ } S.ticker >= S.duration && S.free() } } for (let x = 0; x < this.particles.length; x++) { const S = this.particles[x]; if (S.active && (S.ticker += e, S.ticker >= S.delay)) { const z = _.min((S.ticker - S.delay) / S.life, 1); S.vel = h.mul(S.vel, 1 / (1 + e * S.drag)), S.pos = h.add(S.pos, h.mul(S.vel, e)), S.rotVel *= 1 / (1 + e * S.rotDrag), S.rot += S.rotVel * e, S.scaleUseExp && (S.scale += e * S.scaleExp), S.alphaUseExp && (S.alpha = _.max(S.alpha + e * S.alphaExp, 0)); const I = S.hasParent ? S.pos : t.pointToScreen(S.pos); let k = S.scaleUseExp ? S.scale : _.remap(z, (r = S.def.scale.lerp) == null ? void 0 : r.min, (a = S.def.scale.lerp) == null ? void 0 : a.max, S.scale, S.scaleEnd), v = S.alphaUseExp ? S.alpha : _.remap(z, (m = S.def.alpha.lerp) == null ? void 0 : m.min, (o = S.def.alpha.lerp) == null ? void 0 : o.max, S.alpha, S.alphaEnd); S.alphaIn && z < ((p = (n = S.def.alphaIn) == null ? void 0 : n.lerp) == null ? void 0 : p.max) && (v = _.remap(z, (f = (d = S.def.alphaIn) == null ? void 0 : d.lerp) == null ? void 0 : f.min, (g = (w = S.def.alphaIn) == null ? void 0 : w.lerp) == null ? void 0 : g.max, S.alphaInStart, S.alphaInEnd)), S.emitterIdx >= 0 && (v *= this.emitters[S.emitterIdx].alpha), S.hasParent || (k = t.pixels(k)), S.sprite.position.set(I.x, I.y), S.sprite.scale.set(k, k), S.sprite.rotation = S.rot, S.sprite.alpha = v, S.sprite.visible = !0, z >= 1 && S.free() } } } } const Rt = { archwayBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.2, .35), end: new l(.08, .12), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.06, .84, y.random(.46, .48))) } }, bloodSplat: { image: ["part-splat-01.img", "part-splat-02.img", "part-splat-03.img"], life: .5, drag: 1, rotVel: 0, scale: { start: .04, end: new l(.15, .2), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(16711680, 1, y.random(.45, .8))) } }, barrelPlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(3, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.08, .18), end: new l(.07, .17), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.09, .8, y.random(.66, .68))) } }, barrelChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.01, .02, y.random(.38, .41))) } }, barrelBreak: { image: ["part-spark-02.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.01, .02, y.random(.38, .41))) } }, blackChip: { image: ["part-woodchip-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, .08, y.random(.16, .18))) } }, blueChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.64, 1, y.random(.83, .85))) } }, book: { image: ["part-book-01.img"], life: new l(1, 1.5), drag: new l(3, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.09, .19), end: new l(.07, .17), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, .42, y.random(.72, .74))) } }, bottleBrownChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 5), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.02, .04), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: 7878664 }, bottleBrownBreak: { image: ["part-spark-02.img"], life: new l(.4, .8), drag: new l(1, 4), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.03, .06), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: .8, end: 0, lerp: new l(.75, 1) }, color: 7878664 }, bottleBlueChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 5), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.02, .04), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: 19544 }, bottleWhiteBreak: { image: ["part-spark-02.img"], life: new l(.4, .8), drag: new l(1, 4), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.03, .06), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: .75, end: 0, lerp: new l(.75, 1) }, color: 16777215 }, bottleWhiteChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 5), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.02, .04), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: .75, end: 0, lerp: new l(.95, 1) }, color: 16777215 }, bottleBlueBreak: { image: ["part-spark-02.img"], life: new l(.4, .8), drag: new l(1, 4), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.03, .06), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: .8, end: 0, lerp: new l(.75, 1) }, color: 19544 }, brickChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, .71, y.random(.32, .34))) } }, clothBreak: { image: ["part-cloth-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.95, 1))) } }, clothHit: { image: ["part-cloth-01.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.95, 1))) } }, depositBoxGreyBreak: { image: ["part-plate-01.img"], life: new l(.5, 1), drag: new l(7, 8), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.15, .25), end: new l(.12, .2), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.36, .38))) } }, depositBoxGoldBreak: { image: ["part-plate-01.img"], life: new l(.5, 1), drag: new l(6, 8), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.2, .35), end: new l(.18, .25), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.11, .84, y.random(.64, .66))) } }, glassChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 5), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: 8444415 }, glassPlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 8444415 }, goldChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.11, .84, y.random(.88, .9))) } }, greenChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.4, .18, y.random(.5, .62))) } }, greenPlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.08, .16), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 3884335 }, greenhouseBreak: { image: ["part-spark-02.img", "part-plate-01.img", "part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: .8, end: 0, lerp: new l(.75, 1) }, color: 8444415 }, hutBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.1, .81, y.random(.78, .82))) } }, leaf: { image: ["part-leaf-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.5, .75))) } }, leafPrickly: { image: ["part-leaf-01sv.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.8, .85))) } }, leafRiver: { image: ["part-leaf-02.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.5, .75))) } }, lockerBreak: { image: ["part-plate-01.img"], life: new l(.5, 1), drag: new l(7, 8), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.15, .2), end: new l(.12, .15), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.1, .23, y.random(.51, .53))) } }, ltgreenChip: { image: ["part-woodchip-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.2, .42, y.random(.38, .42))) } }, outhouseChip: { image: ["part-woodchip-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, .57, y.random(.4, .46))) } }, outhouseBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, .79, y.random(.52, .54))) } }, outhousePlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, .57, y.random(.4, .46))) } }, potChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.06, .84, y.random(.73, .77))) } }, potBreak: { image: ["part-pot-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.06, .84, y.random(.73, .77))) } }, potatoChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.075, .43, y.random(.48, .5))) } }, potatoBreak: { image: ["part-pumpkin-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.075, .43, y.random(.48, .5))) } }, pumpkinChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.07, 1, y.random(.98, 1))) } }, pumpkinBreak: { image: ["part-pumpkin-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, 1, y.random(.95, .97))) } }, squashChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.31, .86, y.random(.35, .36))) } }, squashBreak: { image: ["part-pumpkin-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.31, .86, y.random(.35, .36))) } }, redChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.98, 1, y.random(.52, .54))) } }, redBreak: { image: ["part-spark-02.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.98, 1, y.random(.52, .54))) } }, redPlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.02, 1, y.random(.26, .28))) } }, rockChip: { image: ["map-stone-01.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.5, .75))) } }, rockBreak: { image: ["map-stone-01.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.5, .75))) } }, rockEyeChip: { image: ["map-stone-01.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.03, .06), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: 2696225 }, rockEyeBreak: { image: ["map-stone-01.img"], life: new l(.8, 1), drag: new l(4, 12), rotVel: 0, scale: { start: new l(.05, .1), end: new l(.03, .06), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 2696225 }, shackBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.1, .24, y.random(.38, .41))) } }, shackGreenBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 5730406 }, tanChip: { image: ["part-woodchip-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.1, .35, y.random(.48, .52))) } }, teahouseBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.6, .31, y.random(.42, .45))) } }, teapavilionBreak: { image: ["part-panel-01.img"], life: new l(.5, 1.5), drag: new l(1, 5), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.25, .55), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, .8, y.random(.6, .62))) } }, toiletBreak: { image: ["part-spark-02.img"], life: new l(.8, 1), drag: new l(1, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.97, 0, y.random(.95, .97))) } }, toiletMetalBreak: { image: ["part-spark-02.img"], life: new l(.8, 1), drag: new l(4, 5), rotVel: 0, scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.01, .02, y.random(.38, .41))) } }, turkeyFeathersHit: { image: ["part-feather-01.img", "part-feather-02.img"], life: new l(1, 1.5), drag: new l(1, 10), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .12), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return 16777215 } }, turkeyFeathersDeath: { image: ["part-feather-01.img", "part-feather-02.img"], life: new l(1, 1.5), drag: new l(1, 10), rotVel: new l(0, Math.PI * 3), scale: { start: new l(.15, .25), end: new l(.12, .2), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return 16777215 } }, whiteChip: { image: ["part-spark-02.img"], life: .5, drag: new l(1, 10), rotVel: 0, scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.97, 0, y.random(.95, .97))) } }, whitePlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.97, 0, y.random(.95, .97))) } }, windowBreak: { image: ["part-spark-02.img"], life: new l(.4, .8), drag: new l(1, 4), rotVel: new l(Math.PI * 1, Math.PI * 6), scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: .8, end: 0, lerp: new l(.75, 1) }, color: 8444415 }, woodChip: { image: ["part-woodchip-01.img"], life: new l(.5, 1), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.04, .08), end: new l(.01, .02), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.05, 1, y.random(.35, .45))) } }, woodLog: { image: ["part-log-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.05, 1, y.random(.35, .45))) } }, woodPlank: { image: ["part-plank-01.img"], life: new l(1, 1.5), drag: new l(1, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.1, .2), end: new l(.08, .18), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.05, 1, y.random(.25, .35))) } }, woodShard: { image: ["part-spark-02.img"], life: new l(1, 1.5), drag: new l(3, 5), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: new l(.06, .15), end: new l(.02, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.05, 1, y.random(.25, .35))) } }, "9mm": { image: ["part-shell-01.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .0625, end: .0325, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "9mm_cursed": { image: ["part-shell-01.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .0625, end: .0325, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "762mm": { image: ["part-shell-02.img"], life: new l(.75, 1), drag: new l(1.5, 2.5), rotVel: new l(Math.PI * 2.5, Math.PI * 2.5), scale: { start: .075, end: .045, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.925, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "556mm": { image: ["part-shell-04.img"], life: new l(.75, 1), drag: new l(1.5, 2.5), rotVel: new l(Math.PI * 2.5, Math.PI * 2.5), scale: { start: .075, end: .045, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.925, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "12gauge": { image: ["part-shell-03.img"], life: new l(.5, .75), drag: new l(1, 2), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .1, end: .05, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "50AE": { image: ["part-shell-01.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .0625, end: .0325, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "308sub": { image: ["part-shell-05.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .0625, end: .0325, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, flare: { image: ["part-shell-03.img"], life: new l(.5, .75), drag: new l(1, 2), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .1, end: .05, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, "45acp": { image: ["part-shell-01.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .07, end: .04, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, potato_ammo: { image: ["part-wedge-01.img"], life: new l(.5, .75), drag: new l(3, 4), rotVel: new l(Math.PI * 3, Math.PI * 3), scale: { start: .07, end: .04, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.95, 1) }, color: 16777215 }, bugle_ammo: { image: ["part-note-02.img"], life: new l(1.25, 1.3), drag: new l(3, 4), rotVel: new l(Math.PI * 1, Math.PI * 1), scale: { start: .1, end: .14, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.5, 1) }, color: 16767488 }, fragPin: { image: ["part-frag-pin-01.img"], life: new l(.5, .5), drag: new l(.9, 1), rotVel: 0, scale: { start: .18, end: .14, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.5, 1) }, color: 16777215 }, fragLever: { image: ["part-frag-lever-01.img"], life: new l(.5, .5), drag: new l(.9, 1), rotVel: Math.PI * 9, scale: { start: .18, end: .14, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.5, 1) }, color: 16777215 }, explosionBurst: { image: ["part-frag-burst-01.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.065, 1, y.random(.98, .99))) } }, explosionMIRV: { image: ["part-frag-burst-01.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 1, y.random(.82, .84))) } }, explosionSmoke: { image: ["part-smoke-01.img"], life: new l(2, 3), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, explosionUSAS: { image: ["part-frag-burst-01.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, 1, y.random(.98, .99))) } }, explosionRounds: { image: ["part-frag-burst-03.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(.08, .7, y.random(.75, .8))) } }, explosionBomb: { image: ["part-frag-burst-02.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: 16777215 }, explosionPotato: { image: ["part-frag-burst-01.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: 11363866 }, explosionPotatoSMG: { image: ["part-frag-burst-01.img"], life: .5, drag: 0, rotVel: 0, scale: { start: 1, end: 4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.75, 1) }, color: 12888074 }, airdropSmoke: { image: ["part-smoke-02.img", "part-smoke-03.img"], zOrd: 499, life: new l(1, 1.5), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.67, .72), end: new l(.55, .61), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, airdropCrate01: { image: ["part-airdrop-01.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate01h: { image: ["part-airdrop-01h.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate01x: { image: ["part-airdrop-01x.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate02: { image: ["part-airdrop-02.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate02h: { image: ["part-airdrop-02h.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate02x: { image: ["part-airdrop-02x.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate03: { image: ["part-airdrop-03.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, airdropCrate04: { image: ["part-airdrop-04.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell01a: { image: ["part-class-shell-01a.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell01b: { image: ["part-class-shell-01b.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell02a: { image: ["part-class-shell-02a.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell02b: { image: ["part-class-shell-02b.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell03a: { image: ["part-class-shell-03a.img"], life: new l(.85, 1.15), drag: new l(2, 2.25), rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, classShell03b: { image: ["part-class-shell-03b.img"], life: new l(.85, 1.15), drag: new l(1.85, 2.15), rotVel: new l(0, Math.PI * 2), scale: { start: .5, end: .4, lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16777215 }, cabinSmoke: { image: ["part-smoke-02.img", "part-smoke-03.img"], life: new l(3, 3.25), drag: new l(.2, .22), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.2, .25), end: new l(.6, .65), lerp: new l(0, 1) }, alpha: { start: .7, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: .7, lerp: new l(0, .1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.69, .695))) } }, bathhouseSteam: { image: ["part-smoke-02.img", "part-smoke-03.img"], life: new l(10, 12), drag: new l(.04, .06), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.2, .25), end: new l(.9, .95), lerp: new l(0, 1) }, alpha: { start: .5, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: .5, lerp: new l(0, .1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.99, .995))) } }, bunkerBubbles: { image: ["player-ripple-01.img"], zOrd: 10, life: new l(2.25, 2.5), drag: new l(1.85, 2.15), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.2, .25), end: new l(.65, .7), lerp: new l(0, 1) }, alpha: { start: .25, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.95, 1))) } }, waterRipple: { image: ["player-ripple-01.img"], zOrd: 10, life: 1.75, drag: 0, rotVel: 0, scale: { start: .15, exp: .5 }, alpha: { start: 1, exp: -1 }, color: 11792639 }, leafAutumn: { image: ["part-leaf-03.img", "part-leaf-04.img", "part-leaf-05.img", "part-leaf-06.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, leafHalloween: { image: ["part-leaf-03.img", "part-leaf-04.img", "part-leaf-05.img", "part-leaf-06.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.5, .55))) }, ignoreValueAdjust: !0 }, leafSpring: { image: ["part-blossom-01.img", "part-blossom-02.img", "part-blossom-03.img", "part-blossom-04.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, leafSummer: { image: ["part-leaf-06.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.7, .95))) }, ignoreValueAdjust: !0 }, leafPotato: { image: ["part-blossom-01.img", "part-blossom-02.img", "part-blossom-03.img", "part-blossom-04.img", "part-potato-02.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, potato: { image: ["part-potato-02.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .15), end: new l(.08, .11), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, snow: { image: ["part-snow-01.img"], life: new l(10, 15), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.07, .12), end: new l(.05, .1), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, snowball_impact: { image: ["part-snow-01.img"], life: new l(.5, 1), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .23), end: new l(.07, .14), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, potato_impact: { image: ["part-potato-01.img"], life: new l(.5, 1), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .23), end: new l(.07, .14), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))) } }, potato_smg_impact: { image: ["part-potato-01.img"], life: new l(.5, 1), drag: new l(0, 0), rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.13, .23), end: new l(.07, .14), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.9, 1) }, color: 16770437 }, heal_basic: { image: ["part-heal-basic.img"], life: new l(.75, 1), drag: .25, rotVel: 0, scale: { start: new l(.1, .12), end: new l(.05, .07), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, heal_heart: { image: ["part-heal-heart.img"], life: new l(.75, 1), drag: .25, rotVel: 0, scale: { start: new l(.1, .12), end: new l(.05, .07), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, heal_moon: { image: ["part-heal-moon.img"], life: new l(.75, 1), drag: .25, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.1, .12), end: new l(.05, .07), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, heal_tomoe: { image: ["part-heal-tomoe.img"], life: new l(.75, 1), drag: .25, rotVel: new l(Math.PI * .5, Math.PI * 1), scale: { start: new l(.1, .12), end: new l(.05, .07), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(0, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, boost_basic: { image: ["part-boost-basic.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.3, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, boost_star: { image: ["part-boost-star.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.3, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, boost_naturalize: { image: ["part-boost-naturalize.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .35, Math.PI * .7), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.3, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, boost_shuriken: { image: ["part-boost-shuriken.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * 1, Math.PI * 2), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.3, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, revive_basic: { image: ["part-heal-basic.img"], life: new l(.75, 1), drag: .25, rotVel: 0, scale: { start: new l(.1, .12), end: new l(.05, .07), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.83, 1, y.random(.7, 1))) }, ignoreValueAdjust: !0 }, leafStim: { image: ["part-blossom-01.img", "part-blossom-02.img", "part-blossom-03.img", "part-blossom-04.img"], life: new l(4, 5), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.37, 1, y.random(.95, 1))) } }, takedownStim: { image: ["part-takedown-01.img"], life: new l(4, 5), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: 13107200 }, inspireStim: { image: ["part-note-01.img"], life: new l(4, 5), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return y.rgbToInt(y.hsvToRgb(.13, 1, y.random(.98, 1))) } }, xp_common: { image: ["part-boost-basic.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return Math.random() > .5 ? y.rgbToInt(y.hsvToRgb(.12, .97, y.random(.95, 1))) : y.rgbToInt(y.hsvToRgb(.16, 1, y.random(.95, 1))) }, ignoreValueAdjust: !0 }, xp_rare: { image: ["part-boost-basic.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return Math.random() > .5 ? y.rgbToInt(y.hsvToRgb(.05, .94, y.random(.85, .88))) : y.rgbToInt(y.hsvToRgb(.06, .95, y.random(.95, 1))) }, ignoreValueAdjust: !0 }, xp_mythic: { image: ["part-boost-basic.img"], life: new l(.75, 1), drag: 0, rotVel: new l(Math.PI * .25, Math.PI * .5), scale: { start: new l(.12, .14), end: new l(.06, .08), lerp: new l(0, 1) }, alpha: { start: 1, end: 0, lerp: new l(.7, 1) }, alphaIn: { start: 0, end: 1, lerp: new l(0, .05) }, color: function() { return Math.random() > .5 ? y.rgbToInt(y.hsvToRgb(0, .96, y.random(.91, .94))) : y.rgbToInt(y.hsvToRgb(.03, .95, y.random(.92, .95))) }, ignoreValueAdjust: !0 } }, Qi = { smoke_barrel: { particle: "explosionSmoke", rate: new l(.2, .3), radius: 0, speed: new l(2, 3), angle: Math.PI * .1, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, cabin_smoke_parent: { particle: "cabinSmoke", rate: new l(.72, .83), radius: 0, speed: new l(64, 96), angle: Math.PI * .1, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, bathhouse_steam: { particle: "bathhouseSteam", rate: new l(2, 3), radius: 1, speed: new l(1.5, 2), angle: Math.PI * .1, maxCount: Number.MAX_VALUE }, bunker_bubbles_01: { particle: "bunkerBubbles", rate: new l(.3, .325), radius: 0, speed: new l(1.6, 1.8), angle: Math.PI * -2.2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, bunker_bubbles_02: { particle: "bunkerBubbles", rate: new l(.4, .425), radius: 0, speed: new l(1.6, 1.8), angle: Math.PI * -2.2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, falling_leaf: { particle: "leafAutumn", rate: new l(.08, .12), radius: 120, speed: new l(2, 3), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_leaf_halloween: { particle: "leafHalloween", rate: new l(.08, .12), radius: 120, speed: new l(2, 3), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_leaf_spring: { particle: "leafSpring", rate: new l(.1, .14), radius: 120, speed: new l(2, 3), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_leaf_summer: { particle: "leafSummer", rate: new l(.18, .24), radius: 120, speed: new l(1.4, 2.4), angle: Math.PI * .2, maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_leaf_potato: { particle: "leafPotato", rate: new l(.1, .14), radius: 120, speed: new l(2, 3), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_potato: { particle: "potato", rate: new l(.2, .24), radius: 120, speed: new l(2, 3), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_snow_fast: { particle: "snow", rate: new l(.12, .17), maxRate: new l(.05, .07), maxElapsed: 240, radius: 70, speed: new l(1, 1.5), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, falling_snow_slow: { particle: "snow", rate: new l(.08, .12), radius: 70, speed: new l(1, 1.5), angle: Math.PI * .2, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE, zOrd: 999 }, heal_basic: { particle: "heal_basic", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, heal_heart: { particle: "heal_heart", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, heal_moon: { particle: "heal_moon", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, heal_tomoe: { particle: "heal_tomoe", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, boost_basic: { particle: "boost_basic", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, boost_star: { particle: "boost_star", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, boost_naturalize: { particle: "boost_naturalize", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, boost_shuriken: { particle: "boost_shuriken", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: new l(0, Math.PI * 2), maxCount: Number.MAX_VALUE }, revive_basic: { particle: "revive_basic", rate: new l(.5, .55), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, windwalk: { particle: "leafStim", rate: new l(.1, .12), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, takedown: { particle: "takedownStim", rate: new l(.1, .12), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, inspire: { particle: "inspireStim", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, xp_common: { particle: "xp_common", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, xp_rare: { particle: "xp_rare", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE }, xp_mythic: { particle: "xp_mythic", rate: new l(.3, .35), radius: 1.5, speed: new l(1, 1.5), angle: 0, rot: 0, maxCount: Number.MAX_VALUE } }, Za = 1.25, Dt = .75, Ka = .75, Ji = 2; class Ya { constructor() { s(this, "active", !1); s(this, "sprite", new re); s(this, "soundRangeMult"); s(this, "id"); s(this, "pos"); s(this, "planeDir"); s(this, "actionComplete"); s(this, "dirty"); s(this, "soundInstance"); s(this, "soundUpdateThrottle"); s(this, "alpha"); s(this, "renderAlpha"); s(this, "spriteUpdateTime"); s(this, "type"); s(this, "config"); s(this, "rad"); s(this, "planeSound"); this.sprite.anchor.set(.5, .5), this.sprite.visible = !1 } init(e, t) { switch (this.id = e.id, this.pos = h.copy(e.pos), this.planeDir = h.copy(e.planeDir), this.actionComplete = e.actionComplete, this.active = !0, this.dirty = !1, this.soundInstance = null, this.soundUpdateThrottle = 0, this.alpha = Dt, this.renderAlpha = 1, this.spriteUpdateTime = 0, this.type = e.action, this.config = this.type == N.Plane.Airdrop ? N.airdrop : N.airstrike, this.rad = this.config.planeRad, this.type) { case N.Plane.Airdrop: this.sprite.texture = X.from(t.getMapDef().biome.airdrop.planeImg), this.planeSound = t.getMapDef().biome.airdrop.planeSound; break; case N.Plane.Airstrike: this.sprite.texture = X.from("map-plane-02.img"), this.planeSound = "fighter_01" } this.sprite.visible = !0, this.sprite.rotation = Math.atan2(this.planeDir.x, this.planeDir.y) } free(e) { this.spriteUpdateTime >= Ji && (this.soundInstance && (e.stopSound(this.soundInstance), this.soundInstance = null), this.sprite.visible = !1, this.active = !1) } } class Qa { constructor(e) { s(this, "active", !1); s(this, "pos", h.create(0, 0)); s(this, "rad", 0); s(this, "duration", 0); s(this, "ticker", 0); s(this, "gfx", new Se); s(this, "renderPos"); s(this, "renderRad"); this.container = e, e.addChild(this.gfx) } init(e, t, i) { this.active = !0, this.pos = h.copy(e), this.rad = t, this.duration = i, this.ticker = 0, this.renderPos = h.create(0, 0), this.renderRad = 0, this.gfx.visible = !0 } update(e) { this.ticker += e, this.gfx.visible = !0, this.ticker >= this.duration && (this.gfx.visible = !1, this.active = !1) } render(e, t, i) { const r = e.getMapPosFromWorldPos(this.pos, t), a = e.getMapPosFromWorldPos(h.add(this.pos, h.create(this.rad, 0)), t), m = h.length(h.sub(a, r)), o = !h.eq(this.renderPos, r, 1e-4), n = !_.eqAbs(this.renderRad, m, 1e-4); o && (this.renderPos = h.copy(r)), n && (this.renderRad = m), o && this.gfx.position.set(this.renderPos.x, this.renderPos.y), n && (this.gfx.clear(), this.gfx.lineStyle(1.5, 15400704), this.gfx.beginFill(15400704, .2), this.gfx.drawCircle(0, 0, this.renderRad), this.gfx.endFill()); const p = _.smoothstep(this.ticker, 0, .5) * (1 - _.smoothstep(this.ticker, this.duration - .5, this.duration)); this.gfx.alpha = p } } class Ja { constructor(e) { s(this, "planes", []); s(this, "airstrikeZones", []); s(this, "airstrikeZoneContainer", new ie); this.audioManager = e } free() { for (let e = 0; e < this.planes.length; e++) this.planes[e].free(this.audioManager) } updatePlanes(e, t) { for (let i = 0; i < this.planes.length; i++) this.planes[i].dirty = !0; for (let i = 0; i < e.length; i++) { const r = e[i]; let a = null; for (let m = 0; m < this.planes.length; m++) { const o = this.planes[m]; if (o.active && o.id == r.id) { a = o; break } } a || (a = this.addPlane(r, t)), a.dirty = !1, a.actionComplete = r.actionComplete } for (let i = 0; i < this.planes.length; i++) { const r = this.planes[i]; r.active && r.dirty && r.free(this.audioManager) } } addPlane(e, t) { let i = null; for (let r = 0; r < this.planes.length; r++) if (!this.planes[r].active) { i = this.planes[r]; break } return i || (i = new Ya, this.planes.push(i)), i.init(e, t), i } createAirstrikeZone(e) { let t = null; for (let i = 0; i < this.airstrikeZones.length; i++) if (!this.airstrikeZones[i]) { t = this.airstrikeZones[i]; break } return t || (t = new Qa(this.airstrikeZoneContainer), this.airstrikeZones.push(t)), t.init(e.pos, e.rad, e.duration), t } update(e, t, i, r, a) { for (let m = 0; m < this.planes.length; m++) { const o = this.planes[m]; if (o.active) { let n = 0; if ((y.sameLayer(n, i.layer) || i.layer & 2) && (!(i.layer & 2) || !r.insideStructureMask(U.createCircle(o.pos, 1))) && (n |= 2), o.pos = h.add(o.pos, h.mul(o.planeDir, e * o.config.planeVel)), o.actionComplete && (o.spriteUpdateTime = Math.min(o.spriteUpdateTime + e, Ji), o.rad = _.lerp(o.spriteUpdateTime, o.config.planeRad, o.config.planeRad * Za), o.alpha = _.lerp(o.spriteUpdateTime, Dt, Dt * Ka), o.soundRangeMult = _.max(0, _.lerp(o.spriteUpdateTime, o.config.soundRangeMult, o.config.soundRangeMult - o.config.soundRangeDelta))), o.soundInstance) o.soundUpdateThrottle < 0 ? (this.audioManager.updateSound(o.soundInstance, "sfx", o.pos, { layer: n, rangeMult: o.config.soundRangeMult, ignoreMinAllowable: !0, fallOff: o.config.fallOff }), o.soundUpdateThrottle = .1) : o.soundUpdateThrottle -= e; else { const g = h.length(h.sub(i.pos, o.pos)), x = o.config.soundRangeMax * o.config.soundRangeMult; let S = 0; if (o.type == N.Plane.Airstrike) { const v = _.max(150, g); S = (1 - _.clamp(_.max(0, v) / 800, 0, 1)) * 2.25 } g < x && (o.soundInstance = this.audioManager.playSound(o.planeSound, { channel: "sfx", soundPos: o.pos, layer: n, loop: !0, rangeMult: 2.5, ignoreMinAllowable: !0, fallOff: o.config.fallOff, offset: S })) } a.addPIXIObj(o.sprite, n, 1501, o.id); const p = t.pointToScreen(o.pos), d = t.pixels(o.rad / t.ppu), f = r.insideBuildingCeiling(U.createCircle(i.pos, .01), !0); let w = o.alpha; i.layer == 1 ? w = 0 : (f || i.layer & 1) && (w = .15), o.renderAlpha = _.lerp(e * 3, o.renderAlpha, w), o.sprite.position.set(p.x, p.y), o.sprite.scale.set(d, d), o.sprite.tint = 16776960, o.sprite.alpha = o.renderAlpha, o.sprite.visible = !0 } } for (let m = 0; m < this.airstrikeZones.length; m++) { const o = this.airstrikeZones[m]; o.active && o.update(e) } } renderAirstrikeZones(e, t, i) { for (let r = 0; r < this.airstrikeZones.length; r++) { const a = this.airstrikeZones[r]; a.active && a.render(e, t, i) } } } function q(u, e) { return { time: u, bones: e } } function te(u, e, t) { return { time: u, fn: e, args: t } } const Ke = class Ke { constructor(e = h.create(0, 0), t = 0, i = h.create(0, 0)) { this.pivot = e, this.rot = t, this.pos = i, this.pivot = h.copy(e), this.rot = 0, this.pos = h.copy(i) } copy(e) { h.set(this.pivot, e.pivot), this.rot = e.rot, h.set(this.pos, e.pos) } rotate(e) { return this.rot = e, this } offset(e) { return this.pos = h.copy(e), this } static lerp(e, t, i) { const r = new Ke; return r.pos = h.lerp(e, t.pos, i.pos), r.rot = _.lerp(e, t.rot, i.rot), r.pivot = h.lerp(e, t.pivot, i.pivot), r } }; s(Ke, "identity", new Ke(h.create(0, 0))); let L = Ke; var Be = (u => (u[u.HandL = 0] = "HandL", u[u.HandR = 1] = "HandR", u[u.FootL = 2] = "FootL", u[u.FootR = 3] = "FootR", u))(Be || {}); Ei(Object.keys(Be).length % 2 == 0); const ci = { fists: { 0: new L(h.create(14, -12.25)), 1: new L(h.create(14, 12.25)) }, slash: { 0: new L(h.create(18, -8.25)), 1: new L(h.create(6, 20.25)) }, meleeTwoHanded: { 0: new L(h.create(10.5, -14.25)), 1: new L(h.create(18, 6.25)) }, meleeKatana: { 0: new L(h.create(8.5, 13.25)), 1: new L(h.create(-3, 17.75)) }, meleeNaginata: { 0: new L(h.create(19, -7.25)), 1: new L(h.create(8.5, 24.25)) }, machete: { 0: new L(h.create(14, -12.25)), 1: new L(h.create(1, 17.75)) }, rifle: { 0: new L(h.create(28, 5.25)), 1: new L(h.create(14, 1.75)) }, dualRifle: { 0: new L(h.create(5.75, -16)), 1: new L(h.create(5.75, 16)) }, bullpup: { 0: new L(h.create(28, 5.25)), 1: new L(h.create(24, 1.75)) }, launcher: { 0: new L(h.create(20, 10)), 1: new L(h.create(2, 22)) }, pistol: { 0: new L(h.create(14, 1.75)), 1: new L(h.create(14, 1.75)) }, dualPistol: { 0: new L(h.create(15.75, -8.75)), 1: new L(h.create(15.75, 8.75)) }, throwable: { 0: new L(h.create(15.75, -9.625)), 1: new L(h.create(15.75, 9.625)) }, downed: { 0: new L(h.create(14, -12.25)), 1: new L(h.create(14, 12.25)), 2: new L(h.create(-15.75, -9)), 3: new L(h.create(-15.75, 9)) } }, H = F, es = { none: { keyframes: [], effects: [] }, fists: { keyframes: [q(0, { 1: new L(h.create(14, 12.25)) }), q(H.fists.attack.damageTimes[0], { 1: new L(h.create(29.75, 1.75)) }), q(H.fists.attack.cooldownTime, { 1: new L(h.create(14, 12.25)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, cut: { keyframes: [q(0, { 1: new L(h.create(14, 12.25)) }), q(H.fists.attack.damageTimes[0] * .25, { 1: new L(h.create(14, 12.25)).rotate(-Math.PI * .35) }), q(H.fists.attack.damageTimes[0] * 1.25, { 1: new L(h.create(14, 12.25)).rotate(Math.PI * .35) }), q(H.fists.attack.cooldownTime, { 1: new L(h.create(14, 12.25)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, cutReverse: { keyframes: [q(0, { 1: new L(h.create(1, 17.75)) }), q(H.fists.attack.damageTimes[0] * .4, { 1: new L(h.create(25, 6.25)).rotate(Math.PI * .3) }), q(H.fists.attack.damageTimes[0] * 1.4, { 1: new L(h.create(25, 6.25)).rotate(-Math.PI * .5) }), q(H.fists.attack.cooldownTime, { 1: new L(h.create(1, 17.75)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, thrust: { keyframes: [q(0, { 1: new L(h.create(14, 12.25)) }), q(H.fists.attack.damageTimes[0] * .4, { 1: new L(h.create(5, 12.25)).rotate(Math.PI * .1) }), q(H.fists.attack.damageTimes[0] * 1.4, { 1: new L(h.create(25, 6.25)).rotate(-Math.PI * 0) }), q(H.fists.attack.cooldownTime, { 1: new L(h.create(14, 12.25)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, slash: { keyframes: [q(0, { 0: new L(h.create(18, -8.25)), 1: new L(h.create(6, 20.25)) }), q(H.fists.attack.damageTimes[0], { 0: new L(h.create(6, -22.25)), 1: new L(h.create(6, 20.25)).rotate(-Math.PI * .6) }), q(H.fists.attack.cooldownTime, { 0: new L(h.create(18, -8.25)), 1: new L(h.create(6, 20.25)).rotate(0) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, hook: { keyframes: [q(0, { 1: new L(h.create(14, 12.25)) }), q(H.hook.attack.damageTimes[0] * .25, { 1: new L(h.create(14, 12.25)).rotate(Math.PI * .1) }), q(H.hook.attack.damageTimes[0], { 1: new L(h.create(24, 1.75)) }), q(H.hook.attack.damageTimes[0] + .05, { 1: new L(h.create(14, 12.25)).rotate(Math.PI * -.3) }), q(H.hook.attack.damageTimes[0] + .1, { 1: new L(h.create(14, 12.25)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.hook.attack.damageTimes[0], "animMeleeCollision", {})] }, pan: { keyframes: [q(0, { 1: new L(h.create(14, 12.25)) }), q(.15, { 1: new L(h.create(22, -8.25)).rotate(-Math.PI * .2) }), q(.25, { 1: new L(h.create(28, -8.25)).rotate(Math.PI * .5) }), q(.55, { 1: new L(h.create(14, 12.25)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.pan.attack.damageTimes[0], "animMeleeCollision", {})] }, axeSwing: { keyframes: [q(0, { 0: new L(h.create(10.5, -14.25)), 1: new L(h.create(18, 6.25)) }), q(H.woodaxe.attack.damageTimes[0] * .4, { 0: new L(h.create(9, -14.25)).rotate(Math.PI * .4), 1: new L(h.create(18, 6.25)).rotate(Math.PI * .4) }), q(H.woodaxe.attack.damageTimes[0], { 0: new L(h.create(9, -14.25)).rotate(-Math.PI * .4), 1: new L(h.create(18, 6.25)).rotate(-Math.PI * .4) }), q(H.woodaxe.attack.cooldownTime, { 0: new L(h.create(10.5, -14.25)), 1: new L(h.create(18, 6.25)) })], effects: [te(H.woodaxe.attack.damageTimes[0], "animPlaySound", { sound: "swing" }), te(H.woodaxe.attack.damageTimes[0], "animMeleeCollision", {})] }, hammerSwing: { keyframes: [q(0, { 0: new L(h.create(10.5, -14.25)), 1: new L(h.create(18, 6.25)) }), q(H.stonehammer.attack.damageTimes[0] * .4, { 0: new L(h.create(9, -14.25)).rotate(Math.PI * .4), 1: new L(h.create(18, 6.25)).rotate(Math.PI * .4) }), q(H.stonehammer.attack.damageTimes[0], { 0: new L(h.create(9, -14.25)).rotate(-Math.PI * .4), 1: new L(h.create(18, 6.25)).rotate(-Math.PI * .4) }), q(H.stonehammer.attack.cooldownTime, { 0: new L(h.create(10.5, -14.25)), 1: new L(h.create(18, 6.25)) })], effects: [te(H.stonehammer.attack.damageTimes[0], "animPlaySound", { sound: "swing" }), te(H.stonehammer.attack.damageTimes[0], "animMeleeCollision", {})] }, katanaSwing: { keyframes: [q(0, { 0: new L(h.create(8.5, 13.25)), 1: new L(h.create(-3, 17.75)) }), q(H.katana.attack.damageTimes[0] * .3, { 0: new L(h.create(8.5, 13.25)).rotate(Math.PI * .2), 1: new L(h.create(-3, 17.75)).rotate(Math.PI * .2) }), q(H.katana.attack.damageTimes[0] * .9, { 0: new L(h.create(8.5, 13.25)).rotate(-Math.PI * 1.2), 1: new L(h.create(-3, 17.75)).rotate(-Math.PI * 1.2) }), q(H.katana.attack.cooldownTime, { 0: new L(h.create(8.5, 13.25)), 1: new L(h.create(-3, 17.75)) })], effects: [te(H.katana.attack.damageTimes[0], "animPlaySound", { sound: "swing" }), te(H.katana.attack.damageTimes[0], "animMeleeCollision", {})] }, naginataSwing: { keyframes: [q(0, { 0: new L(h.create(19, -7.25)), 1: new L(h.create(8.5, 24.25)) }), q(H.naginata.attack.damageTimes[0] * .3, { 0: new L(h.create(19, -7.25)).rotate(Math.PI * .3), 1: new L(h.create(8.5, 24.25)).rotate(Math.PI * .3) }), q(H.naginata.attack.damageTimes[0] * .9, { 0: new L(h.create(19, -7.25)).rotate(-Math.PI * .85), 1: new L(h.create(8.5, 24.25)).rotate(-Math.PI * .85) }), q(H.naginata.attack.cooldownTime, { 0: new L(h.create(19, -7.25)), 1: new L(h.create(8.5, 24.25)) })], effects: [te(H.woodaxe.attack.damageTimes[0], "animPlaySound", { sound: "swing" }), te(H.woodaxe.attack.damageTimes[0], "animMeleeCollision", {})] }, sawSwing: { keyframes: [q(0, { 1: new L(h.create(1, 17.75)) }), q(H.saw.attack.damageTimes[0] * .4, { 1: new L(h.create(25, 6.25)).rotate(Math.PI * .3) }), q(H.saw.attack.damageTimes[0], { 1: new L(h.create(25, 6.25)).rotate(-Math.PI * .3) }), q(H.saw.attack.damageTimes[1] - .1, { 1: new L(h.create(25, 17.75)).rotate(-Math.PI * .25) }), q(H.saw.attack.damageTimes[1] * .6, { 1: new L(h.create(-36, 7.75)).rotate(-Math.PI * .25) }), q(H.saw.attack.damageTimes[1] + .2, { 1: new L(h.create(1, 17.75)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(.4, "animPlaySound", { sound: "swing" }), te(H.saw.attack.damageTimes[0], "animMeleeCollision", {}), te(H.saw.attack.damageTimes[1], "animMeleeCollision", { playerHit: "playerHit2" })] }, cutReverseShort: { keyframes: [q(0, { 1: new L(h.create(1, 17.75)) }), q(H.saw.attack.damageTimes[0] * .4, { 1: new L(h.create(25, 6.25)).rotate(Math.PI * .3) }), q(H.saw.attack.damageTimes[0], { 1: new L(h.create(25, 6.25)).rotate(-Math.PI * .3) }), q(H.fists.attack.cooldownTime, { 1: new L(h.create(14, 17.75)) })], effects: [te(0, "animPlaySound", { sound: "swing" }), te(H.fists.attack.damageTimes[0], "animMeleeCollision", {})] }, cook: { keyframes: [q(0, { 0: new L(h.create(15.75, -9.625)), 1: new L(h.create(15.75, 9.625)) }), q(.1, { 0: new L(h.create(14, -1.75)), 1: new L(h.create(14, 1.75)) }), q(.3, { 0: new L(h.create(14, -1.75)), 1: new L(h.create(14, 1.75)) }), q(.4, { 0: new L(h.create(22.75, -1.75)), 1: new L(h.create(1.75, 14)) }), q(99999, { 0: new L(h.create(22.75, -1.75)), 1: new L(h.create(1.75, 14)) })], effects: [te(0, "animPlaySound", { sound: "pullPin" }), te(.1, "animSetThrowableState", { state: "cook" })] }, throw: { keyframes: [q(0, { 0: new L(h.create(22.75, -1.75)), 1: new L(h.create(1.75, 14.175)) }), q(.15, { 0: new L(h.create(5.25, -15.75)), 1: new L(h.create(29.75, 1.75)) }), q(.15 + N.player.throwTime, { 0: new L(h.create(15.75, -9.625)), 1: new L(h.create(15.75, 9.625)) })], effects: [te(0, "animPlaySound", { sound: "throwing" }), te(0, "animSetThrowableState", { state: "throwing" }), te(0, "animThrowableParticles", {})] }, crawl_forward: { keyframes: [q(0, { 0: new L(h.create(14, -12.25)), 2: new L(h.create(-15.75, -9)) }), q(N.player.crawlTime * .33, { 0: new L(h.create(19.25, -10.5)), 2: new L(h.create(-20.25, -9)) }), q(N.player.crawlTime * .66, { 0: new L(h.create(5.25, -15.75)), 2: new L(h.create(-11.25, -9)) }), q(N.player.crawlTime * 1, { 0: new L(h.create(14, -12.25)), 2: new L(h.create(-15.75, -9)) })], effects: [] }, crawl_backward: { keyframes: [q(0, { 0: new L(h.create(14, -12.25)), 2: new L(h.create(-15.75, -9)) }), q(N.player.crawlTime * .33, { 0: new L(h.create(5.25, -15.75)), 2: new L(h.create(-11.25, -9)) }), q(N.player.crawlTime * .66, { 0: new L(h.create(19.25, -10.5)), 2: new L(h.create(-20.25, -9)) }), q(N.player.crawlTime * 1, { 0: new L(h.create(14, -12.25)), 2: new L(h.create(-15.75, -9)) })], effects: [] }, revive: { keyframes: [q(0, { 0: new L(h.create(14, -12.25)), 1: new L(h.create(14, 12.25)) }), q(.2, { 0: new L(h.create(24.5, -8.75)), 1: new L(h.create(5.25, 21)) }), q(.2 + N.player.reviveDuration, { 0: new L(h.create(24.5, -8.75)), 1: new L(h.create(5.25, 21)) })], effects: [] } }, er = { "proj-frag-nopin-01.img": "proj-frag-nopin-02.img", "proj-frag-nopin-nolever-01.img": "proj-frag-nopin-nolever-02.img", "proj-frag-pin-01.img": "proj-frag-pin-02.img", "proj-mirv-mini-01.img": "proj-mirv-mini-02.img" }; class ts { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "isNew"); s(this, "container", new ie); s(this, "trail", re.from("player-bullet-trail-02.img")); s(this, "sprite", new re); s(this, "strobeSprite", null); s(this, "layer"); s(this, "type"); s(this, "rad"); s(this, "pos"); s(this, "posOld"); s(this, "posZ"); s(this, "posZOld"); s(this, "dir"); s(this, "imgScale"); s(this, "rot"); s(this, "rotVel"); s(this, "rotDrag"); s(this, "velZ"); s(this, "grounded"); s(this, "inWater"); s(this, "lastSoundObjId"); s(this, "playHitSfx"); s(this, "alwaysRenderOntop"); s(this, "strobeScale"); s(this, "strobeScaleMax"); s(this, "strobeTicker"); s(this, "strobeDir"); s(this, "strobeSpeed"); this.container.visible = !1, this.trail.anchor.set(1, .5), this.trail.scale.set(1, 1), this.trail.visible = !1, this.container.addChild(this.trail), this.sprite.anchor.set(.5, .5), this.container.addChild(this.sprite) } init() {} free() { this.container.visible = !1, this.strobeSprite && (this.strobeSprite.visible = !1) } updateData(e, t, i, r) { if (t) { const a = F[e.type]; this.layer = e.layer, this.type = e.type, this.rad = a.rad * .5 } if (this.posOld = i ? h.copy(e.pos) : h.copy(this.pos), this.posZOld = i ? e.posZ : this.posZ, this.pos = h.copy(e.pos), this.posZ = e.posZ, this.dir = h.copy(e.dir), i) { const a = F[e.type], m = a.worldImg; this.imgScale = m.scale, this.rot = 0, this.rotVel = a.throwPhysics.spinVel, a.throwPhysics.randomizeSpinDir && Math.random() < .5 && (this.rotVel *= -1), this.rotDrag = a.throwPhysics.spinDrag * y.random(1, 2), this.velZ = 0, this.grounded = !1, this.inWater = !1, this.lastSoundObjId = 0, this.playHitSfx = !a.explodeOnImpact, this.alwaysRenderOntop = !1; let o = !0; if (this.type == "bomb_iron") { this.alwaysRenderOntop = !0; const p = U.createCircle(this.pos, .5); r.map.insideBuildingCeiling(p, !0) && (o = !1) } let n = m.sprite; r.map.mapDef.gameMode.spookyKillSounds && (n = er[n] || n), this.sprite.texture = X.from(n), this.sprite.tint = m.tint, this.sprite.alpha = 1, this.container.visible = o, e.type == "strobe" && (this.strobeSprite || (this.strobeSprite = new re, this.strobeSprite.texture = X.from("part-strobe-01.img"), this.strobeSprite.anchor.set(.5, .5), this.container.addChild(this.strobeSprite)), this.strobeSprite.scale.set(0, 0), this.strobeSprite.visible = !0, this.strobeScale = 0, this.strobeScaleMax = 12, this.strobeTicker = 0, this.strobeDir = 1, this.strobeSpeed = 1.25) } } } const is = { grass: "frag_grass", sand: "frag_sand", water: "frag_water" }; class rs { constructor() { s(this, "projectilePool", new _e(ts)) } update(e, t, i, r, a, m, o) { const n = this.projectilePool.getPool(); for (let p = 0; p < n.length; p++) { const d = n[p]; if (d.active) { const f = F[d.type]; let w = d.rotDrag; d.inWater && (w *= 3), d.rotVel *= 1 / (1 + e * w), d.rot += d.rotVel * e; const g = { obj: null, pen: 0 }, x = { obj: null, pen: 0 }, S = U.createCircle(d.pos, d.rad), z = a.obstaclePool.getPool(); for (let O = 0; O < z.length; O++) { const W = z[O]; if (W.active && !W.dead && y.sameLayer(W.layer, d.layer)) { const Z = U.intersect(W.collider, S); if (Z) { const K = W.height > d.posZ ? g : x; Z.pen > K.pen && (!K.obj || K.obj.height <= W.height) && (K.obj = W, K.pen = Z.pen) } } } const I = h.div(h.sub(d.pos, d.posOld), e), k = h.length(I); if (g.obj && g.obj.__id != d.lastSoundObjId && k > 7.5 && (d.lastSoundObjId = g.obj.__id, d.playHitSfx)) { const O = h.mul(h.normalizeSafe(I, h.create(1, 0)), -1), W = oe[g.obj.type]; Ct(W.hitParticle, W.sound.bullet, d.pos, O, d.layer, t, i) } const v = a.getGroundSurface(d.pos, d.layer); d.posZ <= .01 && (!d.inWater && v.type == "water" && t.addRippleParticle(d.pos, d.layer, v.data.rippleColor), d.inWater = v.type == "water"); const b = d.velZ; if (d.velZ = (d.posZ - d.posZOld) / e, !d.isNew && !d.grounded && d.velZ >= 0 && b < 0) { const O = { fn: "playGroup", channel: "hits", name: "" }; if (x.obj) { if (d.lastSoundObjId != x.obj.__id) { d.lastSoundObjId = x.obj.__id; const W = oe[x.obj.type]; O.name = W.sound.bullet } } else d.grounded = !0, O.name = is[v.type], O.name === void 0 && (O.name = `footstep_${v.type}`, O.fn = "playGroup", O.channel = "sfx"); O.name && d.playHitSfx && i[O.fn](O.name, { channel: O.channel, soundPos: d.pos, layer: d.layer, filter: "muffled" }) } if (d.type == "strobe" && d.strobeSprite && (d.strobeTicker = _.clamp(d.strobeTicker + e * d.strobeDir * d.strobeSpeed, 0, 1), d.strobeScale = _.easeInExpo(d.strobeTicker) * d.strobeScaleMax, d.strobeSprite.scale.set(d.strobeScale, d.strobeScale), (d.strobeScale >= d.strobeScaleMax || d.strobeTicker <= 0) && (d.strobeDir *= -1)), d.sprite.rotation = d.rot, d.sprite.alpha = d.inWater ? .3 : 1, f.trail) { const O = h.length(I), W = _.remap(O, f.throwPhysics.speed * .25, f.throwPhysics.speed * 1, 0, 1) * _.remap(d.posZ, .1, N.projectile.maxHeight * .5, 0, 1); d.trail.scale.set(f.trail.maxLength * W, f.trail.width), d.trail.rotation = -Math.atan2(d.dir.y, d.dir.x), d.trail.tint = f.trail.tint, d.trail.alpha = f.trail.alpha * W, d.trail.visible = !0 } else d.trail.visible = !1; let M = d.layer, A = d.posZ < .25 ? 14 : 25; const D = U.createCircle(d.pos, d.rad * 3), B = a.insideStructureStairs(D), T = a.insideStructureMask(D); d.posZ >= .25 && B && (d.layer & 1) == (r.layer & 1) && (!T || !(r.layer & 2)) && (M |= 2, A += 100), d.alwaysRenderOntop && r.layer == 0 && (A = 1e3, M |= 2), m.addPIXIObj(d.container, M, A); const C = d.imgScale * _.remap(d.posZ, 0, N.projectile.maxHeight, 1, 4.75), R = o.pointToScreen(d.pos), V = o.pixels(C); d.container.position.set(R.x, R.y), d.container.scale.set(V, V) } } } } function tr(u, e, t, i, r, a, m, o) { const n = F[u]; if (n) { let p = h.rotate(r, e); n.particle.shellForward && (p = h.mul(r, n.particle.shellForward)); let d = h.mul(p, t * 9.5); d = h.rotate(d, (Math.random() - .5) * Math.PI / 3); let f = h.add(i, h.mul(r, N.player.radius + n.particle.shellOffset)); n.particle.shellOffsetY && (f = h.add(f, h.mul(p, n.particle.shellOffsetY))), n.particle.shellReverse && (d = h.mul(d, -1)), o.addParticle(n.ammo, a, f, d, n.particle.shellScale, -Math.atan2(p.y, p.x), null, m) } } class as { constructor() { s(this, "shots", []) } addShot(e) { let t = null; for (let a = 0; a < this.shots.length; a++) if (!this.shots[a].active) { t = this.shots[a]; break } t || (t = {}, this.shots.push(t)); const i = e.shotSourceType, r = F[i]; t.active = !0, t.pos = h.copy(e.pos), t.layer = e.layer, t.playerId = e.playerId, t.weaponType = i, t.offhand = e.shotOffhand, t.lastShot = e.lastShot, t.shotAlt = e.shotAlt, t.ticker = 0, t.pullDelay = r.pullDelay !== void 0 ? r.pullDelay * .45 : 0, t.splinter = e.splinter, t.trailSaturated = e.trailSaturated } update(e, t, i, r, a) { for (let m = 0; m < this.shots.length; m++) { const o = this.shots[m]; if (o.active) { const n = F[o.weaponType]; if (o.ticker == 0) { const p = i.getPlayerById(o.playerId); let d = n.sound.shoot; if (n.sound.shootTeam) { const w = i.getPlayerInfo(o.playerId).teamId; n.sound.shootTeam[w] && (d = n.sound.shootTeam[w]) } o.lastShot && n.sound.shootLast && (d = n.sound.shootLast), o.shotAlt && n.sound.shootAlt && (d = n.sound.shootAlt); let f = 0; if (o.trailSaturated && !n.ignoreDetune ? f = 300 : o.splinter && (f = -300), a.playSound(d, { channel: o.playerId == t ? "activePlayer" : "otherPlayers", soundPos: o.pos, layer: p ? p.layer : o.layer, filter: "muffled", fallOff: n.sound.fallOff ? n.sound.fallOff : 0, detune: f, volumeScale: o.splinter ? .75 : 1 }), o.splinter && a.playSound(d, { channel: o.playerId == t ? "activePlayer" : "otherPlayers", soundPos: o.pos, layer: p ? p.layer : o.layer, filter: "muffled", fallOff: n.sound.fallOff ? n.sound.fallOff : 0, detune: 1200, delay: 30, volumeScale: .75 }), p) { if (p.__id == t && n.fireMode == "single" && n.pullDelay) { const S = p.localData.weapons[p.localData.curWeapIdx].ammo > 0 ? n.sound.cycle : n.sound.pull; a.stopSound(p.cycleSoundInstance), p.cycleSoundInstance = a.playSound(S) } const w = o.offhand || !n.isDual, g = !o.offhand || !n.isDual; p.addRecoil(n.worldImg.recoil, w, g), p.fireDelay = n.fireDelay } } if (o.ticker += e, o.ticker >= o.pullDelay) { const p = i.getPlayerById(o.playerId); p && !p.netData.dead && p.netData.activeWeapon == o.weaponType && n.caseTiming == "shoot" && tr(o.weaponType, Math.PI / 2 * -1, 1, p.netData.pos, p.netData.dir, p.renderLayer, p.renderZOrd + 1, r), o.active = !1 } } } } } const ui = .1; function ss(u, e) { if (u.length != e.length) return !1; for (let t = 0; t < u.length; t++) if (u[t].type != e[t].type) return !1; return !0 } function os() { const u = { fontFamily: "Arial", fontWeight: "bold", fontSize: P.pixelRatio > 1 ? 30 : 22, align: "center", fill: 65535, stroke: 0, strokeThickness: 0, dropShadow: !0, dropShadowColor: "#000000", dropShadowBlur: 1, dropShadowAngle: Math.PI / 3, dropShadowDistance: 1 }, e = new Ye("", u); return e.anchor.set(.5, .5), e.scale.set(.5, .5), e.position.set(0, 30), e.visible = !1, e } function le() { const u = new re; return u.texture = X.EMPTY, u.anchor.set(.5, .5), u.scale.set(1, 1), u.tint = 16777215, u.visible = !1, u } const ls = Object.values(N.scopeZoomRadius.desktop), ms = Object.values(N.scopeZoomRadius.mobile); class di { constructor() { s(this, "gunBarrel", le()); s(this, "gunMag", le()); s(this, "container", new ie); s(this, "magTop", !1); this.container.addChild(this.gunBarrel), this.container.addChild(this.gunMag), this.container.rotation = Math.PI * .5, this.container.visible = !1 } setVisible(e) { this.container.visible = e } setType(e, t) { var m; const i = F[e], r = i.worldImg; if (this.gunBarrel.texture = X.from(r.sprite), this.gunBarrel.anchor.set(.5, 1), this.gunBarrel.position.set(0, 0), this.gunBarrel.scale.set(r.scale.x * .5 / t, r.scale.y * .5 / t), this.gunBarrel.tint = r.tint, this.gunBarrel.visible = !0, r.magImg) { const o = r.magImg; this.gunMag.texture = X.from(o.sprite), this.gunMag.anchor.set(.5, .5), this.gunMag.position.set(o.pos.x / t, o.pos.y / t), this.gunMag.scale.set(.25 / t, .25 / t), this.gunMag.tint = 16777215, this.gunMag.visible = !0, o.top ? this.container.addChild(this.gunMag) : this.container.addChildAt(this.gunMag, 0) } else this.gunMag.visible = !1; this.magTop = (m = r.magImg) == null ? void 0 : m.top; const a = i.isDual ? h.create(-5.95, 0) : h.create(-4.25, -1.75); r.gunOffset && (a.x += r.gunOffset.x, a.y += r.gunOffset.y), this.container.position.set(a.x, a.y) } } class ns { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "bodySprite", le()); s(this, "chestSprite", le()); s(this, "flakSprite", le()); s(this, "steelskinSprite", le()); s(this, "helmetSprite", le()); s(this, "visorSprite", le()); s(this, "backpackSprite", le()); s(this, "handLSprite", le()); s(this, "handRSprite", le()); s(this, "footLSprite", le()); s(this, "footRSprite", le()); s(this, "hipSprite", le()); s(this, "gunLSprites", new di); s(this, "gunRSprites", new di); s(this, "objectLSprite", le()); s(this, "objectRSprite", le()); s(this, "meleeSprite", le()); s(this, "bodySubmergeSprite", le()); s(this, "handLSubmergeSprite", le()); s(this, "handRSubmergeSprite", le()); s(this, "footLSubmergeSprite", le()); s(this, "footRSubmergeSprite", le()); s(this, "bodyEffectSprite", le()); s(this, "patchSprite", le()); s(this, "handLContainer", new ie); s(this, "handRContainer", new ie); s(this, "footLContainer", new ie); s(this, "footRContainer", new ie); s(this, "bodyContainer", new ie); s(this, "container", new ie); s(this, "nameText", os()); s(this, "auraContainer", new ie); s(this, "auraCircle", le()); s(this, "bones", []); s(this, "anim", { type: ce.None, data: {}, seq: -1, ticker: 0, bones: [] }); s(this, "perks", []); s(this, "perkTypes", []); s(this, "perksDirty", !1); s(this, "surface", null); s(this, "wasInWater", !1); s(this, "weapTypeOld", ""); s(this, "visualsDirty", !1); s(this, "stepDistance", 0); s(this, "zoomFast", !1); s(this, "playedDryFire", !1); s(this, "lastSwapIdx", -1); s(this, "hasteSeq", -1); s(this, "cycleSoundInstance", null); s(this, "actionSoundInstance", null); s(this, "useItemEmitter", null); s(this, "hasteEmitter", null); s(this, "passiveHealEmitter", null); s(this, "downed", !1); s(this, "wasDowned", !1); s(this, "bleedTicker", 0); s(this, "submersion", 0); s(this, "gunRecoilL", 0); s(this, "gunRecoilR", 0); s(this, "fireDelay", 0); s(this, "throwableState", "equip"); s(this, "lastThrowablePickupSfxTicker", 0); s(this, "isNearDoorError", !1); s(this, "doorErrorTicker", 0); s(this, "noCeilingRevealTicker", 0); s(this, "frozenTicker", 0); s(this, "updateFrozenImage", !0); s(this, "viewAabb", { min: h.create(0, 0), max: h.create(0, 0) }); s(this, "auraViewFade", 0); s(this, "auraPulseTicker", 0); s(this, "auraPulseDir", 1); s(this, "renderLayer", 0); s(this, "renderZOrd", 18); s(this, "renderZIdx", 0); s(this, "action", { type: se.None, seq: -1, seqOld: -1, item: "", skin: "", targetId: 0, time: 0, duration: 0, throttleCount: 0, throttleTicker: 0 }); s(this, "netData", { pos: h.create(0, 0), dir: h.create(1, 0), outfit: "", backpack: "", helmet: "", chest: "", activeWeapon: "fists", layer: 0, dead: !1, downed: !1, animType: ce.None, animSeq: 0, actionType: se.None, actionSeq: 0, wearingPan: !1, healEffect: !1, frozen: !1, frozenOri: 0, hasteType: Ve.None, hasteSeq: 0, actionItem: "", scale: 1, role: "", perks: [] }); s(this, "localData", { health: N.player.health, zoom: 0, boost: 0, scope: "", curWeapIdx: 0, inventory: {}, weapons: [], spectatorCount: 0 }); s(this, "throwableStatePrev"); s(this, "rad", N.player.radius); s(this, "bodyRad"); s(this, "pos", h.create(0, 0)); s(this, "posOld", h.create(0, 0)); s(this, "dir", h.create(1, 0)); s(this, "dirOld", h.create(1, 0)); s(this, "layer", 0); s(this, "isLoadoutAvatar", !1); s(this, "playActionStartSfx", !0); s(this, "isNew"); s(this, "wasInsideObstacle"); s(this, "insideObstacleType"); s(this, "lastInsideObstacleTime"); s(this, "dead"); s(this, "gunSwitchCooldown"); this.bodySprite.addChild(this.bodySubmergeSprite), this.handLSprite.addChild(this.handLSubmergeSprite), this.handRSprite.addChild(this.handRSubmergeSprite), this.footLSprite.addChild(this.footLSubmergeSprite), this.footRSprite.addChild(this.footRSubmergeSprite), this.handLContainer.addChild(this.gunLSprites.container), this.handLContainer.addChild(this.handLSprite), this.handLContainer.addChild(this.objectLSprite), this.handRContainer.addChild(this.gunRSprites.container), this.handRContainer.addChild(this.meleeSprite), this.handRContainer.addChild(this.handRSprite), this.handRContainer.addChild(this.objectRSprite), this.footLContainer.addChild(this.footLSprite), this.footRContainer.addChild(this.footRSprite), this.bodyContainer.addChild(this.footLContainer), this.bodyContainer.addChild(this.footRContainer), this.bodyContainer.addChild(this.backpackSprite), this.bodyContainer.addChild(this.bodySprite), this.bodyContainer.addChild(this.chestSprite), this.bodyContainer.addChild(this.flakSprite), this.bodyContainer.addChild(this.steelskinSprite), this.bodyContainer.addChild(this.hipSprite), this.bodyContainer.addChild(this.patchSprite), this.bodyContainer.addChild(this.bodyEffectSprite), this.bodyContainer.addChild(this.handLContainer), this.bodyContainer.addChild(this.handRContainer), this.bodyContainer.addChild(this.visorSprite), this.bodyContainer.addChild(this.helmetSprite), this.container.addChild(this.bodyContainer), this.container.addChild(this.nameText), this.auraContainer.addChild(this.auraCircle), this.initSubmergeSprites(); const e = Object.keys(Be).length; for (let t = 0; t < e; t++) this.bones.push(new L), this.anim.bones.push({ weight: 0, pose: new L }); this.throwableStatePrev = this.throwableState, this.bodyRad = this.rad } init() { this.isNew = !1, this.wasInsideObstacle = !1, this.insideObstacleType = "", this.lastInsideObstacleTime = 0, this.lastSwapIdx = -1, this.hasteSeq = -1, this.actionSoundInstance = null, this.playAnim(ce.None, -1) } free() { this.container.visible = !1, this.auraContainer.visible = !1, this.useItemEmitter && (this.useItemEmitter.stop(), this.useItemEmitter = null), this.hasteEmitter && (this.hasteEmitter.stop(), this.hasteEmitter = null), this.passiveHealEmitter && (this.passiveHealEmitter.stop(), this.passiveHealEmitter = null) } updateData(e, t, i, r) { this.netData.pos = h.copy(e.pos), this.netData.dir = h.copy(e.dir), t && (this.netData.outfit = e.outfit, this.netData.backpack = e.backpack, this.netData.helmet = e.helmet, this.netData.chest = e.chest, this.netData.activeWeapon = e.activeWeapon, this.netData.layer = e.layer, this.netData.dead = e.dead, this.netData.downed = e.downed, this.netData.animType = e.animType, this.netData.animSeq = e.animSeq, this.netData.actionType = e.actionType, this.netData.actionSeq = e.actionSeq, this.netData.wearingPan = e.wearingPan, this.netData.healEffect = e.healEffect, this.netData.frozen = e.frozen, this.netData.frozenOri = e.frozenOri, this.netData.hasteType = e.hasteType, this.netData.hasteSeq = e.hasteSeq, this.netData.actionItem = e.actionItem, this.netData.scale = e.scale, this.netData.role = e.role, (i || !ss(this.netData.perks, e.perks)) && (this.perksDirty = !0), this.netData.perks = e.perks, e.animSeq != this.anim.seq && this.playAnim(e.animType, e.animSeq), this.action.type = e.actionType, this.action.seq = e.actionSeq, this.action.item = e.actionItem, this.visualsDirty = !0), i && (this.isNew = !0, this.renderLayer = this.netData.layer, this.renderZOrd = 18, this.renderZIdx = this.__id) } setLocalData(e, t) { const i = this.localData.scope; if (e.healthDirty && (this.localData.health = e.health), e.boostDirty && (this.localData.boost = e.boost), e.zoomDirty && (this.localData.zoom = e.zoom, this.zoomFast = !1), e.actionDirty && (this.action.time = e.action.time, this.action.duration = e.action.duration, this.action.targetId = e.action.targetId), e.inventoryDirty) { this.localData.scope = e.scope, this.localData.inventory = {}; for (const r in N.bagSizes) N.bagSizes.hasOwnProperty(r) && (this.localData.inventory[r] = e.inventory[r]) } if (e.weapsDirty) { this.localData.curWeapIdx = e.curWeapIdx, this.localData.weapons = []; for (let r = 0; r < N.WeaponSlot.Count; r++) { const a = { type: e.weapons[r].type, ammo: e.weapons[r].ammo }; this.localData.weapons.push(a) } } e.spectatorCountDirty && (this.localData.spectatorCount = e.spectatorCount), this.localData.scope != i && (this.zoomFast = !0) } getZoom() { let e = this.localData.zoom; if (P.mobile) { const t = ls.indexOf(e); t !== -1 && (e = ms[t]) } return e } getHelmetLevel() { return this.netData.helmet ? F[this.netData.helmet].level : 0 } getChestLevel() { return this.netData.chest ? F[this.netData.chest].level : 0 } getBagLevel() { return F[this.netData.backpack].level } Ur() { return F[this.netData.activeWeapon].type } Wr(e) { return this.localData.weapons[e].type !== "" } getMeleeCollider() { const e = F[this.netData.activeWeapon], t = Math.atan2(this.dir.y, this.dir.x), i = h.add(e.attack.offset, h.mul(h.create(1, 0), this.netData.scale - 1)), r = h.add(this.pos, h.rotate(i, t)), a = e.attack.rad; return U.createCircle(r, a, 0) } hasActivePan() { return this.netData.wearingPan || this.netData.activeWeapon == "pan" && this.currentAnim() != ce.Melee } getPanSegment() { var t; const e = this.netData.wearingPan ? "unequipped" : "equipped"; return (t = F.pan.reflectSurface) == null ? void 0 : t[e] } canInteract(e) { return !this.netData.dead && (!e.perkMode || this.netData.role) } updatePerks(e, t, i) { for (let r = 0; r < this.perks.length; r++) this.perks[r].isNew = !1; if (this.perksDirty) { if (e && !t) { for (let a = 0; a < this.netData.perks.length; a++) { const m = this.netData.perks[a]; this.perks.findIndex(o => o.type == m.type) === -1 && i.addRareLootMessage(m.type) } for (let a = 0; a < this.perks.length; a++) { const m = this.perks[a]; this.netData.perks.findIndex(o => o.type == m.type) === -1 && i.removeRareLootMessage(m.type) } } const r = []; for (let a = 0; a < this.netData.perks.length; a++) { const m = this.netData.perks[a], o = this.perks.findIndex(n => n.type == m.type) === -1; r.push({ type: m.type, droppable: m.droppable, isNew: o && !this.isNew }) } this.perks = r, this.perkTypes = []; for (let a = 0; a < this.netData.perks.length; a++) this.perkTypes.push(this.netData.perks[a].type); this.perksDirty = !1 } } hasPerk(e) { return this.perkTypes.includes(e) } update(e, t, i, r, a, m, o, n, p, d, f, w, g) { var Z, K, ae; const x = F[this.netData.activeWeapon], S = this.__id == d, z = t.getPlayerById(d); if (this.posOld = h.copy(this.pos), this.dirOld = h.copy(this.dir), this.pos = h.copy(this.netData.pos), this.dir = h.copy(this.netData.dir), this.layer = this.netData.layer, this.downed = this.netData.downed, this.rad = this.netData.scale * N.player.radius, !_.eqAbs(this.rad, this.bodyRad)) { const $ = this.rad - this.bodyRad; let j = Math.abs($) > 1e-4 ? $ * e * 6 : $; this.isNew && (j = $), this.bodyRad += j, this.visualsDirty = !0 } if (S) { const $ = o.screenToPoint(h.create(o.screenWidth, 0)), j = h.sub($, o.pos); this.viewAabb.min = h.sub(o.pos, j), this.viewAabb.max = h.add(o.pos, j) } this.updatePerks(S, g, p); const I = this.weapTypeOld != this.netData.activeWeapon; this.weapTypeOld = this.netData.activeWeapon, this.lastThrowablePickupSfxTicker -= e, this.noCeilingRevealTicker -= e; const k = t.getPlayerInfo(d).groupId, v = t.getPlayerInfo(this.__id), b = v.groupId == k; this.nameText.text = v.name, this.nameText.visible = !S && b; let M = null, A = null; const D = i.obstaclePool.getPool(); for (let $ = 0; $ < D.length; $++) { const j = D[$]; if (j.active && !j.dead && j.layer == this.netData.layer) { if (j.isBush) { const Q = this.rad * .25; U.intersectCircle(j.collider, this.pos, Q) && (M = j) } else if (j.isDoor) { const Q = this.rad + .25, he = h.sub(j.pos, this.pos), ze = h.rotate(h.create(1, 0), j.rot); U.intersectCircle(j.collider, this.pos, Q) && (j.door.locked || j.door.openOneWay && h.dot(he, ze) < 0) && (A = j) } } } const B = M != null; if (B && (this.insideObstacleType = M == null ? void 0 : M.type), this.lastInsideObstacleTime -= e, this.wasInsideObstacle != B && this.lastInsideObstacleTime < 0 && !this.isNew) { const $ = oe[this.insideObstacleType]; this.lastInsideObstacleTime = .2, r.playSound($ == null ? void 0 : $.sound.enter, { channel: "sfx", soundPos: this.pos, fallOff: 1, layer: this.layer, filter: "muffled" }); const j = h.normalizeSafe(h.sub(this.posOld, this.pos), h.create(1, 0)), Q = B ? 1 : -1, he = Math.floor(y.random(3, 5)); for (let ze = 0; ze < he; ze++) { const Ce = h.mul(h.rotate(h.mul(j, Q), (Math.random() - .5) * Math.PI / 1.5), y.random(6, 8)); a.addParticle($.hitParticle, this.layer, this.pos, Ce) } } this.wasInsideObstacle = B; const T = this.isNearDoorError; if (this.isNearDoorError = A != null, this.doorErrorTicker -= e, this.isNearDoorError && !T && this.doorErrorTicker <= 0) { this.doorErrorTicker = .5; const j = (Z = oe[A == null ? void 0 : A.type].door) == null ? void 0 : Z.sound.error; r.playSound(j, { channel: "sfx", soundPos: this.pos, fallOff: 1, layer: this.layer, filter: "muffled" }) } this.surface = i.getGroundSurface(this.pos, this.layer); const C = this.surface.type == "water"; if (this.updateSubmersion(e, i), this.updateFrozenState(e), this.netData.dead || (this.stepDistance += h.length(h.sub(this.posOld, this.pos)), this.stepDistance > 5 && C || C && !this.wasInWater ? (this.stepDistance = 0, a.addRippleParticle(this.pos, this.layer, (K = this.surface) == null ? void 0 : K.data.rippleColor), r.playGroup("footstep_water", { soundPos: this.pos, fallOff: 3, layer: this.layer, filter: "muffled" })) : this.stepDistance > 4 && !C && (this.stepDistance = 0, r.playGroup(`footstep_${this.surface.type}`, { soundPos: this.pos, fallOff: 3, layer: this.layer, filter: "muffled" })), this.wasInWater = C), this.bleedTicker -= e, !this.netData.dead && (this.netData.downed && this.action.type == se.None || this.hasPerk("trick_drain")) && this.bleedTicker < 0) { this.bleedTicker = this.hasPerk("trick_drain") ? N.player.bleedTickRate * 3 : N.player.bleedTickRate; const $ = h.rotate(h.mul(this.dir, -1), (Math.random() - .5) * Math.PI / 3); $.y *= -1, window.CrazyGames || a.addParticle("bloodSplat", this.renderLayer, h.create(0, 0), h.mul($, o.ppu), 1, Math.random() * Math.PI * 2, this.container, this.renderZOrd + 1), w || r.playSound("player_bullet_hit_02", { channel: "hits", soundPos: this.pos, fallOff: 3, layer: this.layer, filter: "muffled" }) } if (this.gunSwitchCooldown -= e, this.fireDelay -= e, S && (I || this.lastSwapIdx != this.localData.curWeapIdx)) { const $ = this.lastSwapIdx; this.lastSwapIdx = this.localData.curWeapIdx; const j = F[this.netData.activeWeapon]; if (j.type == "melee" || j.type == "throwable") { if (j.type != "throwable" || this.lastThrowablePickupSfxTicker <= 0) { const Q = this.isLoadoutAvatar ? o.pos : this.pos; r.playSound(j.sound.deploy, { channel: "sfx", soundPos: Q, fallOff: 3 }) } } else if (j.type == "gun") { let Q = "gun_switch_01", he = !1; if (($ == 0 || $ == 1) && (this.lastSwapIdx == 0 || this.lastSwapIdx == 1) && this.fireDelay > 0) { const ze = F[this.localData.weapons[$].type]; j && ze && j.deployGroup !== void 0 && ze.deployGroup !== void 0 && j.deployGroup == ze.deployGroup && (he = !0) } this.gunSwitchCooldown > 0 || he ? Q = j.sound.deploy : this.gunSwitchCooldown = N.player.freeSwitchCooldown, r.stopSound(this.cycleSoundInstance), this.cycleSoundInstance = r.playSound(Q, { channel: "activePlayer" }), this.fireDelay = 0 } } if (r.isSoundPlaying(this.cycleSoundInstance) || (this.cycleSoundInstance = null), this.action.seq != this.action.seqOld && !this.isNew) { let $ = !0; !S && this.action.type != se.None && (this.action.throttleTicker = .5, this.action.throttleCount < 5 ? this.action.throttleCount++ : $ = !1), $ && this.playActionStartEffect(S, a, r) } if (this.action.seqOld = this.action.seq, this.updateActionEffect(S, v, a, r), this.action.throttleTicker -= e, this.action.throttleTicker < 0 && this.action.throttleCount > 0 && (this.action.throttleCount--, this.action.throttleTicker = .25), this.netData.hasteType && this.netData.hasteSeq != this.hasteSeq) { const j = { [Ve.None]: { particle: "", sound: "" }, [Ve.Windwalk]: { particle: "windwalk", sound: "ability_stim_01" }, [Ve.Takedown]: { particle: "takedown", sound: "ability_stim_01" }, [Ve.Inspire]: { particle: "inspire", sound: "ability_stim_01" } } [this.netData.hasteType]; this.isNew || r.playSound(j.sound, { channel: "sfx", soundPos: this.pos, fallOff: 1, layer: this.layer, filter: "muffled" }), (ae = this.hasteEmitter) == null || ae.stop(), this.hasteEmitter = a.addEmitter(j.particle, { pos: this.pos, layer: this.layer }), this.hasteSeq = this.netData.hasteSeq } else !this.netData.hasteType && this.hasteEmitter && (this.hasteEmitter.stop(), this.hasteEmitter = null); if (this.hasteEmitter && (this.hasteEmitter.pos = h.add(this.pos, h.create(0, .1)), this.hasteEmitter.layer = this.renderLayer, this.hasteEmitter.zOrd = this.renderZOrd + 1), this.netData.healEffect && !this.passiveHealEmitter ? this.passiveHealEmitter = a.addEmitter("heal_basic", { pos: this.pos, layer: this.layer }) : !this.netData.healEffect && this.passiveHealEmitter && (this.passiveHealEmitter.stop(), this.passiveHealEmitter = null), this.passiveHealEmitter && (this.passiveHealEmitter.pos = h.add(this.pos, h.create(0, .1)), this.passiveHealEmitter.layer = this.renderLayer, this.passiveHealEmitter.zOrd = this.renderZOrd + 1), S && !g) { const $ = this.localData.curWeapIdx, j = this.localData.weapons[$], Q = F[j.type]; if (!this.playedDryFire && this.Ur() == "gun" && (m.isBindPressed(E.Fire) || m.isBindDown(E.Fire) && Q.fireMode == "auto") && this.action.type == se.None && !f && !Q.ammoInfinite) { const he = this.localData.inventory[Q.ammo] || 0, ze = j.ammo; he == 0 && ze == 0 && (r.playSound(Q.sound.empty), this.playedDryFire = !0) } m.isBindDown(E.Fire) || (this.playedDryFire = !1) } this.gunRecoilL = _.max(0, this.gunRecoilL - this.gunRecoilL * e * 5 - e), this.gunRecoilR = _.max(0, this.gunRecoilR - this.gunRecoilR * e * 5 - e); const R = { playerBarn: t, map: i, audioManager: r, particleBarn: a }; this.updateAnim(e, R), this.currentAnim() == ce.None && (this.throwableState = "equip"), (this.currentAnim() == ce.Cook || this.currentAnim() == ce.Throw) && x.type != "throwable" && this.playAnim(ce.None, this.anim.seq); const V = this.selectIdlePose(), O = ci[V]; for (let $ = 0; $ < this.bones.length; $++) { const j = O[$] || L.identity, Q = this.anim.bones[$]; Q.weight > 0 ? this.bones[$].copy(L.lerp(Q.weight, j, Q.pose)) : this.bones[$].copy(j) } this.throwableStatePrev != this.throwableState && (this.visualsDirty = !0), this.throwableStatePrev = this.throwableState, this.visualsDirty && this.updateVisuals(t, i), this.visualsDirty = !1, this.updateAura(e, S, z), this.Zr(), this.updateRenderLayer(S, z, i), n.addPIXIObj(this.auraContainer, this.renderLayer, this.renderZOrd - 1, this.renderZIdx); const W = z.layer & 2 || (z.layer & 1) == 1 || (this.layer & 1) == 0; this.auraContainer.visible = !!(!this.netData.dead && W), n.addPIXIObj(this.container, this.renderLayer, this.renderZOrd, this.renderZIdx), this.isNew = !1 } render(e, t) { const i = e.pointToScreen(this.pos), r = e.pixels(1); if (this.container.position.set(i.x, i.y), this.container.scale.set(r, r), this.container.visible = !this.netData.dead, this.auraContainer.position.set(i.x, i.y), this.auraContainer.scale.set(r, r), P.debug && t.players) { de.addCircle(this.pos, this.rad, 16711680, 0); const a = F[this.netData.activeWeapon]; a.type === "gun" && de.addRay(this.pos, this.dir, a.barrelLength, 16711680, 0) } } updateRenderLayer(e, t, i) { const r = U.createCircle(this.pos, N.player.maxVisualRadius); let a = !1, m = !1, o = !1; const n = i.structurePool.getPool(); for (let w = 0; w < n.length; w++) { const g = n[w]; if (g.active) { for (let x = 0; x < g.stairs.length; x++) { const S = g.stairs[x], z = U.intersect(S.collision, r); if (z) { m = !0; const I = h.add(S.center, h.mul(S.downDir, -2.5)); let k = h.sub(I, this.pos); const v = h.length(k); k = v > 1e-4 ? h.div(k, v) : h.create(1, 0), o = lt.intersectSegmentDist(i.obstaclePool.getPool(), this.pos, k, v, .5, this.layer, !1) < v } e && S.noCeilingReveal && z && this.layer != 0 && (this.noCeilingRevealTicker = .25) } for (let x = 0; x < g.mask.length; x++) if (U.intersect(g.mask[x], r)) { a = !0; break } } } let p = this.layer, d = 18; m && (p & 1 && (t.layer & 1 || !o) || t.layer & 2 && !a) && (p |= 2), m && (p & 1) == (t.layer & 1) && (!a || t.layer == 0) && (p |= 2, d += 100); const f = this.__id + (this.netData.downed ? 0 : 262144) + (e ? 65536 : 0) + (this.rad > 1 ? 131072 : 0); this.renderLayer = p, this.renderZOrd = d, this.renderZIdx = f } updateVisuals(e, t) { var f; const i = F[this.netData.outfit], r = i.skinImg, a = this.bodyRad / N.player.radius; if (this.bodySprite.texture = X.from(r.baseSprite), this.bodySprite.tint = i.ghillie ? t.getMapDef().biome.colors.playerGhillie : r.baseTint, this.bodySprite.scale.set(.25, .25), this.bodySprite.visible = !0, this.netData.frozen && this.updateFrozenImage) { const w = t.getMapDef().biome.frozenSprites || []; if (w.length > 0) { const g = w[Math.floor(Math.random() * w.length)], x = _.oriToRad(this.netData.frozenOri) + Math.PI * .5 + (Math.random() - .5) * Math.PI * .25; this.bodyEffectSprite.texture = X.from(g), this.bodyEffectSprite.rotation = x, this.bodyEffectSprite.tint = 16777215, this.bodyEffectSprite.scale.set(.25, .25) } this.updateFrozenImage = !1 } if (t.factionMode && !i.ghillie) { const g = e.getPlayerInfo(this.__id).teamId, x = ["player-patch-01.img", "player-patch-02.img"], S = (g - 1) % x.length, z = x[S], I = N.teamColors[S], k = _.oriToRad(3) + Math.PI * .5; this.patchSprite.texture = X.from(z), this.patchSprite.rotation = k, this.patchSprite.tint = I, this.patchSprite.scale.set(.25, .25), this.patchSprite.visible = !0 } else this.patchSprite.visible = !1; const m = function(w, g, x) { w.texture = X.from(g), w.scale.set(.175, .175), w.tint = x, w.visible = !0 }, o = i.ghillie ? t.getMapDef().biome.colors.playerGhillie : r.handTint; m(this.handLSprite, r.handSprite, o), m(this.handRSprite, r.handSprite, o); const n = function(w, g, x) { w.texture = X.from("player-feet-01.img"), w.scale.set(.45, .45), w.rotation = Math.PI * .5, w.tint = g, w.visible = x }, p = i.ghillie ? t.getMapDef().biome.colors.playerGhillie : r.footTint; if (n(this.footLSprite, p, this.downed), n(this.footRSprite, p, this.downed), this.hasPerk("flak_jacket") && !i.ghillie ? (this.flakSprite.texture = X.from("player-armor-base-01.img"), this.flakSprite.scale.set(.215, .215), this.flakSprite.tint = 3671558, this.flakSprite.alpha = .7, this.flakSprite.visible = !0) : this.flakSprite.visible = !1, this.netData.chest == "" || i.ghillie) this.chestSprite.visible = !1; else { const g = F[this.netData.chest].skinImg; this.chestSprite.texture = X.from(g.baseSprite), this.chestSprite.scale.set(.25, .25), this.chestSprite.tint = g.baseTint, this.chestSprite.visible = !0 } if (this.hasPerk("steelskin") && !i.ghillie ? (this.steelskinSprite.texture = X.from("loot-melee-pan-black.img"), this.steelskinSprite.scale.set(.4, .4), this.steelskinSprite.anchor.set(.575, .5), this.steelskinSprite.tint = 16777215, this.steelskinSprite.visible = !0) : this.steelskinSprite.visible = !1, this.netData.helmet == "" || i.ghillie) this.helmetSprite.visible = !1; else { const g = F[this.netData.helmet].skinImg, x = (this.downed ? 1 : -1) * 3.33; this.helmetSprite.texture = X.from(g.baseSprite), this.helmetSprite.position.set(x, 0), g.spriteScale ? this.helmetSprite.scale.set(g.spriteScale, g.spriteScale) : this.helmetSprite.scale.set(.15, .15); let S = g.baseTint; t.factionMode && (S = e.getPlayerInfo(this.__id).teamId == 1 ? g.baseTintRed : g.baseTintBlue), this.helmetSprite.tint = S, this.helmetSprite.visible = !0 } if (this.getBagLevel() > 0 && !i.ghillie && !this.downed) { const w = [10.25, 11.5, 12.75], g = this.getBagLevel(), x = w[_.min(g - 1, w.length - 1)], S = (.4 + g * .03) * .5; this.backpackSprite.texture = X.from("player-circle-base-01.img"), this.backpackSprite.position.set(-x, 0), this.backpackSprite.scale.set(S, S), this.backpackSprite.tint = r.backpackTint, this.backpackSprite.visible = !0, function(z, I, k) { z.texture = X.from(I), z.tint = k }(this.backpackSprite, r.backpackSprite, r.backpackTint) } else this.backpackSprite.visible = !1; if (this.netData.wearingPan) { const w = F.pan.hipImg; this.hipSprite.texture = X.from(w.sprite), this.hipSprite.position.set(w.pos.x, w.pos.y), this.hipSprite.scale.set(w.scale.x, w.scale.y), this.hipSprite.rotation = w.rot, this.hipSprite.tint = w.tint, this.hipSprite.visible = !0 } else this.hipSprite.visible = !1; const d = F[this.netData.activeWeapon]; if (d.type == "gun") { this.gunRSprites.setType(this.netData.activeWeapon, a), this.gunRSprites.setVisible(!0), d.isDual ? (this.gunLSprites.setType(this.netData.activeWeapon, a), this.gunLSprites.setVisible(!0)) : this.gunLSprites.setVisible(!1); const w = this.bodyContainer.getChildIndex(this.handRContainer), g = this.bodyContainer.getChildIndex(this.handRContainer); let x = w + 1; (this.gunRSprites.magTop || d.worldImg.handsBelow) && (x = w - 1), x = _.max(x, 0), g != x && this.bodyContainer.addChildAt(this.handLContainer, x); const S = this.handRContainer.getChildIndex(this.gunRSprites.container), z = d.worldImg.handsBelow ? this.handRContainer.children.length : 0; S != z && this.handRContainer.addChildAt(this.gunRSprites.container, z) } else this.gunLSprites.setVisible(!1), this.gunRSprites.setVisible(!1); if (this.downed != this.wasDowned) if (this.wasDowned = this.downed, this.downed) { const w = this.bodyContainer.getChildIndex(this.footLContainer); this.bodyContainer.addChildAt(this.handLContainer, w), this.bodyContainer.addChildAt(this.handRContainer, w) } else this.bodyContainer.addChild(this.handLContainer), this.bodyContainer.addChild(this.handRContainer); if (d.type == "melee" && this.netData.activeWeapon != "fists") { const w = d.worldImg; this.meleeSprite.texture = X.from(w.sprite), this.meleeSprite.pivot.set(-w.pos.x, -w.pos.y), this.meleeSprite.scale.set(w.scale.x / a, w.scale.y / a), this.meleeSprite.rotation = w.rot, this.meleeSprite.tint = w.tint, this.meleeSprite.visible = !0; const g = this.handRContainer.getChildIndex(this.handRSprite), x = _.max(w.renderOnHand ? g + 1 : g - 1, 0); this.handRContainer.getChildIndex(this.meleeSprite) != x && this.handRContainer.addChildAt(this.meleeSprite, x); const S = this.bodyContainer.getChildIndex(this.handRContainer), z = _.max(w.leftHandOntop ? S + 1 : S - 1, 0); this.bodyContainer.getChildIndex(this.handLContainer) != z && this.bodyContainer.addChildAt(this.handLContainer, z) } else this.meleeSprite.visible = !1; if (d.type == "throwable") { const w = function(x, S) { var z, I; if (S.sprite && S.sprite != "none") { let k = S.sprite; t.mapDef.gameMode.spookyKillSounds && (k = er[k] || k), x.texture = X.from(k), x.position.set((z = S.pos) == null ? void 0 : z.x, (I = S.pos) == null ? void 0 : I.y), x.scale.set(S.scale, S.scale), x.rotation = Math.PI * .5, x.visible = !0 } else x.visible = !1 }, g = (f = d.handImg) == null ? void 0 : f[this.throwableState]; w(this.objectLSprite, g.left), w(this.objectRSprite, g.right) } else this.objectLSprite.visible = !1, this.objectRSprite.visible = !1; if ((this.downed || this.currentAnim() == ce.Revive) && (this.gunLSprites.setVisible(!1), this.gunRSprites.setVisible(!1), this.meleeSprite.visible = !1, this.objectLSprite.visible = !1, this.objectRSprite.visible = !1), this.downed && (this.backpackSprite.visible = !1), this.action.type != se.UseItem && this.action.type != se.Revive || this.netData.dead || this.netData.downed && !this.hasPerk("self_revive") || !this.hasPerk("aoe_heal")) this.auraPulseTicker = 0, this.auraPulseDir = 1, this.auraCircle.visible = !1; else { const w = F[this.action.item], g = w != null && w.aura ? w.aura.sprite : "part-aura-circle-01.img", x = w != null && w.aura ? w.aura.tint : 16711935, S = .125; let z = w ? N.player.medicHealRange : N.player.medicReviveRange; z *= S, this.auraCircle.texture = X.from(g), this.auraCircle.scale.set(z, z), this.auraCircle.tint = x, this.auraCircle.visible = !0 } if (t.perkMode && this.netData.role != "" && this.netData.helmet != "" && !i.ghillie) { const g = F[this.netData.role].visorImg; if (g) { const x = (this.downed ? 1 : -1) * 3.33; this.visorSprite.texture = X.from(g.baseSprite), this.visorSprite.position.set(x, 0) } g.spriteScale ? this.visorSprite.scale.set(g.spriteScale, g.spriteScale) : this.visorSprite.scale.set(.15, .15), this.visorSprite.visible = !0 } else this.visorSprite.visible = !1; this.bodyContainer.scale.set(a, a) } updateAura(e, t, i) { let r = !0; if (t || (r = ke.testCircleAabb(this.pos, this.rad, i.viewAabb.min, i.viewAabb.max)), this.auraViewFade = _.lerp(e * 6, this.auraViewFade, r ? 1 : 0), this.auraCircle.visible) { this.auraPulseTicker = _.clamp(this.auraPulseTicker + e * this.auraPulseDir * 1.5, 0, 1); const a = _.easeOutExpo(this.auraPulseTicker) * .75 + .25; (this.auraPulseTicker >= 1 || this.auraPulseTicker <= 0) && (this.auraPulseDir *= -1), this.auraCircle.alpha = a * this.auraViewFade } } Zr() { const e = function(i, r) { i.position.set(r.pos.x, r.pos.y), i.pivot.set(-r.pivot.x, -r.pivot.y), i.rotation = r.rot }; e(this.handLContainer, this.bones[Be.HandL]), e(this.handRContainer, this.bones[Be.HandR]), e(this.footLContainer, this.bones[Be.FootL]), e(this.footRContainer, this.bones[Be.FootR]); const t = F[this.netData.activeWeapon]; !this.downed && this.currentAnim() != ce.Revive && t.type == "gun" && t.worldImg.leftHandOffset && (this.handLContainer.position.x += t.worldImg.leftHandOffset.x, this.handLContainer.position.y += t.worldImg.leftHandOffset.y), this.handLContainer.position.x -= this.gunRecoilL * 1.125, this.handRContainer.position.x -= this.gunRecoilR * 1.125, this.bodyContainer.rotation = -Math.atan2(this.dir.y, this.dir.x) } playActionStartEffect(e, t, i) { let r = null; switch (this.action.type) { case se.Reload: case se.ReloadAlt: { const a = F[this.action.item]; a && (r = { sound: this.action.type == se.ReloadAlt ? a.sound.reloadAlt : a.sound.reload, channel: e ? "activePlayer" : "otherPlayers" }) } break; case se.UseItem: { const a = F[this.action.item]; a && (r = { sound: a.sound.use, channel: e ? "activePlayer" : "otherPlayers" }) } } if (i.stopSound(this.actionSoundInstance), r && this.playActionStartSfx && (this.actionSoundInstance = i.playSound(r.sound, { channel: r.channel, soundPos: this.pos, fallOff: 2, layer: this.layer, filter: "muffled" })), this.action.type == se.Reload || this.action.type == se.ReloadAlt) { const a = F[this.action.item]; if (a && a.caseTiming == "reload") for (let m = 0; m < a.maxReload; m++) { const o = m % 2 == 0 ? -1 : 1, n = Math.PI + Math.PI / 4 * o, p = a.maxReload <= 2 ? 1 : _.lerp(Math.random(), .8, 1.2); tr(this.action.item, n, p, this.pos, this.dir, this.renderLayer, this.renderZOrd + 1, t) } } } updateActionEffect(e, t, i, r) { var o; let a = ""; const m = {}; switch (this.action.type) { case se.UseItem: { const n = F[this.action.item], p = t.loadout; n.type == "heal" ? a = F[p.heal].emitter : n.type == "boost" && (a = F[p.boost].emitter), this.hasPerk("aoe_heal") && (m.scale = 1.5, m.radius = N.player.medicHealRange / m.scale, m.rateMult = .25); break } case se.Revive: { this.netData.downed && (a = "revive_basic"); break } } a && (!this.useItemEmitter || this.useItemEmitter.type != a) && ((o = this.useItemEmitter) == null || o.stop(), m.pos = this.pos, m.layer = this.layer, this.useItemEmitter = i.addEmitter(a, m)), this.useItemEmitter && (this.useItemEmitter.pos = h.add(this.pos, h.create(0, .1)), this.useItemEmitter.layer = this.renderLayer, this.useItemEmitter.zOrd = this.renderZOrd + 1), this.useItemEmitter && !a && (this.useItemEmitter.stop(), this.useItemEmitter = null), r.isSoundPlaying(this.actionSoundInstance) || (this.actionSoundInstance = null), this.actionSoundInstance && !e && r.updateSound(this.actionSoundInstance, "otherPlayers", this.pos, { layer: this.layer, fallOff: 2, filter: "muffled" }) } playItemPickupSound(e, t) { var r; const i = F[e]; i && (t.playSound((r = i.sound) == null ? void 0 : r.pickup, { channel: "ui" }), i.type == "throwable" && (this.lastThrowablePickupSfxTicker = .3)) } selectIdlePose() { const e = F[this.netData.activeWeapon]; let t = "fists"; return this.downed ? t = "downed" : "anim" in e && e.anim.idlePose ? t = e.anim.idlePose : e.type == "gun" ? e.pistol ? t = e.isDual ? "dualPistol" : "pistol" : e.isBullpup ? t = "bullpup" : e.isLauncher ? t = "launcher" : t = e.isDual ? "dualRifle" : "rifle" : e.type == "throwable" ? t = "throwable" : t = "fists", ci[t] ? t : "fists" } selectAnim(e) { var i; const t = function(r, a) { return { type: r, mirror: !!a && Math.random() < .5 } }; switch (e) { case ce.None: return t("none", !1); case ce.Cook: return t("cook", !1); case ce.Throw: return t("throw", !1); case ce.Revive: return t("revive", !1); case ce.CrawlForward: return t("crawl_forward", !0); case ce.CrawlBackward: return t("crawl_backward", !0); case ce.Melee: { const r = F[this.netData.activeWeapon]; if (!((i = r.anim) != null && i.attackAnims)) return t("fists", !0); const a = r.anim.attackAnims, m = Math.floor(Math.random() * a.length), o = a[m]; return t(o, o == "fists" && a.length == 1) } default: return t("none", !1) } } currentAnim() { return this.anim.type } playAnim(e, t) { this.anim.type = e, this.anim.data = this.selectAnim(e), this.anim.seq = t, this.anim.ticker = 0; for (let i = 0; i < this.bones.length; i++) { const r = this.anim.bones[i]; r.weight = 0, r.pose.copy(this.bones[i]) } } updateAnim(e, t) { if (this.anim.data.type == "none" && this.playAnim(ce.None, this.anim.seq), this.currentAnim() != ce.None) { const i = this.anim.ticker; this.anim.ticker += e * 1; const r = es[this.anim.data.type], a = r.keyframes; let m = -1, o = 0; for (; this.anim.ticker >= a[o].time && o < a.length - 1;) m++, o++; m = _.max(m, 0); const n = a[m].time, p = a[o].time, d = _.min((this.anim.ticker - n) / (p - n), 1), f = a[m].bones, w = a[o].bones, g = this.anim.data.mirror; for (let z = 0; z < this.anim.bones.length; z++) { const I = this.anim.bones[z]; let k = z; g && (k = z % 2 == 0 ? z + 1 : z - 1), f[k] !== void 0 && w[k] !== void 0 && (I.weight = m == o ? d : 1, I.pose.copy(L.lerp(d, f[k], w[k])), g && (I.pose.pos.y *= -1, I.pose.pivot.y *= -1, I.pose.rot *= -1)) } const x = o == a.length - 1 && _.eqAbs(d, 1); let S = this.anim.ticker; x && (S += 1); for (let z = 0; z < r.effects.length; z++) { const I = r.effects[z]; I.time >= i && I.time < S && this[I.fn].apply(this, [t, I.args]) } x && this.playAnim(ce.None, this.anim.seq) } } animPlaySound(e, t) { var a; const r = F[this.netData.activeWeapon].sound[t.sound]; r && ((a = e.audioManager) == null || a.playSound(r, { channel: "sfx", soundPos: this.pos, fallOff: 3, layer: this.layer, filter: "muffled" })) } animSetThrowableState(e, t) { this.throwableState = t.state } animThrowableParticles(e, t) { var i, r; if (F[this.netData.activeWeapon].useThrowParticles) { const a = h.rotate(h.create(.75, .75), Math.atan2(this.dir.y, this.dir.x)); (i = e.particleBarn) == null || i.addParticle("fragPin", this.renderLayer, h.add(this.pos, a), h.mul(h.rotate(this.dir, Math.PI * .5), 4.5), 1, Math.random() * Math.PI * 2, null, this.renderZOrd + 1); const m = h.rotate(h.create(.75, -.75), Math.atan2(this.dir.y, this.dir.x)); (r = e.particleBarn) == null || r.addParticle("fragLever", this.renderLayer, h.add(this.pos, m), h.mul(h.rotate(this.dir, -Math.PI * .25), 3.5), 1, Math.random() * Math.PI * 2, null, this.renderZOrd + 1) } } animMeleeCollision(e, t) { var r, a, m, o, n, p, d, f; const i = F[this.netData.activeWeapon]; if (i && i.type == "melee") { const w = this.getMeleeCollider(), g = w.rad + h.length(h.sub(this.pos, w.pos)), x = [], S = (r = e.map) == null ? void 0 : r.obstaclePool.getPool(); for (let v = 0; v < S.length; v++) { const b = S[v]; if (b.active && !b.dead && !b.isSkin && b.height >= N.player.meleeHeight && y.sameLayer(b.layer, this.layer & 1)) { let M = U.intersectCircle(b.collider, w.pos, w.rad); if (i.cleave || i.wallCheck) { const A = h.normalizeSafe(h.sub(b.pos, this.pos), h.create(1, 0)), D = lt.intersectSegment((a = e.map) == null ? void 0 : a.obstaclePool.getPool(), this.pos, A, g, 1, this.layer, !1); D && D.id !== b.__id && (M = null) } if (M) { const A = oe[b.type], D = h.add(w.pos, h.mul(h.neg(M.dir), w.rad - M.pen)), B = h.rotate(h.mul(M.dir, 7.5), (Math.random() - .5) * Math.PI / 3); x.push({ pen: M.pen, prio: 1, pos: D, vel: B, layer: this.renderLayer, zOrd: this.renderZOrd, particle: A.hitParticle, sound: A.sound.punch, soundFn: "playGroup" }) } } } const z = (m = e.playerBarn) == null ? void 0 : m.getPlayerInfo(this.__id).teamId, I = (o = e.playerBarn) == null ? void 0 : o.playerPool.getPool(); for (let v = 0; v < I.length; v++) { const b = I[v]; if (b.active && b.__id != this.__id && !b.netData.dead && y.sameLayer(b.layer, this.layer)) { const M = h.normalizeSafe(h.sub(b.pos, this.pos), h.create(1, 0)), A = ke.intersectCircleCircle(w.pos, w.rad, b.pos, b.rad); if (A && _.eqAbs(g, lt.intersectSegmentDist((n = e.map) == null ? void 0 : n.obstaclePool.getPool(), this.pos, M, g, N.player.meleeHeight, this.layer, !1))) { const D = (p = e.playerBarn) == null ? void 0 : p.getPlayerInfo(b.__id).teamId, B = h.rotate(M, (Math.random() - .5) * Math.PI / 3), T = i.sound[t.playerHit] || i.sound.playerHit; window.CrazyGames || x.push({ pen: A.pen, prio: D == z ? 2 : 0, pos: h.copy(b.pos), vel: B, layer: b.renderLayer, zOrd: b.renderZOrd, particle: "bloodSplat", sound: T, soundFn: "playSound" }) } } } x.sort((v, b) => v.prio == b.prio ? b.pen - v.pen : v.prio - b.prio); let k = x.length; i.cleave || (k = _.min(k, 1)); for (let v = 0; v < k; v++) { const b = x[v]; (d = e.particleBarn) == null || d.addParticle(b.particle, b.layer, b.pos, b.vel, 1, Math.random() * Math.PI * 2, null, b.zOrd + 1), (f = e.audioManager) == null || f[b.soundFn](b.sound, { channel: "hits", soundPos: b.pos, layer: this.layer, filter: "muffled" }) } } } initSubmergeSprites() { const e = function(i, r) { i.texture = X.from(r), i.anchor.set(.5, .5), i.tint = 16777215, i.alpha = 0, i.visible = !1 }; e(this.bodySubmergeSprite, "player-wading-01.img"), e(this.handLSubmergeSprite, "player-hands-01.img"), e(this.handRSubmergeSprite, "player-hands-01.img"), e(this.footLSubmergeSprite, "player-feet-01.img"), e(this.footRSubmergeSprite, "player-feet-01.img"); const t = new Se; t.beginFill(16711680, .5), t.drawCircle(0, 0, 38 * 2 * ui), t.position.set(0, 0), this.bodySubmergeSprite.addChild(t), this.bodySubmergeSprite.mask = t, this.bodySubmergeSprite.scale.set(.5, .5) } updateSubmersion(e, t) { var p, d, f, w; const i = ((p = this.surface) == null ? void 0 : p.type) == "water"; let r = 0; if (i) { const g = (d = this.surface) == null ? void 0 : d.data.river, x = g && !t.isInOcean(this.pos), S = x ? g.distanceToShore(this.pos) : t.distanceToShore(this.pos), z = x ? 12 : 16; r = _.remap(S, 0, z, .6, 1) } this.submersion = _.lerp(e * 4, this.submersion, r); const a = this.submersion * .8, m = (.9 - this.submersion * .4) * 2, o = 1 / (m * ui); this.bodySubmergeSprite.scale.set(m, m), this.bodySubmergeSprite.mask.scale.set(o, o), this.bodySubmergeSprite.alpha = a, this.bodySubmergeSprite.visible = a > .001, i && (this.bodySubmergeSprite.tint = (f = this.surface) == null ? void 0 : f.data.waterColor); const n = [this.handLSubmergeSprite, this.handRSubmergeSprite, this.footLSubmergeSprite, this.footRSubmergeSprite]; for (let g = 0; g < n.length; g++) { const x = n[g]; x.alpha = this.downed ? a : 0, x.visible = x.alpha > .001, i && (x.tint = (w = this.surface) == null ? void 0 : w.data.waterColor) } } updateFrozenState(e) { this.netData.frozen ? this.frozenTicker = .25 : (this.frozenTicker -= e, this.updateFrozenImage = !0), this.bodyEffectSprite.alpha = this.netData.frozen ? 1 : _.remap(this.frozenTicker, 0, .25, 0, 1), this.bodyEffectSprite.visible = this.frozenTicker > 0 } addRecoil(e, t, i) { t && (this.gunRecoilL += e), i && (this.gunRecoilR += e) } isUnderground(e) { if (this.layer != 1) return !1; const t = e.structurePool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.layers.length >= 2) { const a = r.layers[1]; if (U.intersectCircle(a.collision, this.pos, this.rad)) return a.underground } } return !0 } } class ir { constructor() { s(this, "playerPool", new _e(ns)); s(this, "playerInfo", {}); s(this, "playerIds", []); s(this, "teamInfo", {}); s(this, "groupInfo", {}); s(this, "playerStatus", {}); s(this, "anonPlayerNames", !1) } onMapLoad(e) {} update(e, t, i, r, a, m, o, n, p, d, f, w, g) { const x = this.playerPool.getPool(); for (let v = 0; v < x.length; v++) { const b = x[v]; b.active && b.update(e, this, o, p, a, n, m, r, d, t, f, w, g) } const S = this.getPlayerInfo(t), z = this.getPlayerById(t); this.setPlayerStatus(t, { pos: h.copy(z.netData.pos), health: z.localData.health, disconnected: !1, dead: z.netData.dead, downed: z.netData.downed, role: z.netData.role, visible: !0 }); const I = kr(o.factionMode), k = Object.keys(this.playerStatus); for (let v = 0; v < k.length; v++) { const b = this.playerStatus[k[v]], M = b.playerId, A = this.getPlayerInfo(M), D = this.getPlayerById(M); D ? (b.posDelta = h.length(h.sub(D.netData.pos, b.pos)), b.posTarget = h.copy(D.netData.pos), b.posInterp = _.clamp(b.posInterp + e * .2, e / I, 1), b.dead = D.netData.dead, b.downed = D.netData.downed) : b.posInterp = e / I; const B = h.sub(b.posTarget, b.pos), T = h.length(B), C = T > 1e-4 ? h.div(B, T) : h.create(1, 0), R = _.min(T, b.posDelta * b.posInterp); b.pos = h.add(b.pos, h.mul(C, R)), b.timeSinceVisible += e, b.timeSinceUpdate += e; const V = !b.dead || A.teamId != S.teamId && b.role != "leader" ? 0 : .6; b.minimapAlpha = _.smoothstep(b.timeSinceVisible, 0, .1) * _.lerp(_.smoothstep(b.timeSinceUpdate, 2, 2.5), 1, V), !o.factionMode && A.teamId != S.teamId && (b.minimapAlpha = 0), b.minimapVisible = b.minimapAlpha > .01 } } render(e, t) { const i = this.playerPool.getPool(); for (let r = 0; r < i.length; r++) { const a = i[r]; a.active && a.render(e, t) } } getPlayerById(e) { const t = this.playerPool.getPool(); for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.active && r.__id === e) return r } return null } setPlayerInfo(e) { this.playerInfo[e.playerId] = { playerId: e.playerId, teamId: e.teamId, groupId: e.groupId, name: e.name, nameTruncated: Y.truncateString(e.name || "", "bold 16px arial", 180), anonName: `Player${e.playerId-2750}`, loadout: y.cloneDeep(e.loadout) }, this.playerIds.push(e.playerId), this.playerIds.sort((t, i) => t - i) } deletePlayerInfo(e) { const t = this.playerIds.indexOf(e); t !== -1 && this.playerIds.splice(t, 1), delete this.playerInfo[e], delete this.playerStatus[e] } getPlayerInfo(e) { return this.playerInfo[e] || { playerId: 0, group: 0, teamId: 0, name: "", nameTruncated: "", anonName: "", loadout: {} } } recomputeTeamData() { this.teamInfo = {}, this.groupInfo = {}; const e = Object.keys(this.playerInfo); for (let r = 0; r < e.length; r++) { const a = this.playerInfo[e[r]], m = a.playerId, o = a.teamId; this.teamInfo[o] = this.teamInfo[o] || { teamId: o, playerIds: [] }, this.teamInfo[o].playerIds.push(m); const n = a.groupId; this.groupInfo[n] = this.groupInfo[n] || { groupId: n, playerIds: [] }, this.groupInfo[n].playerIds.push(m) } const t = Object.keys(this.teamInfo); for (let r = 0; r < t.length; r++) this.teamInfo[t[r]].playerIds.sort((a, m) => a - m); const i = Object.keys(this.groupInfo); for (let r = 0; r < i.length; r++) this.groupInfo[i[r]].playerIds.sort((a, m) => a - m) } getTeamInfo(e) { return this.teamInfo[e] } getGroupInfo(e) { return this.groupInfo[e] } updatePlayerStatus(e, t, i) { const r = this.getTeamInfo(e), a = i ? this.playerIds : r.playerIds; if (a.length != t.players.length) { console.error(`PlayerIds and playerStatus.players out of sync. OurLen: ${a.length} MsgLen: ${t.players.length} FactionMode: ${i}`); return } for (let m = 0; m < a.length; m++) { const o = a[m], n = t.players[m]; n.hasData && this.setPlayerStatus(o, n) } } setPlayerStatus(e, t) { const i = this.playerStatus[e] || { playerId: e, pos: h.copy(t.pos), posTarget: h.copy(t.pos), posDelta: h.create(0, 0), health: 100, posInterp: 0, visible: !1, dead: !1, downed: !1, disconnected: !1, role: "", timeSinceUpdate: 0, timeSinceVisible: 0, minimapAlpha: 0, minimapVisible: !1 }; i.minimapVisible || (i.pos = h.copy(t.pos), !i.visible && t.visible && (i.timeSinceVisible = 0)), i.visible = t.visible, i.visible && (i.timeSinceUpdate = 0), i.posTarget = h.copy(t.pos), i.posDelta = h.length(h.sub(t.pos, i.pos)), i.dead = t.dead, i.downed = t.downed, i.role = t.role, t.health !== void 0 && (i.health = t.health), t.disconnected !== void 0 && (i.disconnected = t.disconnected), this.playerStatus[e] = i } getPlayerStatus(e) { return this.playerStatus[e] } updateGroupStatus(e, t) { const i = this.getGroupInfo(e); if (i.playerIds.length != t.players.length) { console.error("PlayerIds and groupStatus.players out of sync"); return } for (let r = 0; r < i.playerIds.length; r++) { const a = i.playerIds[r], m = t.players[r], o = this.getPlayerStatus(a); o && (o.health = m.health, o.disconnected = m.disconnected) } } getGroupColor(e) { const t = this.getPlayerInfo(e), i = this.getGroupInfo(t.groupId), r = i ? i.playerIds.indexOf(e) : 0; return r >= 0 && r < N.groupColors.length ? N.groupColors[r] : 16777215 } getTeamColor(e) { const t = e - 1; return t >= 0 && t < N.teamColors.length ? N.teamColors[t] : 16777215 } getPlayerName(e, t, i) { const r = this.getPlayerInfo(e); if (!r) return ""; let a = r.name; return i && (a = r.nameTruncated), this.anonPlayerNames && this.getPlayerInfo(t).groupId != r.groupId && (a = r.anonName), a } addDeathEffect(e, t, i, r, a) { const m = this.getPlayerById(e), o = this.getPlayerById(t); if (m && (o != null && o.hasPerk("turkey_shoot"))) { r.playGroup("cluck", { soundPos: m.pos, layer: m.layer, muffled: !0 }), r.playSound("feather_01", { channel: "sfx", soundPos: m.pos, layer: m.layer, muffled: !0 }); const n = Math.floor(y.random(30, 35)); for (let p = 0; p < n; p++) { const d = h.mul(h.randomUnit(), y.random(5, 15)); a.addParticle("turkeyFeathersDeath", m.layer, m.pos, d) } } } } class hs { constructor() { s(this, "__id"); s(this, "__type"); s(this, "active"); s(this, "particle"); s(this, "type"); s(this, "pos"); s(this, "rad"); s(this, "layer"); s(this, "interior") } init() {} free() { this.particle.fadeOut(), this.particle = null } updateData(e, t, i, r) { var a; this.type = e.type, this.pos = h.copy(e.pos), this.rad = e.rad, t && (this.layer = e.layer, this.interior = e.interior), i && (this.particle = r.smokeBarn.allocParticle(), (a = this.particle) == null || a.init(this.pos, this.rad, this.layer, this.interior)), this.particle.posTarget = h.copy(this.pos), this.particle.radTarget = this.rad } } const pi = ["part-smoke-02.img", "part-smoke-03.img"]; class cs { constructor() { s(this, "active", !1); s(this, "zIdx", 0); s(this, "sprite", re.from(pi[Math.floor(Math.random() * pi.length)])); s(this, "pos"); s(this, "posTarget"); s(this, "rad"); s(this, "radTarget"); s(this, "rot"); s(this, "rotVel"); s(this, "fade"); s(this, "fadeTicker"); s(this, "fadeDuration"); s(this, "tint"); s(this, "layer"); s(this, "interior"); this.sprite.anchor = new Bt(.5, .5), this.sprite.visible = !1 } init(e, t, i, r) { this.pos = h.copy(e), this.posTarget = h.copy(this.pos), this.rad = t, this.radTarget = this.rad, this.rot = y.random(0, Math.PI * 2), this.rotVel = Math.PI * y.random(.25, .5) * (Math.random() < .5 ? -1 : 1), this.fade = !1, this.fadeTicker = 0, this.fadeDuration = y.random(.5, .75), this.tint = y.rgbToInt(y.hsvToRgb(0, 0, y.random(.9, .95))), this.layer = i, this.interior = r } fadeOut() { this.fade = !0 } } class rr { constructor() { s(this, "smokePool", new _e(hs)); s(this, "particles", []); s(this, "zIdx", 2147483647) } allocParticle() { let e = null; for (let t = 0; t < this.particles.length; t++) if (!this.particles[t].active) { e = this.particles[t]; break } return e || (e = new cs, this.particles.push(e)), e.active = !0, e.zIdx = this.zIdx--, e } update(e, t, i, r, a) { for (let m = 0; m < this.particles.length; m++) { const o = this.particles[m]; if (o.active) { o.rad = _.lerp(e * 3, o.rad, o.radTarget), o.pos = _.v2lerp(e * 3, o.pos, o.posTarget), o.rotVel *= 1 / (1 + e * .1), o.rot += o.rotVel * e, o.fadeTicker += o.fade ? e : 0, o.active = o.fadeTicker < o.fadeDuration; const n = _.clamp(1 - o.fadeTicker / o.fadeDuration, 0, 1) * .9; let p = o.layer; (y.sameLayer(o.layer, i.layer) || i.layer & 2) && (o.layer == 1 || !(i.layer & 2) || !r.insideStructureMask(U.createCircle(o.pos, 1))) && (p |= 2); const d = o.interior ? 500 : 1e3; a.addPIXIObj(o.sprite, p, d, o.zIdx); const f = t.pointToScreen(o.pos), w = t.pixels(o.rad * 2 / t.ppu); o.sprite.position.set(f.x, f.y), o.sprite.scale.set(w, w), o.sprite.rotation = o.rot, o.sprite.tint = o.tint, o.sprite.alpha = n, o.sprite.visible = o.active } } } } function fi(u, e, t) { const i = e - u, r = i * t; return Math.abs(r) < .01 ? i : r } function us() { const u = new Se; return u.position.set(0, 0), u.scale.set(1, 1), u.__zOrd = 0, u.__zIdx = 0, u } function gt(u, e, t, i, r) { u.moveTo(e, t), u.lineTo(e, t + r), u.lineTo(e + i, t + r), u.lineTo(e + i, t), u.lineTo(e, t), u.closePath() } class ar { constructor(e, t) { s(this, "zIdx", 0); s(this, "layer", 0); s(this, "layerAlpha", 0); s(this, "groundAlpha", 0); s(this, "underground", !1); s(this, "layers", []); s(this, "ground", new Se); s(this, "layerMask", us()); s(this, "debugLayerMask", null); s(this, "layerMaskDirty", !0); s(this, "layerMaskActive", !1); this.game = e, this.canvasMode = t; for (let i = 0; i < 4; i++) this.layers.push(new ds(`layer_${i}`)); this.ground.alpha = 0 } free() { var e; (e = this.layerMask.parent) == null || e.removeChild(this.layerMask), this.layerMask.destroy(!0) } addPIXIObj(e, t, i, r) { if (!e.transform) { const o = new Error, n = JSON.stringify({ type: "addChild", stack: o.stack, browser: navigator.userAgent, playing: this.game.playing, gameOver: this.game.gameOver, spectating: this.game.spectating, time: this.game.playingTicker, mode: this.game.teamMode, layer: t, zOrd: i, zIdx: r }); console.error(n) } e.__layerIdx === void 0 && (e.__layerIdx = -1, e.__zOrd = -1, e.__zIdx = -1); let a = t; t & 2 && (a = i >= 100 ? 3 : 2), !(e.parent == this.layers[a] && e.__zOrd == i && (r === void 0 || e.__zIdx == r)) && (e.__layerIdx = a, e.__zOrd = i, e.__zIdx = r !== void 0 ? r : this.zIdx++, this.layers[a].addSortedChild(e)) } setActiveLayer(e) { this.layer = e } setUnderground(e) { this.underground = e } resize(e, t) { const i = e.mapLoaded ? e.getMapDef().biome.colors.underground : 1772803; this.ground.clear(), this.ground.beginFill(i), this.ground.drawRect(0, 0, t.screenWidth, t.screenHeight), this.ground.endFill(), this.layerMaskDirty = !0 } redrawLayerMask(e, t) { const i = this.layerMask; if (this.canvasMode) { if (i.clear(), this.layerMaskActive) { i.beginFill(16777215, 1), i.drawRect(0, 0, e.screenWidth, e.screenHeight); const r = t.structurePool.getPool(); for (let a = 0; a < r.length; a++) { const m = r[a]; if (m.active) for (let o = 0; o < m.mask.length; o++) { const n = m.mask[o], p = h.mul(h.sub(n.max, n.min), .5), d = h.add(n.min, p), f = e.pointToScreen(h.sub(d, p)), w = e.pointToScreen(h.add(d, p)); i.drawRect(f.x, f.y, w.x - f.x, w.y - f.y) } } i.endFill() } } else { if (this.layerMaskDirty) { this.layerMaskDirty = !1, i.clear(), i.beginFill(16777215, 1), gt(i, 0, 0, 1024, 1024); const m = t.structurePool.getPool(); for (let o = 0; o < m.length; o++) { const n = m[o]; if (n.active) for (let p = 0; p < n.mask.length; p++) { const d = n.mask[p], f = h.mul(h.sub(d.max, d.min), .5), w = h.add(d.min, f), g = w.x - f.x, x = w.y - f.y, S = f.x * 2, z = f.y * 2; i.beginHole(), gt(i, g, x, S, z), i.endHole() } } i.endFill() } const r = e.pointToScreen(h.create(0, 0)), a = e.scaleToScreen(1); i.position.set(r.x, r.y), i.scale.set(a, -a) } } redrawDebugLayerMask(e, t) { const i = this.debugLayerMask; i.clear(), i.beginFill(16711935, 1); const r = t.structurePool.getPool(); for (let o = 0; o < r.length; o++) { const n = r[o]; if (n.active) for (let p = 0; p < n.mask.length; p++) { const d = n.mask[p], f = h.mul(h.sub(d.max, d.min), .5), w = h.add(d.min, f), g = w.x - f.x, x = w.y - f.y, S = f.x * 2, z = f.y * 2; gt(i, g, x, S, z) } } i.endFill(); const a = e.pointToScreen(h.create(0, 0)); e.pointToScreen(h.create(1, 0)); const m = e.scaleToScreen(1); i.position.set(a.x, a.y), i.scale.set(m, -m) } update(e, t, i, r) { const a = this.layer > 0 ? 1 : 0; this.layerAlpha += fi(this.layerAlpha, a, e * 12); const m = this.layer == 1 && this.underground ? 1 : 0; this.groundAlpha += fi(this.groundAlpha, m, e * 12), this.layers[0].alpha = 1, this.layers[1].alpha = this.layerAlpha, this.layers[2].alpha = 1, this.layers[3].alpha = 1, this.ground.alpha = this.groundAlpha, this.layers[0].visible = this.groundAlpha < 1, this.layers[1].visible = this.layerAlpha > 0, this.ground.visible = this.groundAlpha > 0, this.redrawLayerMask(t, i); const o = this.layer == 0; o && !this.layerMaskActive ? (this.layers[2].mask = this.layerMask, this.layers[2].addChild(this.layerMask), this.layerMaskActive = !0) : !o && this.layerMaskActive && (this.layers[2].mask = null, this.layers[2].removeChild(this.layerMask), this.layerMaskActive = !1); for (let n = 0; n < this.layers.length; n++) this.layers[n].checkSort() } } class ds extends ie { constructor(t = "") { super(); s(this, "dirty", !0); this.debugName = t } addSortedChild(t) { this.addChild(t), this.dirty = !0 } checkSort() { return this.dirty ? (this.children.sort((t, i) => t.__zOrd == i.__zOrd ? t.__zIdx - i.__zIdx : t.__zOrd - i.__zOrd), this.dirty = !1, !0) : !1 } } const at = 2, wi = 1e-5; class ps { constructor(e, t) { s(this, "container", new ie); s(this, "lineSprites", new fs); s(this, "padScaleBase", 1); s(this, "padScaleDown", .6); s(this, "padScalePos", .25); s(this, "moveDetected", !1); s(this, "shotDetected", !1); s(this, "shotDetectedOld", !1); s(this, "touchingAim", !1); s(this, "display", !0); s(this, "moveStyle", "locked"); s(this, "aimStyle", "locked"); s(this, "touchAimLine", !0); s(this, "touchPads"); s(this, "playerMovement", { left: !1, right: !1, up: !1, down: !1, moveLen: 0 }); s(this, "analogMovement", { toMoveDir: h.create(1, 0), toMoveLen: 0 }); s(this, "aimMovement", { toAimDir: h.create(1, 0), toAimLen: 0 }); s(this, "leftLockedPadCenter", h.create(0, 0)); s(this, "rightLockedPadCenter", h.create(0, 0)); s(this, "padPosBase", 48); s(this, "padPosRange", 0); s(this, "movePadDetectMult", 1); s(this, "shotPadDetectMult", 1.075); s(this, "turnDirCooldown", .5); s(this, "turnDirTicker", 0); s(this, "mobileOffsetLandscape", 25); s(this, "mobileOffsetPortrait", 100); s(this, "lockedPadOffsetLandscape", h.create(126, 100)); s(this, "lockedPadOffsetPortrait", h.create(96, 160)); s(this, "lockedPadOffsetYLandscapeSafari", 120); s(this, "lockedPadOffsetYPortraitSafari", 240); this.input = e, this.config = t; const i = function(n, p) { const d = re.from("pad.img"); return d.anchor.set(.5, .5), d.scale.set(1, 1), d.alpha = .2, d.visible = !1, d.tint = p, n.addChild(d), d }, r = () => ({ touched: !1, centerPos: h.create(0, 0), touchPos: h.create(0, 0), centerSprite: i(this.container, 0), touchSprite: i(this.container, 16777215) }); this.touchPads = [r(), r()]; const a = function(n) { return ["locked", "anywhere"].includes(n) ? n : "anywhere" }, m = a(t.get("touchMoveStyle")), o = a(t.get("touchAimStyle")); this.setMoveStyle(m), this.setAimStyle(o), this.setTouchAimLine(!!t.get("touchAimLine")), this.init() } getTouchMovement(e) { return this.getMovement(e) } getAimMovement(e, t) { const i = e.localData.curWeapIdx == N.WeaponSlot.Throwable; return this.getAim(i, t) } setAimDir(e) { this.aimMovement.toAimDir = h.copy(e) } getMovement(e) { let t = null, i = null, r = !1, a; this.moveDetected = !1; for (let o = 0; o < this.input.touches.length; o++) { const n = this.input.touches[o]; if (!n.isDead && this.isLeftSideTouch(n.posDown.x, e)) { const p = this.moveStyle == "anywhere" ? n.posDown : this.leftLockedPadCenter, d = h.sub(n.pos, p), f = h.length(d); if (f > at) { const w = (f - at) / (this.padPosRange / this.movePadDetectMult - at); a = w > wi ? h.div(d, w) : this.analogMovement.toMoveDir, this.analogMovement = { toMoveDir: h.create(a.x, a.y * -1), toMoveLen: w }, this.moveDetected = !0 } i = this.getConstrainedPos(p, n.pos, f), t = p, r = !0; break } } const m = this.touchPads[0]; return m.touched = r, r && this.moveStyle == "anywhere" ? m.centerPos = h.copy(t) : m.centerPos = h.c
